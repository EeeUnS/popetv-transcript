예, 안녕하세요 포프입니다
제가 이제
오늘부터 프라우드넷에서 일을 하기 시작했는데요
그건 농담이고,
KGC때 받았던 티셔츠에요.
뭐 일단,  오늘은 사실 멀티스레딩 얘기를 하긴 할 건데
아
뭐 이 티셔츠를 입은게 잠깐
여담을을 하려고 해요
제가 얼마 전에
그 네트워킹 프로그래밍을
좀 하려고 생각을 한 적이 있어서
생각만 하고 전 별로 안 하는데
맨날 생각만 하는거 같애
생각해보니까 망상주의자야
어, 근데
그때 이제 게임 쪽은 아니고
이제 뭐, 메신저 쪽이나
뭐
스트리밍 요쪽을 생각을 하면서
p2p생각을 좀 했었거든요
모바일 쪽에서 p2p를 할 일이 있어서
근데 뭐,  p2p가 좀 어렵고... 
뭐.. 위에서 릴레이도 좀 해줘야하고
막 이런
생각을 했었는데
최근에 또 다른 사람하고 그냥
그런 비슷한 얘기를 하다가
아마 최재규 님이었던 거 같아요
지금
옛날에 아마 NC계시다가
지금 인디 하시고 계실텐데
최재규 님하고 이제 저희 IRC
채팅방이 있거든요?
저희 Game dev forever 에서 하는
이제 IRC
채팅방이 있는데
거기서이제 얘기를 하다가
거긴가? 인디인가 둘 중에
두 채널 중에 하나에서 얘기를 하다가
뭐 이런 저런 얘기를 하다가
그 얘기를 해 주셨던 거 같아요
그렇게
p2p나 이런 거 잘 지원해주고
p2p에서 실패하면 릴레이로 곧바로
해주는 그 정도의
서비스를 정말 잘 지원해주는
제품은
넷텐션
프라우드넷? 넷텐션 그거 정도 밖에
없다고
그리고 다른 것들을
자기가 직접 또 해야 되고
제가 볼 때 결과적으로
게임엔진의 미래는
네트워크쪽을 이제 엔진 레벨에서
 점점 지원을 해야 된다고
보거든요 대표적인 예로 이제
히어로 엔진 같은 경우가 그렇고
뭐 거기는 서버호스팅부터
클라우드로 해 갖고
스케일링까지 전부 다
그 쪽에서 해결을 해주니까
그렇게 된다면 결국에는
이런 뭐 p2p의 문제
릴레이 서버 문제
이런 것들도 결과적으로는
게임 엔진은 일부가 되어서
조만간 나올 거라고 생각해요
그리고 그거를 잘 잡아서
결과적으로 클라이언트 프로그래머 몇 하고
뭐 아티스트 몇 하고
만들 수 있는
게임을 만들 수 있는 플랫폼을
제공하는 회사가
결과적으로는 게임 엔진의
우위를 갖출 거라고 생각을 하고
그런 의미에서 이제
넷텐션의  현재 위치는
굉장히 좋죠
혼자 독자 노선으로으로 가기보다는
당연히 다른 게임엔진 속에
자체적으로 포함이 돼서
그런 서버호스팅이라든가 뭐
서버 스케일링 이런 부분까지 어떻게 해 줄
수 있는 그런 솔루션을 조금씩
더 개발하면 좋겠지만
물론 뭐,
배현직 사장님이 이미 그런걸 하고
있으실 거라고
생각하는데
어찌보면 히어로 엔진같이
이렇게 좀 하나의 완전한 플랫폼
이런식으로 나오면 좀 더 좋지
않을까 하는 생각을 해요
그래서 뭐 어쨋든 간에
넷텐션 광고는 또 대충 했고
여담은 거기였고
(저는) 넷텐션에서 일하지는 않습니다
농담이었습니다 그거는
일한다라고 했던 것
멀티스레딩 얘기로 가 볼게요
저번 편에서이제
뭐 멀티 스레딩하고 이제 ref counting(reference counting)하고
그런 얘길 하면서
제가 멀티스레딩 안 들어간다고 
말씀을 드렸고
그러고
어찌보면은
결과적으로 멀티스레딩을
가지 않으면 그럼 reference counting의문제
그러니까 reference counting의 속도 저하 문제를
고민할 필요도 없어요
왜냐면 reference counting 쓰면 돼요
충분히 빨라요
싱글스레딩에서 락 걸고
atomic increase, decrease 안 하는 상황에서
그런데
음
예전에 이제
멀티 스레딩을 안 할 수는
없잖아요 사실 뭐 예전엔 뭐
그런 거 있죠
프리 런치(free lunch)는 이제 끝났다?
공짜 점심은 끝났다라는 얘기로 시작을 해서
우리가 무어의 법칙에 의해서
싱글스레드로 갔어도
매년 몇 배씩
빨라졌지만 이제 그
물리적인 한계에 도달했기
때문에
이제는 그냥
멀티 코어로 가야된다.
그래서 예전에 싱글스레드로 만들었던
게임들이나 뭐, 프로그램들
실행 해 보면은
cpu 점유율이
한 12% 코어가 8개면
7개는 노니까 그렇게 돼서 이제 그게 문제다.
그리고 그걸 다 써야지만,
게임이 빨리 돈다. 해서
멀티스레딩을 엄청나게 했어요
2000... 한...5, 6년 부터 2003, 4년 부터
그 때
여러 가지 실수를 솔직히 해 왔죠.
게임 개발자 입장에서
처음에는
단순히그냥
어, 그래 업데이트 루프는 이 스레드에서
렌더링 루프는 저 스레드에서
그렇게 해서 두 개로 나누던가
이제 오디오 스레드 새로 만들고,
파티클 스레드 새로 만들고
그래서
각 스레드마다
무슨
하나의 할 일을 주는 거
근데 문제는
결과적으로 업데이트 스레드가
렌더링스레드 보다 빠를 수도 있고,
그럼 경우에선 멈춰있고, 기다리니까
그런 게 문제 였고,
그리고 뭐, 데이터 카피 하고
더블 버퍼링 하고
뭐, 이거 할 때 안 지워져야 되고
이런 여러 가지 문제도 있었고
뭐, 그 뒤에 여러가지 시행착오를 겪다가
결과적으로는
ps3가 잘 한게 하나가 있어요
ps3가 다른 건 다 개판쳤어도
하나 잘한거는
잡 시스템(Job System)을 만들었다는 것
잡 시스템의 개념이 뭐냐면
얘네는 cpu가 하나가 있고,
하나였나? 두개였나?
뭐 몇 개가 있고
다음에 SPU라는게 아홉개가 있었잖아요
전혀 색다른 모양의 cpu들
그래서 여기서 돌리기 위해서는
특별한코드를 만들어서
"그래, 여기 CPU에서 이런걸 준비했으니까
이거를 다 아홉 개 잡에서 실행을 시켜서
끝내고 돌아오렴"
그런 개념이었는데
그 때 이후로
모든 멀티스레딩 방법이 사실
이 정도로 많이 돌아 갔어요.
저희는 이제 잡 시스템이라고 하고
태스크 시스템(Task System)이라고도 많이
들으셨을 거고 뭐 결과적으로는
잡을 어떻게 분리하냐,
분류하냐 그 차이인데,
뭐가 더 빠르냐, 느리냐
뭐 어떻게 그룹짓느냐?
뭐 결과적으로는
비슷한구요
그래서 개념은 뭐냐면
아~
아~~
아~~~
어찌보면 여태까지 멀티스레딩이 힘들었던 이유는
프로그래밍 패러다임 자체가 저희가 이제
오브젝트 오리엔티드 시스템을(Object Oriented System)
시스템을 쓰잖아요.
OOP를 쓰고
거기다 이제 뭐 procedure이라고도 하고
이거는...
C 스타일 그런
그런거섰는데 문제는 뭐였냐면
전 코드가 실행했던 그 상태에 의존해서
다음 코드가 유지가 된다
그래서 그런 상태의 값을
기억을 해야지만 무언가
전에 바꿨던 상태 값에 의존해서 뭔가
상태를 바꾸고 이렇기 때문에
여러가지 스레드에서 이 상태를
바꾸기 시작을 하면은
"그게 레이스 컨디션(Race Condition)
이 생긴다"가 문제였거든요?
그래서 그거를 해결하는
방법으로
뭐 예전부터 있었던 프로그래밍 방식이지만
이제 Functional 프로그래밍이 그래서 있는거고요
Functional 프로그래밍은
한마디로
하나의 실행주체가
독자적인 거기 때문에
서로 다른 실행위치의 애들 끼리
건드리지 않는 거예요
그래서 제가 말씀드렸던 잡시스템도
비슷한 개념이었고,
태스크 시스템도 비슷한 개념이에요
이런 이런 이런 태스크를
다 독자적으로 구성을 해서
각 태스크가
여러 스레드에서 동시에 실행이 돼도
서로 영향을 안 미치는
그런 쪽으로 멀티스레딩이 가고 있고
제가 원하는 멀티스레딩 방법도
사실은 그 쪽이에요
그래서
아직도 여러 게임 회사에서는
약간 좀 예전 방식의
멀티스레딩을 많이 구현을 해요
뭐 새로 시스템 만들고
새로 엔진 만든다고 하는
제가 몬트리올에 있을때 있었던 그 회사도
스퀘어에닉스 산하의 그 회사도
엔진 자체를 만드는데
그 패러다임에서 벗어나지
못하더라고요 잘
그래서 아 저거는 아니구나
그래서 제가 원하는 시스템은
이거에요.
뭐 이미,
많은 분들이 하시고
계시겠지만
제가 제대로 구현하는 회사는
한 군데 밖에 못 봤어요
제가 다 몸담았던 회사 중에
결과적으로 모든건 싱글스레드에요
각 스레드가 분리된다는 개념은
일단은 없어요
모든 건 싱글스레드로 실행을 하되
각 구성요소가 멀티스레드,
잡으로 뻗치는 거에요 예를 들어서
애니메이션 업데이트를 하겠다 그러면,
애니메이션, 그 게임의
그러니까 애니메이션 업데이트 단계가
딱 CPU에서 있는 거죠
그러면, 이 CPU단계에서는
각 애니메이션이 있는 물체들의
컴포넌트가 있잖아요?
그래서 컴포넌트 기반 시스템이
이 태스크기반 시스템이 잘 돌아요.
그래서 애니메이션 컴포넌트 들이
쫙 있잖아요 array가. 그러면 그
각각의 array에 대해서 그걸
멀티스레딩으로 돌리는 거에요.
그래서 제 개념은 뭐냐면
애니메이션 업데이트 한 줄
그래서 모든 태스크가 왕창 만들고
이 태스크를
여러 스레드에서
실행을 시키는거죠
그러고 그 실행이 끝날 때 까지는
이게 멈춰있는거에요. 이 CPU가
아니면
아니면 얘도 그 중에 하나를 돌리고 있겠지만
뭐 굳이 멈출 필요는 없고
여러가지 뭐 dependency를 만드는
법도 있는데 간단하게 얘기하면,
기다리는 거에요
그래서, 벌어져서 멀티스레딩이 쫘악
해서 모든 애니메이션이 끝날 때 까지 기다렸다가
이게뭉치죠
그럼 딱 뭉치면 그 순간에 다음 잡을
실행하는 거에요
뭔진 모르겠지만 뭐 파티클 업데이트.
그러면
딱 멈추고, 파티클 업데이트 쫙 한 다음에 또 멈추고,
그래서 마지막 단게에는 렌더까지 가겠죠
그럼 렌더에 가서는
예전에 이제 좀
힘들었어요 왜냐하면,
렌더링 자체의 잡을 submit하는 경우에
멀티스레딩이 지원이 잘 안 됐거든.
그리고 DirectX11에서
지원한다고 했지만
실제 드라이버 레벨에서는
잘 지원이 안 됐고
그래서
이거를 굉장히 고생을 많이
했어요 사람들이 사실은
제가 볼 땐 이제
다음 드라이버가
DirectX11.2 인가?
뭐 요번에...
12였나?
거기서 나왔던 그...
그 뭐야,  프레젠테이션 보면
그게 잘 되게도 하는 거 같아요
그래서 렌더링 할때도 딱 갈라줘서
모든 것을 이제 커맨드 라인에
추가를 하는 거거든요
곧바로 submit 하는 게 아니라 
그러면 커맨드라인 동시에 쫙 만들어 주고
뭉치면서 그거를 한꺼번에 렌더링에
쫙 뿌려주고
그래서 모든게 벌려졌다 줄여졌다
벌려졌다 줄여졌다 하면은
결과적으로는
뭐, 약간의
100%를 쓸 수는 없겠지만
어떤 멀티스레딩 개념에 가도
100%를 못써요 모든 코어를
그래도 굉장히
멀티 스레딩에 가까운
그러니까 거의 100%에 가까운
그런 성능 점유율이 나오고
그러고,
아까 말씀드렸던
락이나 언락
아까가 아니고 저번 비디오에서 말씀드렸던
그런 락이나 언락을 걸 이유도 없고
ref count 같은 경우에도 뭐,
굳이 걱정 안해도 되고요.
이 잡이 벌어지는 동안에는
ref count란 개념이 없는거에요
자체적인 독립적인 거기 때문에
그래서
결과적으로 제가 원하는 렌더링 방식
렌더링이 아니구나
게임 엔진의
게임 루프 방식은 그거에요
게임 루프는 싱글 스레드
모든게 한 줄로 가되 각 잡을
여러 개로 벌린다
그럼 이제 그게
게임 엔진 자체를 처음부터 디자인을
잘 안 해놓으면은
이 컴포넌트가 저 컴포넌트를 가져오고
뭐 이런 문제가 생겨서
문제가 생기거든요
근데
처음부터 그거를
정립을 잘해 놓으면 이 컴포넌트는 언제나
이거 먼저 업데이트 되고
얘가 업데이트 될 떈 이 컴포넌트를
수정을 안 하고 이런 제한을 잘 걸어두면
충분히 가능한 엔지니어 제가
예전에도 한 번
해봤었고 사실은
그 C#으로 한 번 컴포넌트 기반
오브젝트 엔진을 만든 적이 있는데
오브젝트..
컴포넌트 기반 오브젝트
게임 오브젝트를 기반으로 한
게임엔진을 만든 적이 있는데
그 때 비슷한 걸 봤어요 근데
제가
굉장히 복잡한 게임은
아니었지만 그걸 했을 때
저는 충분히 나왔거든요 이렇게
벌리고 줄고 벌리고 줄고 하는게?
그래서 게임엔진을 앞으로 디자인하시는 분들은
결과적으로 그렇게 가셔야 할 거에요
그러면은
뭐 코어가 500개가 되던 1000개가 되던
문제없이 똑같이 돌 거고,
그리고 뭐 어떤 의미에서는 이미 뭐 쿠다나
뭐 컴퓨트 셰이더(Compute Shader, 컴퓨트 쉐이더)도
똑같은 일을 하고 있는 거죠
사실은
데이터 Output을 뭐 텍스쳐 같은걸로
잡아두고 메모리 블럭 잡아두고
요 메모리 블럭은 요 코어에서만
아 사용하는거 그런식으로 하는 거기 때문에
메모리는 조금 더 많이 먹을 수 있어요 결과적으론. 근데
메모리는 어차피 이제 싸니까
cpu보다 메모리가 더 싼거 같아요 가면 갈 수록
그래서 그 문제도
웬만큼 정립이 되는 거 같고
그래서 제가 원하는 게임 루프는
싱글 스레드라는걸 말씀드리고 싶어요
싱글스레드에 태스크시스템, 잡시스템에 기반한 거고
그리고 이제 C나 C++에서 돌 수 있는 
태스크 시스템이
공짜로 나왔던 것 중에는
그다지 쓸만한 게 없었던거 겉아요
뭐 TBB(Threading Building Blocks)정도가
굉장히 좋은거였는데
뭐 C#이나 그런거에서 이제
parallel foreach 이런거 있죠
고게 바로 그거에요.
functional programming이
람다 개념 그래서 뭐
그거는 굉장히 좋은 방향인데
요번에... 비주얼...
그러니까 마이크로 소프트에서
마이크로소프트도 참여했고,
인텔도 참여했고
그래서 이제 그거를
라이브러리화 해서 하나로
통합하려는 움직임이 있어요
제 생각에 제가 지금 정확히 스펙은
기억이 안나는데
c++ 표준 14던가? 17인가에
들어가는 거 같아요 근데
여기서 이제 얘네들이 또 할려고 하는 거는
CPU만이 아니라
GPU의 컴퓨트 셰이더까지 같이
동원하는 그런 하나의 라이브러리를
만들려고 하는거 같은데
게임의 입장에서는 솔직히
CPU만 지원되는거만 있으면 좋아요
GPU는 어차피 보통 그리느라고 바쁘고
뭐 거기서 컴퓨트 셰이더를 쓸 일이 있으면
뭐 쓰기야 쓰겠지만
그 두개를 합친다는 게 굉장히 쉽지는 않은 거거든요?
CPU구조 자체가 달라서 그래서
제가 표준안을 정확히
꼼꼼히 살펴보진 못했지만
그게 이제 CPU와 GPU중에 하나만 골라서
돌릴 수 있고,
그러면은 괜찮을 거 같아요
예전에 봤던 그
마이크로소프트에서 자체적으로 만들었던
AMP(Accelerated Massive Parallelism) 라는 거는
그런 식으로 개념은 잡혀 있어요
CPU에서만 돌릴거냐
GPU에서만 돌릴거냐
CPU에서 돌릴 거면 이런 이런 이런
것도 가능하고,
GPU까지 돌릴 거면 이런거는 안 돼고
구조 자체가 틀리니까
그래서 둘다 돌릴 거면은
GPU에 맞춰갖고 돌려야 되고
그런 게 있었어요
그거는
아마 표준안으로 들어갈 거 같고
이제 C하고 C++의 표준안의 문제가 뭐냐면
새로운 표준안이 나올 때마다
syntax(구문)가 너무 더러워져
저 템플릿 프로그래밍 되게 안 좋아하거든요?
그 이유가 읽기가 너무 어려워요
괄호 몇개 열고 뭐 하다 보면은
정말 이상해져 갖고
뭐 예전에 있던 프로그램이 안 깨지게려면
그렇게 할 수밖에 없는 거긴 하겠지만
그리고 뭐 이미 20년 30년 지난...
40년 일 수도 있어
그 지난 언어에 새로운 걸 추가하느라고
그런 고통이 따르는 걸 수도 있죠
어찌보면은
C++
를 대체할 만한 언어가
좀 모던한 syntax로 나왔으면
좋겠다는 생각은 많이 해요
최근에 뭐 여러가지 언어가
나오고 있지만
게임 개발을 염두해 두고 나오는 언어는 아니지만
최근에 봤던 언어중에 이제
컴파일러 되는 언어가 별로 안나왔어요 사실은
그 동안 다 스크립팅 언어 쪽으로만 나왔지
근데 이제 요 최근에 나왔던거
그래도 두 개는 구글에서 만들었던
Go Lang하고
mozilla 쪽에서 현재 만들고 있는
Rust라는
그런 언어가
있잖아요
그래서 사실 웹 서버에 써 볼 생각으로 좀
보긴 봤는데
Go Lang은
어, 구글에서 만든 거
최근에 만든 언어 치고는
굉장히 syntax가 구려요
왜 저 따위로 만들었을까?
생각이 들 정도로
제가 syntax가 싫어갖고
죽어도 안 쓰겠단 언어는 별로 없는데
Go Lang은 제가 볼 때는
저는 죽어도 안 쓸 언어에요
뭐 파스칼 기반인 것도 같긴 한데
뭐 하나하나를 쓸 때마다
이거는 암호를 쓰는 기분이야
딱 보고 이게 언어가 이해가 되야 되는데 그게 안 되고
그에 비해 Rust 자체는
syntax도 굉장히 마음에 들고
메모리 관리도 굉장히 열심히 할려는 것도있고
그리고
제 생각에 Go Lang은 가비지 컬렉션(Garbage collection)
기반으로 알고있어요
근데 Rust는
가비지 컬렉션도
조금 지원을 하지만 기본적으론
ref count라고 기억을 하는데
제가 그게 맞는지 아닌지는 지금 정확히 기억이 안 나고
Rust에 조금 관심은 가는데 아직
쓸 만한 수준까지
안정화가 안 되어있어요
아직도 뭐 1.0 버전도  안 나왔던 것 같고
뭐 언어적인 측면에서는 예전에 말씀드렸듯이
Ruby(루비언어) syntax가 굉장히 좀 마음에 들고
Ruby syntax로 해서 컴파일 언어로 나올 수 있다면
쓰지 않을까?
물론 C나 C++처럼 라이브러리가
다 오기까지는 걸리겠지만,
그리고 솔직히 제 생각엔 C하고
C++를 대체할 만한 무언가가 나오진 않을 거 같아요
뭐 C#이 많은
제품에서 돌겠지만 가비지 컬렉션만
빼 주면 좋을 것 같고 C#은
어쨌든 뭐 그 정도로해서
오늘 할려고 했던 얘기는 결과적으로는
멀티스레딩 할 때
자꾸만 뭐
복잡하게 이거는 저 스레드 두고
요거는 저 스레드 두고 이 생각을 하지 마시고
처음부터
엔진의 구조 자체를
그런 식으로 잡 시스템, Task 시스템으로 벌어졌다 줄여졌다 할 수있게
그런 식으로가길 바래요
그리고 실제 그게 현재 모든
언어 디자인하시는 그런
새로운 언어들 디자인 위원회가(Design Committe)
많이 노력하고 있는 분야고
functional programming이 다시
주목받고 있는 이유도
바로 그런 부분 때문이고
멀티 스레딩쪽에는
뭐 아까 말씀드렸듯이 C++ 표준
에 이제 페러렐(Parallel)이런거 나올 떄
결과적으론 잡 시스템 Task시스템 위주니까
뭐 게임 엔진 만들 떄
이제 오브젝트 시스템 자체를 이제 컴포넌트
위주로 상속 위주가 아니라
컴포넌트 위주로 가서
그런식으로 만들면
훨씬 나을거에요
처음부터 좀 이렇게
디시플린(discipline) 좀 많이 필요한
부분이고 디자인 할 때
그러고 어떤 의미에서는 아까
말했듯이 이렇게
상호참조 안 되게 막는  방법 있잖아요?
그런거 이제
Assert를 어떻게 잘 구현을 한다던가
어떤 메카니즘을 잘 구현을 해서
그런 일을 할 때마다 이제
경고가 나오게 하는 것도
굉장히 좋은 방법이고
제가 그거는 어떻게 할 지 아직 생각을 안 해봤어요
뭐 제가 게임 오브젝트를 주로 다루는 인간도 아니고 그래서
어쨋든 주저리 주저리 말은 많았지만 오늘 포프TV는 거기까지구요
다음에 또 뵙겠습니다
예, 포프였습니다.
