안녕하세요 포프입니다. 이거 하지 않으면 당신은 주니어다라는 시리즈 중 하나인데요... 이번 에피소드는 어쩌면 특히 C++ 프로그래머한테 적용되는 얘기 그리고 C# 프로그래머한테도 적용될 수 있는 얘기긴 해요. 

간단한 한 줄 당신이 C++에서 std::vector를 쓸 때, 그리고 C#에서 List를 사용할 때 Gerneric List reserve 호출하지 않으면 C# 이라면은 생성할 때 capacity를 넣어 주지 않으면 당신은 주니어입니다. 되게 간단하죠? C++ 프로그래밍하시는 분들은 std::vector 같은 STL 컨테이너 좋은 게 많은데 왜 굳이 컨테이너로 사람들이 만들었을까라는 생각을 하시는 분들이 있어요. 가장 큰 이유 중에 하나가 이런 문제 때문이에요. std::vector에서 기본 생성자는 capacity를 reserve 해 주지 않는다... 아마 기본 크기는 구현 따라 다르겠지만 제 기억이 맞다면 16일 거예요. 총 16개의 멤버 또는 요소를 넣을 수 있는 배열을 만들어 주고, 그걸 넘었을 때마다 2배씩 늘려줍니다. 이게 의미하는 바가 뭐냐면 제가 예를 들어서 파일에서 읽은 어떤 배열이 있고 그 배열을 리스트나 std::vector에 넣고 싶어요. 근데 파일을 읽는 순간 나는 그 파일에 요소가 몇 개인지 알아요. '아 3000개구나' 그러면 넣을 벡터를 만들 때 기본적으로 reserve를 3000개를 하고 넣어야 됩니다. 그래야 메모리 할당이 딱 한 번만 생기고 다 들어가는 겁니다. 16부터 시작을 하면 메모리 할당이 여러 번 생기게 돼요. 그러면 쓸데없이 메모리 파편화 만들고 성능도 줄어듭니다.

이게 큰 문제가 아니라고 생각하시는 분들이 있는데, C++ 사용하는 부분이라면 굉장히 큰 문제가 됩니다. C++를 아직도 사용한다면 성능이 매우 중요한 프로그램일 거고 그 코드의 실제 성능이 한 200~300%까지 느려지는 경우도 저는 봤어요. 특정 상황에서 게임 프로그래밍할 때. 그거 그거를 그 회사에서는 std::vector를 쓰는 회사였고 그래서 베스트 프랙티스로 언제나 벡터를 만들었을 때 "네가 여기 들어올 사이즈를 알고 있다면 reserve해라. 
넉넉히 reserve 해도 되니까 반드시 reserve를 해라"라고 얘기를 했어요. 그런데 reserve를 안 하는 프로그래머들이 꼭 있어요. 베스트 프랙티스를 읽었는데도 안 해요. 이유는 뭔지 알아요? 까먹어요. 베스트 프랙티스의 지켜야 할 규칙이 너무 많아요. 한 20개 정도 돼요. 내가 아직 코딩이 손에 익지 않았고 베스트 프랙티스를 읽지 않았어요. 그러면 코드를 작성할 때 어쩔 때는 reserve를 넣고 어쩔 때는 reserve를 넣지 않습니다. 제가 어떤 사람 코드 리뷰를 볼 때 이런 식으로 왔다 갔다 하는 코드 작성한 사람들 보면요 '어 이거 굉장히 위험하다'라고 생각을 해요. 차라리 아예 처음부터 안 하고 언제나 안 하고 있으면 '모르는구나'라고 가정을 하고 '이거 이렇게 해야 됩니다'라고 말해 줄 수 있는데 어쩔 때는 하고 어쩔 때는 안 한다는 거는 학습능력이 일단 부족하다는 거고, 한 가지를 확실히 배우고 다음 거를 배우는 게 아니라 그 순간에 누가 지적했으니까 요거 하고 다음번에 누가 딴 걸 시작하면 그걸 하지만 예전 꺼 까먹고 이런 식으로 가는 겁니다. 근데 이게 성향일 수도 있고 이게 우리 회사가 채용할 수 있는 프로그래머의 한계 일 수도 있어요. 우리 회사는 훌륭한 프로그래머를 채용 못 할 수도 있어요.그러면 적당히 하는 프로그래머 하고 일을 해야 될 수밖에 없거든요? 그러는 사람한테 std::vector를 주기 시작하면은 이런 비효율적인 코드로 만들기 시작을 한다는 거죠. 그럼 만약에 std::vector를 버리고 회사에서 컨테이너로 만든다면 고정 벡터(fixed vector)를 꽤 많이 만들 겁니다. 네가 만드는 순간에 이 배열은 벡터인데 실제 요소가 몇 개인지 카운트를 해주는 템플릿 기반 클래스예요. 하지만 처음 시작할 때 최대 사이즈는 정의를 해야 되고 그 최대 사이즈가 넘어갈 때는 assert가 나오던 오류를 보여주던 crash가 나던 어떤 방식을 돌게 하겠다는 거죠. 그래서 이거를 사용하는 순간 당신은 무조건 생각을 해야 됩니다. capacity가 몇인지. 왜냐하면 capacity 안 넣고는 아예 사용을 못 하니까 그런 식으로 강제를 하는 거예요. 그게 클래스의 강제, 그리고 함수 단위에서는 contract 사전 조건(pre condition) 사후 조건(post condition) 그런 강제를 할 수밖에 없는 부분인 거죠.

그래서 함수, 클래스 설계를 잘만 한다면 이런 식으로 회사에서 중요한 무언가를 강제를 할 수가 있습니다. 그래서 그런 식으로 이제 강제를 하게 되는 거예요. 하지만 강제로 안 했을 때 내가 이런 규칙들을 못 따라가고 베스트 프랙티스를 못 따라간다? 학습능력이 부족하다는 거죠. 그리고 성능상으로 왜 문제가 되는지 모른다는 거고 당연히 모든 코드가 다 성능이 좋아야 되진 않습니다. 어떤 경우에는 정말 capacity 없이 벡터를 써야 되는 경우도 있을 거예요. 하지만 굉장히 많은 경우에 아니면 capacity가 확정을 못 하더라도 충분한 capacity를 잡는 것만으로도 초반 할당을 여러 번하는 할당을 피할 수 있어서 굉장히 성능 향상이 있는데도 불구하고 굳이 내가 성능을 느리게 작성을 한다? 그건 예전에 무슨 책에서도 본 거 같은데 premature optimization 이른 초기화를 안 한다는 문제가 아니라 정확히 이름은 기억이 안 나는데 너는 그냥 평생 부정적인 코딩을 하는 거다? 이런 식으로 얘기했던 거 같아요. 표현은 정확히 기억은 안 나는데... 그렇기 때문에 괜히 똑같이 작성을 하고, 코드 가독성도 해 치치 않고, 훨씬 빠르게 작성할 수 있는 코드를 이게 '이른 초기화를 할 필요는 없어', '너무 섣부른 초기화를 할 필요가 없어'라고 하면서 가독성이 더 나아 지지도 않고 여전히 더 느린 그런 코드 작성한다면 "너는 그냥 자기 발전을 생각하지 않고 염세주의에 빠져서 그냥 핑계만 대고 있는 코딩이다"라고 얘기를 했었어요.그거 맞는 얘기거든요? 그런 식으로 코딩을 작성한다는 겁니다. 그리고 내가 그런 식의 핑계를 대면서 발전을 하지 않고 뭐가 더 나은 방식인지 고민하지 않는 프로그래머라면 주니어라는 거죠. 왜냐하면 누군가는 계속 말해 줘야 되는 거거든요. "이거 틀리셨네요? 고치세요. 저거 틀리셨네요? 고치세요." 만약에 회사가 다 그렇게 대충 하고 있으면 그럼 주니어만 모여있는 회사입니다. 그러면 그중에서 내가 나서 갖고 "요거는 성능이 이러면 조금 더 좋대요. 
요런 식으로 앞으로 해 나갑시다." 좋게 말하면 따라와요. 그리고 내 밑에서 이제 지도받는 사람도 있잖아요? 그 사람들한테는 명령할 수 있는 위치니까 "이거 이렇게 해라", "이렇게 하세요", "이렇게 하셔야 합니다", "안 하면 코드 리뷰 통과 못 합니다" 이런 식으로 가게 된다는 겁니다. 요런 식으로 편하게 볼 수 있는 몇 가지들도 있습니다.

이걸 혹시 몰랐다면은 그냥 아직 배열을 다룰 줄 모르는 사람이에요. 내가 C#에서 리스트가 아니고, C++에서 벡터 그런 거 아니고 진짜 순수한 배열을 가지고 배열의 크기를 증가시키고 줄일 수 있고, 할당하고 재할당하고 이런 것들을 못 하시는 분들은 그냥 평생 주니어입니다. '아 이걸 누가 사용해요?' 사용 안 해도 이거는 굉장히 간단한 배열이나 메모리를 다루는 과정이기 때문에 한번 학교 수준에서 공부하면요 20~30년을 사용 안 해도 그냥 나와야 돼요. '20~30년 동안 사용을 안 했기 때문에 모른다'라고 말하는 거는 공부를 제대로 안 했다는 겁니다. 체화를 못했다는 겁니다. 한 마디로 우리가 한국에서 구구단 열심히 외우잖아요? 나이가 들어도 구구단을 까먹지 않아요. '구구단을 오래 안 써먹어서 까먹었습니다'라고 얘기하는 순간 약간 ㅂㅅ 소리 듣죠? 일반 사회에서... 프로그래밍 업계도 그런 겁니다. 그래서 그거를 오래 사용 안 해서 모릅니다? 그러면 앞에서는 얘기 못 하지만 사람들은 뒤에서 다 ㅂㅅ 쓰고 있습니다. ㅂㅅ... 그렇습니다. 그런 거고요. 요런 것들 모르시는 것들 있으면 열심히 또 알아보시고, 주니어로 오래 살아남는 법 당연히 있습니다. 인생이 괴로워지니깐 그렇게 살아남지 말고요, 우리 열심히 공부하시죠. 포프였습니다.