안녕하세요 포프입니다.
여전히 4K로 찾아가는 포프티비 새로운 포프티비인데요
오늘은
새로운 방송을 하고 있으니
다시 예전에  많이 하던 얘기로 돌아가서
코딩 스탠다드 얘기를 잠깐 더 할게요
오늘은 람다에 대해서 얘기를 할 거예요
C++에도 람다가 들어왔고 C#에도 람다가 들어온지 좀 되죠
사람들이 람다를 열심히 썼고 마구 썼고
개판을 쳤고 이런 문제들이 있었어요
제 코딩 스탠다드 문서가 공개가 되 있어요
영어로 되어 있지만
Proof Of Concept University(POCU) 나갈 때를 대비해서 한글화가 점점 진행이 될 거예요
C#용이 있고 C++용이 있어요 그 두가지가 있는데
그 코딩 스탠다드에 보면은
제가 람다를 웬만하면 쓰지 말라고 그래요
그 이유가 뭐냐, 일단 시작은 C++부터 얘기할게요
C++의 람다와 C#의 람다는 좀 다르게 봐야 하는 부분이 있어요.
람다가 뭐냐, 일단
가장 간단하게 이야기 하면
함수인데 함수를 따로 만들지 않고
그냥 코드 한줄에 함수를 써서 그걸 호출하는 방식이라고 보면 맞아요
예전같으면 함수 정의해두고
함수를 펑션 포인터로 전달해서  그걸 호출하곤 했잖아요
근데 그 과정을 따로 함수를 만들 필요없이 코드를 짜는 중간에
갑자기 괄호를 열고 아 이게
펑터(Functor)야 이러면서 짤 수 있는 방식
어찌보면 자바스크립트에서  함수가 함수와 함수를 연결해서
함수를 호출하고 함수를 매개변수로 전달하는 이런 괴랄한 방법들이 있잖아요
그거하고 조금 비슷한 거라고 보면 맞아요.
근데 람다가 장점이 있긴 있어요
특히 사람들이 많이 보는 장점이 뭐냐면
한번밖에 안 쓰는 함수를 왜 굳이 함수로 만드냐
예전부터 제가  코딩 스탠다드에서 했던 얘기기도 해요
어차피 함수를 한번밖에 안 쓸 거면 코드 안에 넣어라
굳이 함수 만들지 말아라
근데 이걸 한발짝 더 나가면 함수로 만들긴 만드는데
그냥 그거를 람다로  만들어서  재활용은 없게하고
그럼 코드를 읽을 때 죽죽 읽을 수 있다 얘기거든요
뭐
그런 장점이 있긴 있죠
그리고 아까 말했던 것처럼 펑션 포인터(Function Pointer) 같은 거 전달해서
나중에 이제  실행이 곧바로 실행되는게 아니라
함수 펑션 포인터 전달을 나중에 호출하거나 이럴 때도 유리한 면도 있고
제가 예전에 말했던 방식, 함수를 그냥 코드 안에 집어넣어라 호출하는 코드 안에
그건 뒤에 호출하는 방식을 못하니까
그런 람다의 장점도 있고
그리고 또 하나의 장점이 뭐였지?
그정도인거 같아요 사실 람다의 장점은
근데 람다가 단점이 은근히 많아요
단점이 뭐가 많냐면 결국은 람다를 사람들이 얘기할때
이름 없는 함수라고들 많이 들어요
왜냐면 함수를 작성할때 함수에 보통 이름을 적잖아요 함수명을
근데 람다를 작성하게 되면 코드 안에 코드가 들어가는 방식이고
그리고 이제 무명함수 함수 이름을 내가 못 지으니까
그럼 얘를 만약에 디버깅을 할 때가 오거나
얘가 중간에 어디서 크래시가 나서 크래시 덤프가 나오고
스택 덤프가 나올 때
함수 이름이 나올 수가 없어요 그냥 람다함수다
주소는 여기다 이런 식으로 나와요
그럼 그 람다를 포함하고 있던 부모가 되는 함수의 이름을 보고 유추할 수도 있지만
이 람다가 여러개를 호출하고 이러면
콜스택을 보는 것 만으로 여기에서 뻑이 났구나 라는 걸 알 수가 없어요
그런 단점이 하나 있고
그리고 또 람다의
또 다른  단점은
처음에 제가 코드를 짤 때
당연히 이 람다 함수가
다른 데서 안 쓰인다 가정을 하고 코드를 짠 거예요
근데 하다보니까 어느순간 이 람다를
다른데 써야 할일도 있어요
그럼 이 함수의 재활용성이 생긴거고 재 사용성이 생긴건데
프로그래머 습관의 문제일 수도 있지만
아니면 람다에 익숙해지지 않아서 그럴 수도 있지만
코드를 훑어 가면서
아 이 함수가 이미 있구나라는 걸 알기가 되게 어려워
특히 남이 짠 함수의 경우에는 내가
함수 이름만 딱 보고 아 이 함수가 없네 라고 보통 추가를 하게 되는데
그게 아니라 모든 함수를 들어가면서 이런 기능이 없나를 살펴봐야 하는 단점이 있게되죠
그래서 그런
가끔 람다를 열심히 쓰는 코드베이스를 보면 똑같은  일을 하는 코드가 중복이 되서 여기저기서 나오기 시작해요 람다라는 이름으로
그것도 어찌보면 단점이고
음 마지막 단점을 내가 뭘로 할려 그랬지?
말하다 보니 까먹었어요 그냥 넘어갈게요
나머지 하나 단점은 되게 단순했던 것 같아요
아 그거였다 또 기억이 났어 내가 왜이럴까
툴 자체에 람다 디버깅을 할 수 있는 툴 자체가
아직 그렇게 뛰어나지가 않다는 단점도 있어요
이건 어찌보면 툴이 발전이 되면 고쳐질 문제이기도 한데
옛날 같은 경우에는 이제
템플릿, C++에서, 템플릿을 써서 함수를 짜기 시작하면
디버거에 브레이크를 거는 순간
디버깅이 제대로 되야 하는데  얘는 잘 안됐었거든요
그러다가 툴이 좋아져서
거기에 찍어두면 디버깅이 되긴 되죠
근데 내가 원했던 템플릿의 버젼 하나가 아니라
그 템플릿을 쓰는 모든 함수 모든 코드에 브레이킹 포인트를 걸어서
요즘은 그걸 내가 걸어놓은 다음에 하나 두개 빼서
정말 원하는 버젼, 원하는 타입용
템플릿 함수에만 브레이크 포인트를 걸 수가 있어서 많이 좋아졌어요
템플릿 프로그래밍은 이제
한 제가 볼때는 거의 10년 넘게 지나서야
드디어 디버깅이 편해진거고
람다도 그 위치에 갈 거라고 생각을 해요.
마지막 문제는 해결 될 문제지만
여전히 처음 두가지  문제가 남아있어요
일단 재활용성을 보장할 수 있는 방법이 잘 없다.
가끔 중복된 코드가 나올 수 밖에 없다
그리고 두번째는 디버깅을 하더라도
콜스택 이름 때문에 디버깅이 눈에 한번에 확 들어오지 않는다
그러면 이제 그 다음에
코딩 스탠다드가 나올 수 밖에 없는거예요
저도 그렇고 제가 예전에 일하던 큰
회사 게임 코드 베이스에
코딩 스탠다드도 그랬어요
람다를 최대한 쓰지 마라
단 써야 될 때는, 써도 될 때는
정말 이건 분명히 딱 한번만 쓰인다는 보장이 있을 때
그리고 코드가
정말 단순할 때
그 예를 대충 들면은
sort 함수 같은거에 보면은
보통 sort 키가 있고 그 키에서 어떤
규칙대로 정렬을 할 거냐가 있어요
그럼 sort 키가 int 처럼 비교가 가능한 거라면
ascending sort를 할 때는 작은 숫자부터 큰 숫자로, descending sort를 할 때는
큰 숫자부터 작은 숫자로 비교하는
연산자만 넣으면 되거든요 그러면 퀵 소트나
stl소트 같은 데 들어갈때
비교하는 함수를 보통 집어넣는데 그 함수는
sort 키가 a와 b가 있다면 a가 b보다 작다
b가 a보다 작다
요 관계식만 넣어주면 되요. 거의 한줄에 가능해요
이런 것들 아니면
그런 어떤 이터레이터를 돌리면서 거기서 그냥 어떤 값을 프린트 하고 싶다 정말 단순한 걸
이런 걸 할때 정말 한줄 두줄 안에 끝나는 람다일 경우에는 마음 껏 쓰라고 얘기를 해요
그러면 재활용 안할거 같은데 긴 함수는 어떠냐
그냥 함수 만들라는 거예요 그리고 요즘  대부분
oop를 하기 때문에
그런 함수들을  private 함수로 만들어 놓으면
크게 문제는 안된다는 거죠
근데 당연히 함수를 새로 만듦으로 인해서
그
나중에 실제 리팩터링을 할 때 그 함수가 한번밖에 안 쓰이는데
이 함수가 있음으로 해서
여러군데를 검토할 문제가  있는 부분도 있어요 사실은
그거는 예전에 다른 코딩 스탠다드에서도 말했고
다른 함수에서 얘기 했듯이 그런 경우에는 따로 함수를 안 만드는데 맞죠
그러나 이제 이 함수가 언젠가는 쓰이겠다
워낙 흔한 함수도 있어요 언젠가는 반드시 쓰인다고
생각할 수 밖에 없는 함수들
그런건 함수가 나와야 하는게 정상이기 때문에
그런건 케이스 바이 케이스는 맞지만
굳이 람다를 쓸 바에는 함수를 뽑는게 낫다는거죠
아니면 람다를 안 뽑더라도
함수를 그냥 코드만 함수가 아니라
메인 바디 안에 집어넣고 함수가 있는데다
그리고 이 부분을 이제 구역을 딱 짓고 싶으면
그 안에 중괄호 두개를 붙이는 것 만으로도
사실 이게 범위가 보이기 때문에 나중에 눈으로 훑다가 아 여기 중괄호 있네?
이건 뭐지 그러고 그 위에 커맨트가 있겠죠
이 블럭의 코드는 뭘 하는 거다
그걸 보고 뽑아낼 수도 있긴 하죠
함수가 있는 것 보단 못하죠
그래서 프로그래머가 코딩을 짤 때
이 함수가 다시 쓰일 재활용성이 있느냐 그거에 따라 프라이빗 함수로 뽑아 놓는 거
그런 감은 확실히
어떻게 이해될까, 제대로 훈련받은 프로그래머?
아니면 경험이 많고 생각을 많이 하는 프로그래머?
그 사람들에게서 볼 수 있는거고
그런 생각 없이 모든 걸 그냥 함수로뽑거나
그런 생각 없이 모든 걸 함수로 안 뽑거나 하는 것은 문제가 생길 수 밖에 없죠
그래서 C++에서 말하는 람다는 정말 그렇게 밖에는 말할 수 없어요
최대한 쓰지 말아라. 단 써야 될 때
아까 말했던 소트 같은  되게 단순한 비교 연산자가 들어갈 때
아니면  정말 한두줄짜리 코드
죽어도 다시 안 쓸 거 같은 그런 코드 그런 거를 만들 때
생각보다 이게 별로 없어요
그래서 람다를 볼 일은 별로 없어요 C++에서는
C#람다로 가면
조금 얘기는 달라져요
왜 달라지냐면 일단 저는 c#에도 람다를 쓰는 법이 두가지가 있어요
그냥 쿼리문 쓰듯이 SQL쿼리문 쓰듯이
from어쩌고 select어쩌고 이렇게 하는게 있고
그게 아니라 fluent API 라고해서
컬렉션이 있으면 .찍고 wherer 조건문 쓰고 . 찍고 ToArray() 해서 어레이로 바꾸고
이런 식으로 하는 fluent API라고 하고
빌더 패턴이라고 하는 것 같아요 다른 API에서 이걸 빌더식으로 많이 쓰기 때문에
그럼 전 그런 거를 쓰라고 해요 람다는 왜냐면
그게 함수의 함수의 함수의 호출하는 것 같아서
함수 프로그래밍 적으로는 좀 더 이해가 쉽기 때문에
자 컬렉션이 있어, 여기서 필터링을 할거야
조건에 맞춰서, 그게 where 고 그 다음에 니가 여기서
오더링을 할 거면 orderBy가 있으니까 그 다음에 오더를 이렇게 한다 라고 한눈에 볼 수가 있는데
SQL쿼리는 약간 그 반대의 방식이예요
옛날 쿼리를 짜는 방식이 그랬겠었지만
뒤에서부터 앞으로 읽어야 되는거고
보통 코딩을 짤때는 앞에서부터 뒤로 짜기 때문에 전 fluent API를 쓰라고 그래요
근데 c#에 람다는 조금 다른게
일단 툴 적인 서포트가 굉장히 좋아요
실제 람다를 집어넣어도 람다 안에 코드 한줄한줄
그거도 c#에 코드 한줄안에 쫙 쓸 수도 있거든요
.where().orderBy().어쩌고()
하면서 막 한줄에 써놔도 그걸 스태핑 스루 하면서
사실은 코드 한줄한줄 볼 수가 있어요
그만큼 c#의 디버거가 많이 발전해 있죠
그렇기 때문에 람다를  조금 더 느슨하게 써도 상관이  없어요
그리고 어찌보면 얘네의 람다는
SQL에서 볼 수 있는 몇가지 오퍼레이션이 있잖아요. order를 한다거나 where를 한다거나
그런 것들을 함수 하나하나로 표현한 거고
내가 코드를 짤때 이것을 닷(.) 을 새로운 줄에 넣음으로 인해서
오퍼레이션 하나하가 실제
한눈에 보이게 만들 수 있기 때문에
그런 코딩 스탠다드를 잘 따르면
아무리 람다식이 조금 복잡해도 읽을 수도 있고 디버깅도 쉬워요
그리고 c#에서 당연히
람다를 돌다가  익셉션이 나거나 뻑이 나거나 그러면
디버깅을 보기 힘든 단점은 여전히 있어요
그 부분은
C++에서 말한 것 처럼 약간 지양해야 하는 부분이지만
그게 아니라 굉장히  당연한 것들은
람다를 찍어서 할 수가 있죠
여기에 이제
한 두어가지 문제가 더 생기는데
하나는 경험에 의한 것
예전에 되게 잘하는 프로그래머가 있었어요
제가 일하던 회사에 제가 가지고 있는 회사가 아니라
러시아 출신인데
진짜 굉장히 유명한 프로젝트에도 공험자로
주요 공헌자로 들어가 있었을 정도로 대단한  친구였어요
이 친구가 코드를 짜면은 아무도 못 읽겠다고 난리쳤는데
그 이유가 뭐였냐면
굉장히 많은 것을 람다로 떡칠을 해 놓은거예요
딱 컬렉션 안에 들어오는데 거기에다가
한 20줄 짜리 람다를 써요
셀렉트 하고 오더바이 하고
뭐 하고 뭐하고 이런 식으로
사람이 두세단계 까지는 읽는데
거기서 만약 셀렉트를 해서 뭘 골랐으면 그거에 대한 의미를 알기 위해서
이 코드를 다 긁어야 하잖아요
그게 아니라 고 셀렉트까지만 해놓고 where 까지만 해놓고
그걸 다른 변수에 저장해두면
그 변수의 이름이 있을 거 아니예요
예를 들어서 학생들 이름이 들어 왔을 때
학생 이름이 들어왔고 난 여기서 김씨를 찾고싶다
그러면 김씨를 where로 건 다음에 그거를
namesStartWithKim 이렇게 두면은
그게 김씨로 시작하는 이름들이라는 것을 한눈에 볼 수 있는데
그걸 안하고 계속 체인을 박다 보니까
사람들이 코드를 읽고 디버깅 할려면 멍하니
바라보면서 계속 하게 되고
나중에는 그 친구에게 물어봤어요 야 여기 버그가 있는데
이거는 니가 무슨 문제인지 찾을 수 있냐
남들보다는 빠른데 여전히
변수이름을 잘 짓는 것 보다는 느렸어요
그래서 그런 식으로 로지컬 하게 중간중간 변수이름을 찍는 습관은 되게 중요해요
그런 부분을 잘못 하면 c#에서는
완벽히 산으로 갈 수 있다는 단점이 있어요
그런 문제가 있었어요 그게 제가
c#쪽에서 람다에서 문제 본 게 하나가 그거였고
그 다음 문제는
이건 주니어단이나 기본기가 약한애들에서 나오는 문제인데
예를 들어서 컬렉션을
돌아가면서
여러가지 일을 할 수가 있잖아요
컬렉션을 돌아가면서 그 컬렉션에서
뭐 여기서 짝수로 끝나는 id는 이리 보내고
홀수로 끝나는 id는 저기로 보낸다
해서 컬렉션을 두개로 나누는 방식이 있잖아요
그러면 제대로 코딩을 배운 애들은
아 이걸 for루프를 두번 돌리는 건 좀 문제가 있으니까
for를 한번을 돌리면서 if else를 넣어서
다른 컬렉션에 밀어넣자 라고 생각을 해요
그럼   O(n) 으로 되니까
근데 람다에 익숙해진 애들은 람다에서 .where 이렇게 고르는 것들 있잖아요
그게 for문이 돈다고 생각을 못하는 것 같애요
그래서 아무 생각없이 그거를 컬렉션에 .where 한 다음에 홀수인 것들은 이 컬렉션으로 만들고
그리고 원래 컬렉션으로 돌아가서 where를  한번 더 해서 짝수인 건 이 컬렉션으로 넣어줘 이런 식으로 코드를 짜요
그래서 코드 짜다 보면은 굉장히 비효율적인 코드들이 나오는 걸 많이 봤어요
그래서 계네들에게 물어봐요 이거 for문인거 아냐
모른대요. 그냥 나오는거 아냐?
개념이 이런 애들이 있어요 사실
그래서 특히 저는 주니어 단이나 이런 애들한테
람다를 잘 쓰지 말라고 그래요.
for문으로 되는 건 웬만하면 for로 하라고 그래요
특히 이제, 물론 람다가 편한 건 있어요 함수형 프로그래밍처럼 하기 되게 편한 것들이 있는데
저도 자주 쓰는 부분도 있어요
컬럼 여러개 나왔을 때
데이터가 여러개 있는데 이 데이터에서 for문 돌려서
새로운 오브젝트 만들어서  다른 컬렉션으로 저장하기 이런거
.select이런걸로 되거든요 사실은
그런거를 단순한 거 까지는 쓰라고 그래요
어느정도 약간 복잡해지고
아니면 그런 비 효율적인 코드가 나오기 시작한 애들한테는
쓰지 말라고 얘기를 되게 많이 해요
c#에서 람다의 문제는
제가 볼때는 체이닝이 너무 쉽다는 문제
그리고 정형화된 함수가 있다는 것의 문제
c++은 정형화된 체이닝 이름이 있진 않잖아요
플루언트 api 할때
그렇기 때문에 그 부분, 그 단점은 안 보이는 것 같아요
이걸 정리를 하면은
c#을 하나 c++을 하나 람다는
C++은 람다를 거의 안 쓰는게 맞아요
되게 단순한거
죽어도 다시 재활용하지 않을 코드만 람다를 쓰는게 맞고
거기서 코드가 뻑이 나거나 익셉션이 나거나
익셉션은 좀 그렇구나 크래시가 나거나
이럴 상황이 보이는 코드라면
더더욱 람다를 안 쓰는게 맞아요
그러면 코드가 복잡해질수록 포인터 문제가 생길수도 있고 람다를 안 쓰는게 맞고
차라리 예전처럼 함수 쓰고 함수이름으로 가라 라고 말할 수 밖에 없죠
그러면 그 다음에 나오는 건
c#은 좀 더 여유롭게 써도 되고, 너그럽게 써도 되지만
람다 체이닝하는게 서너개가 넘어가는 순간 한번쯤 생각을 해봐야 하고
중간중간 변수 이름으로 뽑아주는게 낫다
그런다고 코드가 그렇게 느려지지도 않아요
그렇게 얘길 하면 될 것 같아요
그리고 마지막에 제가 말했던 람다를 쓸때
되게 단순한데 한번에 결과가 나온다 하지 말고
저 수준의 중요성에도 말했지만
람다를 썼을 때 람다가 없이
내가 코드를 짜면 과연 어떤 코드를 짜야될까
그런 고민을 하다보면 좀 더 효율성에
신경을 쓸 수 있는 코드를 짤 수 있을 것 같아요
그 정도 얘기를 하면 람다의  문제 장점 등등 코딩 스탠다드까지 얘기를 한 것 같아요
그러면 오늘은 여기서 끝낼게요 포프였습니다.
