안녕하세요 포프입니다.
만우절날 되게 좋은 일이 있었어요, 올해는
그
마이크로소프트 MVP를 제가 작년 1년 동안 해왔잖아요
만우절날 또 이메일을 보내주더라구요
MVP가 1년 더 갱신되었다고 해서
올해도 마이크로소프트 MVP로 1년을 버틸 것 같고요
솔직한 얘기로 저는
이번에 될까 안될까 고민(?), 생각을 좀 했던 이유 중의 하나가
작년에 제가
마이크로소프트 MVP 될때는
음... 뭐랄까.. 타이틀이 있었어요
어디 회사의 시니어 그래픽 프로그래머 이런 것도 있었고
아니면 게임업계의 큰 회사에서 이렇게 일하고 있다고 보여 줄 것도 있었고
어떤 의미에서는 그런 타이틀이 있었기 때문에
한국에 있는 컨퍼런스에 초청받고 이런 것도 있었거든요
근데
올해는 제가 지금 현재 그게 없거든요
백수입니다 ㅎㅎㅎ
백수라서 그게 없어서 과연 그게 될까? 라는 생각을 했어요
근데 뭐 작년 1년 동안 해왔던
온라인 커뮤니티 활동 자체는
그 전 1년에 비해 적진 않거든요, 숫자로도 그렇고
이 포프TV보시는 분도 그렇고, 블로그도 그렇고
제가 책 감수, 대학강연 이런거 해서
사실상 재작년이나 작년이나 별
차이는 없는데 그냥
자격지심에 혹시라도
현재 내가 가지고 있는 타이틀이나
어느 회사에서 중요 위치에 있다는 그런게
MVP를 받는데 좌우가 되지 않을까 생각을 안했던건 아니에요
근데 올해 나온걸 보고 나서는
다른 기관에 대한거 보다는 조금 더 좋은 감정을 가지게 되긴 해요
그 타이틀이 중요한게 아니라, 여태까지 내가 뭘 해왔는지에 따라 결정이 되는 거구나
라는 안도감?
그런게 들어서 조금은 기분이 좋고
어쨌든 올해도 마이크로소프트 MVP가 갱신이 됐기 때문에
마이크로소프트 얘기를 좀 더 할 거 같아요
마이크로소프트 얘긴아니고
어찌보면  C++얘긴데, GCC얘기일 수도 있고
최근에 제가 어느 모 게임을
네 개의 콘솔용으로 포팅을 해주고 있어요, 그래픽 엔진 쪽을 만들어 주고 있는데
그 중에  GCC기반의
컴파일러, 아니 플랫폼을 쓰는 언어가 하나 있거든요
그 플랫폼이 하나가 아니구나, 두 개(?), 세 개가 있는데
거기서 정말 재미있는 문제를 하나 발견했어요
그게 정말 GCC기반이어서인지 아닌지는 확실하지 않은데
여태까지 패턴이 좀 보이기 때문에, 그에 대한 얘기를 좀 하려고해요
가끔 그 뭐라그래
C++ 코딩하시는 분 중에
class가 혼자 가지고 있어야
되는 멤버를 초기화 할때가 있잖아요
예를 들어서 어떤 class 안에 다른 object가 들어갈 때
그러나 보통은 private member로 초기화를 하는데
어떤 분들은 그걸 함수 안에 static 변수로 선언을 해서
곧바로 리턴하는 경우도 있어요
그러는 이유가 여러가지가 있겠지만
저는
그거를 괜찮은 방법이라 생각을 안하거든요
왜냐면 나중에 지워주기가 거의 불가능한 변수가 되버리잖아요 사실은
그래서 싱글턴 같은 경우는 많이들 그렇게 하는 거 같아요
어차피 싱글턴은 프로그램 실행 중에 계속 있어야 되고
그 실행파일이 끝날 때 같이 내려가서 삭제되는게 전부니까
그렇게 많이들 하시는데
뭐 어찌보면 create instance나 delete instance 따로 안불러줘도 되고
편한 부분도 없진 않아요
저는 그건 굉장히 안
좋아했거든요 옛날부터 그냥
코드 찾기도 좀 불편하고 어떤
의미에서는
옛날의 C에서 OOP개념이 없을 때
C++을 안 쓸 때 C에서
OOP를 비슷하게 흉내를 내려고
장난치던 게 그런 방식이라고 생각을 했었기 때문에
별로 사용을 안했는데
이게 최근에
GCC기반 컴파일을 돌리면서
문제가 생긴걸 최근에 발견을 했어요
어떤 문제였냐면
static변수로 들어가는게 어떤 객체였어요, 그리고
그 객체가 생성자가 호출이 될 때 안에서 메모리를 할당을 해요
New를 불러서 다른 메모리를 할당을 하는건데
이게 그 첫번째 static문을 딱 치고 들어갔을 때는
그 메모리 할당을 실패하더라고요
static변수로 들어가서 변수가 처음 호출이 되니까
이게 생성자를 호출을 하겠죠
그럼 그 생성자 안에서 다른 메모리를 할당을 하는데 그게 실패를 하면서 null pointer가 반환이 됐어요
그래서 그걸 곧바로 사용했으면
crash가 난다,  pointer derefence exception나고,
한마디로 프로그램 crash 나는 건데,
이게 이번 한번만 이랬으면, 이 코드가  이상한가 보다
아니면 지금 제가 사용하는 플랫폼이 이상한가보다 생각을 했을텐데
재밌는건, 제가 2006년도에
playstation 3 처음 나왔을 때 개발할 때도 이 현상을 발견했었거든요
그 당시에는
playstation 3 컴파일러가 GCC였어요 100%
그때 그런 현상을 발견했었고
그리고 2009년도에도
아마 제가 Relic있을 때, Space Marine 만들 때도
이런 문제를 똑같이 발견을 했어요
그래서 그걸 static으로 안하고 멤버변수로 돌렸던 경우가 있는데
2006년도에 처음 발견했을 때는
왜 이러지? 모르겠다~ 그냥 그랬고, 멤버 변수로 돌렸고
2009년도에는
아 이게 GCC기반에서 뭔가 문제가 있나보다라고 단순히 생각을 했었고
이번에는 벌써 5년정도 지난 후니까
나중에 생각해보니까
아 옛날에도 그랬구나 생각이 드는거에요
마이크로소프트 플랫폼에서는 아무 문제가 없어요 이게
그래서 이게 왜 이럴까?
제가 좀 더 깊게 파진
않았거든요
깊이를 파고 뭐...
GCC나오는 어셈블리 보고 그러면 이유는 알 수 있을거 같은데
당장은 일이 급해서 뭐 제대로 알고 싶지도 않고
그냥 어차피 제가 선호하지 않는 코딩 스타일이기 때문에
뭐 어차피 나는 안쓰니까 이 개념도 있어서 안봤는데
혹시라도 아는 분이 있으면 알려주시면 좋을거같아요
현재 추측이예요 추측으로는
GCC에서 object를 static변수로 함수 안에 선언했을 때
선언이라고 하면 초기화죠, 함수를 처음 호출 할 때 그걸 초기화 해주고
그럼 초기화 할 때, 그 안에서 메모리 할당이 될 때
그게 안되는거 같아요
이게 C++규격 안에 있는건지 없는건지는 잘 모르겠어요
GCC자체가 이제
c++ 스탠다드에 굉장히
맞게 만드는 컴파일러기 때문에
저는 그 문제라고 생각하는데
분명히 초기화, 메모리
할당이나 이런 순서에
그런 제약이 있지 않나
그걸 그대로 따라가다 보면 null pointer가 반환되는게 아닌가
생각을 했는데
정확히는 몰라요, 그게 왜 그러는지
제가 일단 playstation3 GCC기반에서도 봤고
그리고 현재 쓰는  GCC기반에서도 봤고
이건 타겟 플랫폼 ARM이거든요
그래서 ARM CPU에서 봤고
제 생각에는
초기화나 생성자 호출 등등의 문제가 있지않나 생각을 하는데 잘 모르겠어요
그래서 아시는 분은 좀
알려주시고
제가 하고 싶은 말은 그냥 그거에요
함수 안에
그런
static을 만들어서 편하게 가고싶은 맘은 알겠는데
이왕이면
class안에 private멤버로 넣는게 나은거같아요
그게 아무래도 좀 더 OOP스런
방법이고
코딩은 좀 더 많아지더라도
오히려 메모리 관련 측면에서는
어떤 객체를 생성하는 시기와 파괴하는 시기를
프로그래머가 manual로 컨트롤 할 수 있다는게 훨씬 더 좋지않나 싶어요
나중에 memory pool만들 때도 기타 등등
그래서 그렇게 말씀을 드리고
싶고
정 그것도 싫다 그러면 차라리 저는
그
함수 말고 cpp파일 안에, static변수를 선언하면
cpp파일에서만 쓸 수 있는 방법이 있잖아요
차라리 그게 낫지 않나 싶어요
그 이유를 들면
그 static변수의 초기화 시점은
secure file에 올라갈 때 거든요
차라리 처음 시작할 때 메모리를 할당하고 하겠다 이런 개념도 있죠
이런걸 원하지 않는 분도 있지만
원하지 않으시면, 아까 말했다시피 private멤버로 해서 해주시고,
그것도 괜찮으면 그렇게 뽑아주시고
개인적으로는 헤더파일에 제대로 넣어서 하는게 좋다고 생각해요 저는
그 말씀을 드리고 싶었고요
따로 얘기할게 있나?
없는 것 같네요. 그정도로만 하면 될거 같아요
뭔 얘기 했는지 모르지만 ㅎㅎ
포프였습니다
