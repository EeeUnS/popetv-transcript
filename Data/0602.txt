안녕하세요, 포프입니다.

오늘도 제가 사용하는 코딩표준에 대해 말씀을 드릴 건데요, 이건 제가 관리하고 운영하는 회사 아니면 제가 코딩표준을 결정해 줄 수 있는 그런 회사의 코드 베이스에서 적용하고 있는 방법들이고요, 실제 일부는 제 웹사이트에도 공개해 놨고, 그리고 일부는 그렇게 공개적으로 나와 있지는 않지만, 각 회사 내부에 있는 내부 문서로 추가적인 규칙들도 있고요, 그 외에 이런 코딩 규칙을 어길 경우 코드가 컴파일이 안 되게 하거나 테스트에 실패해서 배포가 안 되게도 하고 있습니다. 이건 당연히 제가 책임지고 결정을 내릴 수 있는 회사에 한정된 거고요, 제가 그런 회사가 아니라 다른 회사하고 일을 해줄 때면 당연히 그 회사의 코딩 표준에 맞게 코드를 작성해 줍니다. 그런 회사를 두, 세 군데 같이 일하고 있으면 일하는 동안에 두, 세 군데 다 다르게 코딩 표준을 해주고 있어요. 그래야만 전문 프로그래머고요, '프로그래머는 내가 원하는 방식이 있어도 결과적으론 고객을 위해 그거에 맞춰가 주는 게 전문 프로그래머가 맞다'라고 생각합니다. 자, 서론은 여기 끝.

오늘 이야기할 건 문자열 관련 함수들이에요. C#을 기준으로 설명해 드릴게요. C#을 보면 가장 많이 사용하는 문자열 함수 중에 이런 게 있어요. Split 하는 함수. Split 할 때 Tokenizer거든요? Tokenizer면 중간에 비어서 나오는 문자열도 있잖아요? 이걸 제거하려면 특별한 매개변수를 Enumeration으로 넣어줘야 해요. 저희는 이거 사용하는 게 일단 금지되어 있습니다. 이유는 실제 사용은 하는데, 저희 내부적으로 Wrapper 함수를 만들어요. 흔히들 사용하는 문자열 연산은 굳이 Enum을 복잡하게 넣지 말고 Wrapper 함수를 만들어서 아예 새로운 함수를 제공합니다. Split.RemoveEmpty 이런 식으로 만들어서 그 함수를 호출하게 만들어요. 그 이유는 뭐냐면 저희가 많은 문자열 연산을 하다 보면 되게 중복되는 문자열 연산을 많이 할 때가 있어요. 근데 그중에서 어떤 건 애매한 것이 있어요. 특히 C#을 가보면 문자열 비교할 때 Ignore Case에서 비교하는 방법이 있거든요? 여기 Enum이 들어가는데, Ignore 모드가 되게 여러 가지가 있어요. 뭐 InvariantCulture 뭐 Ordinal 막 이상한 것도 많아요. 그 의미를 사람들이 읽긴 읽는데, 읽고 100% 이해 못 하고 이상한 거 쓰는 사람들이 많아요. 그래서 그냥 '우리 회사 이런 비즈니스 로직 하에서는 이거 하나만 쓰면 된다.' 그럼 이걸 Wrapping 해놓고 다른 거 다 금지하는 거예요. 그래서 굳이 문자열 연산을 제공하는 함수에 들어가는 여러 가지 모드를 별도의 함수로 만들어 Wrapping을 해놓은 게 많아요. 지금 말했던 Ignore Case도 그렇고, 우리 회사 내부에서 문자열 연산을 할 때 InvariantCulture를 다르게 하면서 비교할 일은 죽어도 없거든요? 우리는 이게 필요하면 함수를 따로 윗단에서 만들면 되는 거예요. 그게 아닌 이상 대부분 Ordinal이나 InvariantCulture로 하는 건데, 이걸 굳이 열심히 쓰면서 코드도 길어지고 잘못 쓰는 경우도 있는 걸 막기도 싫고 그냥 '이게 맞는 함수야? 보면 너도 이게 맞는 함수고 알 거야.' 식으로 훈련하고 있는 이유도 있어요.

이 외에 또 다른 이유가 특히 메모리 관리를 자동으로 해주는 언어에 익숙해지신 프로그래머들이 좀 이런 것 같은데, 임시 문자열 만드는 거에 대한 거부감이 없어요. '어떤 문자열이 어디에 존재하냐?'라고 확인할 때, 단순히 '이게 String.IndexOf에 뭐가 있어?', '있어.' 그러면 끝날 수 있는 것들 있잖아요? 이런 것들을 막 이상하게 Split을 하고 String.SubString을 한 다음에 읽는 분이 있어요. 이런 여러 가지 연산을 할 수 있는 것을 저희는 그냥 별도의 함수로 만듭니다. 그래서 '이 함수 하나 호출하면 네가 하고 싶은 것 가장 효율적으로 할 수 있는 것.' 이런 개념으로.

그래서 그런 식으로 계속 유틸리티 함수를 만들다 보니까 다양한 모드를 지원해야 했던 많은 문자열 함수를 저희가 금지 목록에 계속 추가하고 있어요. 문자열 연산 자체가 그렇게 무지 느린 연산은 아닌데, 만약에 가독성도 높이고 굉장히 편하게 다른 함수 호출 한 번만으로 바꿀 수 있는 것이 있다면 해주는 게 좋아요. 나중에 무슨 '동접자 수가 어마무시하게 올랐는데, 서버가 좀 느려서 올려야 해요.' 이런 순간을 한 1년이라도 늦출 수 있는 상황들이 있거든요? 그래서 기본적으로 빠르게 작성할 수 있는 코드를 굳이 안 할 이유는 없어요. 단, 이렇게 작성하는데 생각할 게 많고, 하나하나 꼼꼼히 고민해야 하고, 코드도 많이 작성해야 하면 누가 하겠어요? 가성비가 안 맞거든요? 근데 '야! 네가 이 짓 하느니 이 함수 한번 호출하면 끝나. 이게 Garbage를 만들지 않는 빠른 함수야.' 그럼 안 할 이유가 없거든요. 저희는 이렇게 간단히 잡을 수 있는 성능적인 문제점, 그리고 나중에 고치려면 되게 머리 아픈 문제점을 선제적으로 방어하는 게 있어요. 그래서 실제 Split 같은 함수도 저희가 코드 리뷰할 때마다 일단은 되게 심각하게 보는 부분이에요. Split 함수가 들어왔다? 그러면 이걸 다른 연산으로 할 수 없는지 검토자들이 고민을 많이 해요. 그래서 이게 프로덕션 라이브 올라가는 코드일 때 '다른 거 쓰라'라고 계속 지시를 해줘요. 그냥 내부 데스크톱 툴 돌리는 거다? 신경 안 써요. Split 하면 Split 하라지. 내부 관리자 툴이다? '그래그래. 해. 상관없어.' 우리가 만드는 자동화 툴이다? '오케이. 이 정도는 상관없어.' 단 prod 나가서, 라이브 나가서 어쨌든 간에 최대한 기본적으로 빨리 돌아야 하는 코드들은 이런 식으로 작성하고 리뷰를 보는 습관이 들어가 있습니다.

그래서 제 생각에는 많은 C#의 문자열 함수 굉장히 강력하고 모드도 굉장히 많아요. 여러 가지 모드를 바꿔 써야 하는 일이 있다면 차라리 Wrapper 함수로 하나 만드는 게 장기적으로 유지 보수가 쉬울 거예요. 그리고 나중에 가면 내부에서 추가로 검증할 수 있는 여러 가지 방법도 있어요. 우리가 Wrapper로 했기 때문에 이 데이터가 들어온 게 뭔지 Debug.Assert 같은 걸 넣을 수 있는 경우가 있어요. 나쁘지 않은 방법이고, 저희는 많은 문자열 함수에서 특정한 매개변수가 들어가는 걸 막기 때문에 이런 식으로 하는 것만 하고 Wrapper를 만드는 것만으로 문자열 함수를 꽤 효율적으로 더 쓸 수 있을 겁니다.

포프였습니다.