다시 오랜만에 비주얼 C++ 얘기를 조금만 해 보죠. 비주얼 C++ 2013에만 동작하는 게 아니라고 생각을 하는데 2012가 될 수도 있고요. 정확히 모르겠어요. 요즘 비주얼 C++ 개발팀에서... 마이크로소프트 개발 팀이죠? 거기서 새로운 비주얼 C++ 기능들을 다음 버전 나올 때까지 기다리지 않고 익스텐션 개념으로 미리미리 일찍 공개를 하더라고요. 그거 얼마 전에 뭐 하나 말씀드린 것도 그게 있었는데 기억이 안 나고 뭐였는지... 그래서 오늘도 그런 걸 하나 설명드리려고 해요.

최근에 비주얼 C++ 팀에서 만들었던 익스텐션 중에 Speed Cop이라고 있어요. Speed라고 하면 속도고 Cop이면 경찰이잖아요? 그러니까 성능 향상을 할 수 있는 고성능의 코드를 만들기 위해 힌트를 주는 그런 익스텐션을 만들었어요. 비주얼 스튜디오 익스텐션 갤러리 가서 다운로드하시면 되고, Speed Cop이라고 이게 뭐 하는 거냐면 C 코드를 짜다 보면은 그런 거 있잖아요? 가장 좋은 예가 루프 돌릴 때 얘기예요. 루프 할 때 가장 잘해주는 것 같으니까 루프를 돌릴 때 배열이 예를 들어서 flot이나 integger 그러니까 4바이트 되는 변수를 요소로 갖고 있는 배열이 있고 그냥 배열 하나를 다른 배열로 복사할 때 예를 들어서 아니면 각 배열마다 숫자를 4씩 더해 줄 때 있잖아요? 배열 이름이 a라면 a[0]에 +1 해주고 a[1]에 +1 해주고 a[2]에 +1 해주고... 각 배열 요소끼리는 서로 더하거나 이런 거 없이 한마디로 독자적으로 뭔가를 처리하는걸 모든 배열을 훑으면서 할 때 이거를 굳이 하나하나씩 안 해주고 그 네 개를 합쳐 갖고 16바이트를 해갖고 처리하고 한 번에 더 해 줘도 되거든요? 왜냐하면 요즘 cpu는 그런 최소한 16바이트를 한 번에 처리할 수 있는 벡터 유닛이 들어가 있기 때문에 그걸 한번 해주면 속도가 더 빠르죠. 그 4번 어셈블리어 실행시켜 줄 거 그냥 한 번에 벡터 어셈블리 한 번 실행해 주면 끝이니까... 그래서 그런 걸 Vectorization라고 해요. 벡터화해 준다. 이제 그런 거를 자동으로 해 주거든요? 원래 컴파일러가 자기가 벡터화를 해줄 수 있으면 해 줘요. 근데 어떤 조건이 되면 벡터화를 못 해 주는 경우도 있어요. 왜냐하면 전에도 잠깐 C#이 C++ 보다 빨라진다는 얘기 했을 때 했던 얘기지만 컴파일러가 이렇게 최적화를 할 수 있는지 판단해주는 그런 코드를 돌리는 게 시간도 걸리고 그거를 수백만 개를 체크할 수 없으니까 어느 정도 제한이 있거든요. 그래서 체크를 하는 게 있기 때문에 체크에 실패하면 자동 벡터화가 안 돼요.

그러면 자동 벡터가 안 될 때는 과연 프로그래머는 어떻게 아냐? 솔직히 알 방법은 별로 없잖아요? 언제나 어셈블리어 코드 만들어 다시 보지 않는 한 알긴 어렵거든요. 근데 프로그래머가 어셈블리어 맨날 보는 사람이 언제 있어요? 별로 없어요. 내가 그런 거를 좀 해결해 주고자 나온 게 Speed Cop이에요. 이게 뭐냐면 아까 말씀드린 벡터 코드 있잖아요? 그 배열 코드를 실행을 했는데 만약에 벡터화가 안 됐다? 그러면은 컴파일할 때 출력 창이나 오류 창 이런 거 있잖아요? 제 생각엔 Error창에 나왔던 거 같기도 한데 Warning으로 기억이 정확히 안 나요. 아마 그 출력 창에서도 나올 거고 Error창에 보면은 Warning으로 나올 거예요. 아마. 거기서 나오면 '아 요기 있는 코드가 이런 문제 때문에 벡터화를 못 했다'라고 힌트를 보여주는 그런 익스텐션이에요. 그래서 그 힌트를 보고 거기로 간 다음에 '아 문제가 이거구나' 해서 코드를 조금만 고치면 컴파일러가 벡터화를 쉽게 판단할 수 있게 만들어 주는 거죠. 대표적인 예가 하나가 뭐냐면 아까 말한 배열 예제에서 요소 수가 한 30개쯤 하면 벡터화가 안 될 거예요. 근데 그게 한 12~15개 까지는 벡터화가 되는 걸로 알고 있어요. 그래서 그런 것들도 있고 그런 경우에는 해결하려면 마이크로소프트 자체 키워드인 __restrict 써주면 그것도 알아서 해주기는 하겠지만 어떤 의미에서는 컴파일러에 너무 종속되어 있는 그런 키워드는 별로 안 쓰는 게 좋잖아요? 이식성 이런 거 따질 때? 그런 거 고려해 봤을 때는 그냥 Speed Cop을 켜 놓고 그런 warning이 나왔을 때 혹시 이제 곧 치기 쉬운 거면은 고침으로 인해 코드의 성능을 향상하는 좋은 방법이 되는 거 같아요. 근데 이제 Speed Cop의 제한점은 뭐냐면 디버그 빌드에서는 Speed Cop이 안 돼요. 릴리즈 빌드에서만 돼요. 당연한 예기죠 최종 코드가 릴리스 빌드니까 거기서 어떤 게 벡터화되는지 봐서 그거를 판단해 줘야죠. 그리고 디버그 빌드는 최적화 꺼져 있는 경우가 대부분 이니까 그런 백터 화가 일어나지도 않을 거고요. 

그래서 혹시라도 이게 궁금하신 분들은 한번 다운로드하여보세요. 이제 비주얼 스튜디오 갤러리 가셔 갖고 Speed Cop 다운로드하신 다음에 릴리즈 빌드에서 컴파일해 보시고 혹시 벡터화가 자동으로 안 됐다는 거나 다른 컴파일러 최적화가 불가능했다 그런 메시지를 찾아보시고... 뭔가 제약점 하나 있었던 거 같은데 그거는 고쳤나? 고쳤을 수도 있어요. 처음 Speed Cop 나왔을 때는 컴파일하는 코드 창을 열어 두지 않으면 벡터화에 실패했다 이런 메시지가 안 나왔던 걸로 기억을 하거든요? 그래서 언제나 코드 cpp 파일 열어 두고 컴파일했어야 하는데 제 기억에는 지금 다음 버전이 나왔어요. 거기서는 그 문제를 고쳤다고 제가 기억을 하거든요? 정확히는 기억이 안 나고 혹시라도 갤러리 페이지 익스텐션 페이지에 보면은 분명히 예제가 있을 거예요. 예제를 실행했는데도 벡터화가 안 됐다는 메시지가 없다 그러면 한 번 cpp 파일을 열어 보시고 실행해 보세요. 그래서 되면은 아직도 그 버그는 안 고쳐진 거예요.

그래서 제가 요즘 C++ 코드를 많이 짜고 있진 않아요. 놀고 있기 때문에 요즘에 책 작업을 주로 하고 있고 제가 아직도 실무에서 지금 매일같이 C++를 만지고 게임을 최적화하는 단계라면 많이 쓸 거 같은 기능이긴 해요. 왜냐하면 그냥 공짜로 얻는 성능 최적화니까 어떻게 보면은 그럴 것 같아요. 켜 두고 그런 거는 좋은 거 같아요 근데 또 한 가지 걱정은 이게 2014에서 컴파일러가 다르게 최적화가 되면서 컴파일러가 쫌 바뀔 거 아니에요? 그럼 2013 버전하고 2014 버전의 최적화 패턴이 다를 수가 있어요. 최적화하는 방식이. 그러면 원래는 벡터화를 시도하던 걸 벡터화 자체를 시도를 안 하면 2013에서 이게 이렇다고 얘가 하도 warning을 줘서 코드를 막 고쳐놨는데 2014에서는 처음부터 최적화를 안 시키려고 하면 warning도 안 날 거고 오히려 그걸로 코드가 나빠질 수도 있지 않나?라는 생각도 좀 들고... 좀 더 생각을 해 봐야겠네요. 그래서 본론은 Speed Cop 모르시는 분들 한 번 받아서 사용해 보세요. 괜찮은 거 같아요. 포프였습니다.
