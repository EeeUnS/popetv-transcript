얘 안녕하세요 포프 입니다 음 이 비디오는
제가 지난 복지사회 논을 해왔어요
굉장히 초반에 만들려고 했던 미디어 인데
그냥 밀렸어요 그러다 오늘의 말하게 되는데 제가 이 패턴을 쓴 지가 벌써
쫌만
이 2년 정도가 된거 같아서 제가 엔진을 처음부터 빌드 한계
마지막 해본게 한 1 2년 된 것 같아요
그래서 제대로 설명할 수 있지 모르겠지만 노력을 해 볼게요
제가 예전에 인터페이스 떡칠 하지 말라는 그런 식의 비디오를 만든 적이
있어요 그때 제가 했던 얘기가
야 인플레 멘 테이 션에 하나면 왜 인터뷰에서 게임 플랜츠 남느냐 그거는
그냥 하나의 클래스가 맞다
인터페이스 라는 것은 기본적으로 다양성을 위해 있는 거다
그 범위를 넘어가 속 엉뚱한 데 쓰기 시작하면 은 굉장히 피곤해 진다
라는 이게 했었어요 그래서 그거랑 약간 니 맥 상통하는 얘기에요
특히 이제 멀티플랫폼 용 게임 엔진을 만들 때 그런 문제가 많이 생겨요
저희가 이제 그래픽 엔진을 제가 주로 만들었으니까 그래픽 쪽이라고
얘기할게요
그러면은 각 플랫폼 마다 쓸 수 있는 api 는 보통 1 정도가 되어
물론 pc 게임에서 오픈 주의라 고지에 텍스 를 동시에 지원하는 게임들도
있지만 대부분은 제 그냥 지역 텍스 으로 유라의 가져
그러면 pc 에서는 디렉터 있어요 아
엑스박스 에서는 또 엑스박스 용의 그래피 sdk 가 있어요
디텍션 비슷하지만 약간 다르죠 ps 플레이 스테이션 가면 사람들이 아
플레이스테이션 오픈 줄 지원 하잖아요
그렇지만 사실은 플레이스 전에도 자체 그래픽 stk 가 있어요
지금 애플도 그렇죠 메탈 뭐 이런거
그러면 그리고 뭐 다른 게 뭐 있을까 닌텐도 스위치 스위치를 사채 그래픽
했을 때 개가 있어요 그래서 모든 플랫폼 마다 자체 그래픽 stk 가
있어요
그러나 이 그래픽 엔진을 제가 만든 그래픽 엔진이 멀티 플랫폼에 돌때
게임 쪽에서는 가 플랫폼이 뭔지 신경을 안쓰고 아 이거 그려 적어 그려
이거 그려줘
뭐 이 텍스트 로딩 해 줘 이런 것만 하면 되는거잖아요
그래서 추상화를 통해서
실제 나는 저 밑에 있는 플랫폼이 뭔지 모른 채 이거를 그려 줘 라고
하는 것만으로 이 데이터를 그려줘 하는거 그려달라고 해주는 것만으로도
그게 화면에 나올 수 있어야 하는게 정상적인 방법이죠
그럼 사람들이 일반적으로 생각할 때 이게 좀 약간
그러니까 생각은 있는데 아주 충분히 아직 있 있지 않은 프로그램 얻을
그래픽 프로그램에 대한 생각지 중의 하나가
오 그래 인터페이스를 똑같아야 하고
아구 연체는 여러가지 니까 그러면 인터페이스 하나 만들고 앱스 택트
클래스 정도가 되겠죠 아니면 페어런트 클래스가 되거나 그리고 밑에 실제
구현체 디렉 텍스 오픈 지에 미흡 수용으로 오픈 지에 그리고
아
아 뭐 ps4 엑스박스 원 이렇게 구현체를 여러개 만들면 되겠지 라고
인터페이스 그리고 상속을 만들어서 실제 구현을 해요
그러나 저는 이렇게 말 하거든요
어째 컴파일할 때는 한 플랫폼 마다한 인플레 멘트 전 컴파일 해야 되는거
아니냐고
내가 pc 온 컴파일하는 데 ps 뽀얀 컴파일 없잖아요 같이
그러면 이거는 pc 용으로 빌드할 때는 컴파일이 안되는 코드 줘 그럼
결과적으로 실행 주도 중에는
크 인터페이스 하단 9 야채가 딱 하나만 있는 거예요
그러니까 코드 레벨 코드를 처음 짤 때 아이코드 절대 인터페이스를
강요하기 위해서 이렇게 만들면 된다 라고 생각을 했지만 실제 다형성
이라는 것은 실행중에 부 연체가 몇 개가 있냐 의 문제일 뿐 이예요
사실일까 그 개념으로 봤을 때는 이미
다양성을 제대로 쓰고 있지가 않은 거죠
그리고 당연히 누구나 아시겠지만
그럼 더 추워 함수를 쓰고 다양성을 알려 더 처럼 쓸 수 밖에 없죠 가상
함수
그럼 즉 뭐 게임 단에서 돌리기에는 뭐 그 정도는 해도 상관이 없는데
다양성을 써서 보아도
그래픽 엔진 같은 경우는 한 함수가
프레임 한번 돌때 1000번 2000번 호출하는 경우 되게 많아요
그런거를 이제 가상 함수를 만들어서 중간에 점프 테이블도 받고 한번도
뛰어야 되면은 메모리를
거기서 오는 저와 가 게임도 는 시간에 그게 10% 20% 가 잡히는
경우도 있으 10% 좀 구라다 10% 정도가 잡히는 경우도 봤어요
그래서 그런 가상 함수를 필요없는데 놓는 것 자체가 그래핀이 쪽에선
굉장히 큰 문제가 돼요
그럼 이것을 어떻게 구현을 하느냐
이제 그 얘기로 오늘 하고 싶은 거에요 이제 정확히 이거 의 이름이 뭔지
모르겠어요
이거에 대한 이름이 있는지 조차 모르겠어요
왜냐하면 이것은 c 풀풀 에서만 가능한 거거든요 사실은 물론 시 샵에서
이젠 가능할 것 같긴 한데 모 씨 샵에서 그렇게 다른 플랫폼용 그래픽
엔진을 만드는 경우 별로 없으니까
저는 패턴이라고 그냥 불러서 리버스 오피 패턴 이라고 해요
오피에서 op 뒤집었다 고 하는 거에요 까 반전된 op 패턴 이라고
하는데 이걸 어떻게 만드냐
어케 기찬의 설명하기 보통은 이런 식으로 만들잖아요
으
인터페이스 를 위에 만들죠
그래픽에서 한 가지 만들죠 그러면 드로우 함수가 있다고 얘기를 하고 그쵸
그러면
제목을 줘야 될 것 같아요 웬 더 로 베이스 라고 해놓고 클래스 이름을
함수 이름을 들어오라고 정해 나요 그리고 이거는 뭐 버추얼 암술이 수밖에
없어요
그러면 그 밑에 pc 웬 더러 가 있고 그 pc 렌더러 가 이걸 상속한
다음에 그쵸
드러워 함수를 잘 오버라이드 하게 되죠 그럼 이게 아까 제가 말했던 약간
좀 덜 익은
아 프로그래머들이 만드는 방식이 그게 되요
그런데 이걸 이렇게 안 하는 법이 있어요
어떻게 아니야
일단 이거는 그냥 헤더 파일과 cpp 파일이 분리되어 있다는 싶을 뿔의
이제
단점이 장점을 이용한 거에요
그럼 어떻게 만드냐 일단
렌더 로 베이스를 일단 맨 더 로컴 원으로 바꿀 게요 공통된 렌더러 란
개념이 에요
그럼 렌더록 한번으로 하고 거기에 드러워 함수가 즉 있어요
가상 함수가 아니라 실제 그냥 함수로 보이드 들어오 가 있고 뭐 그리고
거기에 제 이거는 헤더 파일에 있는 거죠 그러면 선언만 한 거에 선언만
그러고 이거에 대한 구현이
웬 더 컴 몬 다시 피 피의 없어요
금 어디에 두느냐 이거를 렌더러 pc 다 cpp 안에 넣어두는 거에요
단 그 들어와 암수를 이제 구현체를 울 때 원래 렌더러 pc 다 cpp
를 보면 은
원칙상 은 그 안에 클래스가 뭐든지 웬 더러 pc 가 달리고 앞에 콜론
콜론 타고 들어온 놓았고 구현체를 만들어야 되잖아요 근데 그게 아니라 그
안에
렌더러 컴 몬 콜로 콜로 올 들어 5를 그 안에 구현을 하는 거예요
그러면 pc 를 빌드할 때는
아 렌더러 pc 와 cpp 를 빌드 하게 되잖아요 그럼 거기서 아까 컴온
에서 선언을 해 놨던 들어와 함수 거기서 보이기 때문에
컴파일이 컴파일을 하고 무리없이 넘어가요
그리고 pc 가 아니라 엑스박스 원 용으로 또 들어와 암수 루가 들어
있겠죠
그 안에도 똑같이 렌더 로컴 먼 콜론 콜론 들어 함수가 있지만 pc 를
빌드할 때는 그 엑스박스 용이 빌드를 안하기 때문에 아무 문제가 없이
넘어갈 수가 있는 거에요
재미 있죠 그래서 이런 식으로 구현을 하면 은 상속이
까 가상 함수를 안쓰고 상속을 받아 하고 만들수 있는 방법 이렇게 생겨요
그러면 상속은 왜 그래도 필요하냐 렌더록 핫머니 있지만 그 안에
함수 지금 얘기를 했어요 하지만 이제 그 렌더러 에서 pc 렌더 에서
돌리려면 은 뭐 디바이스도 있어요 컨텍스트 있어야 되고 이게 그 플랫폼
전용 에 데이터 타입 이잖아요
그런 데이터 타입을 정리 해야 되는데 그걸 컴 번에 넣을 수 없다는 거죠
그럼 이 데이터 타입은 어디에 있냐
2 데이터 타입은 웬 더러 pc 다 헤더에 들어가요
그쵸 이건 어제 pc 용으로 * 되는 거기 때문에 상관이 없어요
내어 재미 있는게 뭐냐면
지금까지 얘기해 온 것은 앞에 세웠던 렌더러 컴온 헤더 파일에 들어왔을
놓고 웬 더러 pc cpp 파일에 들어 함수 를 구현한다 가 전부였어요
그쵸
근데 저렇게 상속 관계가 어떻게 된지 얘기 안 했어요
일반적으로 제가 생각할 때는 아까 가 상암 쓸 때 처럼 컴 뭐니 위에
있고 부모로 있고 그 밑에 렌더러 pc 가 상속을 받아야 되는 것
같잖아요
근데 이렇게 하면 안돼요 왜 안되냐
아까 말했던 컨텍스트가 있잖아요 그 모 디바 있었던 컨텍스트 pc 용에
만들어 가는 그런 데이터 타입
내가 들어와 함수로 출 했는데 이 들어 암소 출 구현을 렌더러 pc
cpp 에서 하지만 여전히 소유하고 있는 클래스 른 앞에 콜로 콜로 마킹
더클래스 그게 렌더러 커먼 이에요 그래서 여기서 디바이스 호출할 방법이
없어요 왜냐면 디바이스는 그 자식이 되는 렌더러 pc 에 들어가는 거니까
그래서 상속 관계를 뒤집어 줘야 되요 이게 제가 리버스 op 라고 말하는
되요
이외에 어 그럼 다시 정리를 하면 어떻게 되는거냐 면
렌더러 pc 나 헤더 파일에 뭐 디바이스 컨텍스트 이런게 데이터 입으로
들어가 있어요 헤더 파일에 그쵸
그리고 렌더러 pc cpp 파일에 금호 데이터를 초기 해주거나 이런
것들이 어는 것 인가 함수에 들어가 있는 거에요
그리고 그 클래스 는 당연히 렌더러 pc 클래스 연말 하는거고 그쵸
자 그럼 여기에 있어요 그럼 컴 뭐니
그쵸 커먼 이 웬 더러 피스를 상속을 받아야
물 그래서 이제 렌더러 pc 를 상속을 받아야 되고
모 음 웬 더러 뭐 엑스박스 를 상속받아 되고 잃어야 되잖아요 플랫폼
마다 그 요부분 많은
이 풋 f 가 들어갈 수밖에 없어요 상속을 할 때 이프 대포를 만들거나
아니면 플랫폼 맨 들어 라고 만들어서 플랫은 렌더러 가 아 뭐 디파인 이
된게
pc 에서는 pc 렌더러 pc x 파일 맨 2 엑스박스 이런식 하면
되는거예요 그러면 결과적으론 웬 더 락커 머니 상속을 받는 애는 플랫폼
렌더록 실제 게 어느 플랫폼을 빌드한 이에 따라 pc 가 될 수도 있고
엑스박스 될 수 있다
그러면 렌더러 커버는 아까 말했던 디바이스 나 컨텍스트에 대한 접근권한
있죠
프로텍 티드 아 억세스 모디파이어 돼 있다는 가정하에
접근권한 있어요 그러는 아까 말했던 들어 함수 들어 함수는
이 함수 시피 함수 극우 연체는
웬 더러 pcp 안에 있지만 실제 이거를 가지고는 클래스는 렌더러 커먼
이잖아요
그렇죠 그리고 렌더러 커먼 해서 어느 디바이스 써봤고 그려야 되는데
그래서 m 디바이스 특 뭐 뭐 3 덜 텍스 워커 이런걸 할 때
m 디바이스 접근할 수가 있는 거에요 왜
커먼 은 아까 말했던 pc 에 자식이 되니까
그래서 이런 식으로 구조를 하면은 그리고 모든 함수를 그렇게 구조를 할
수 밖에 없죠 구축을
이런식으로 구축을 하면은 아
아까 말했던 가 상태 이브 이런게 필요가 없이
음 이런 식으로
예 그냥 컴파일 시에 모든 걸 은 양 부모 자식 관계 개
그러나 가상함수 없이 빌드가 되는거고
그리고 실제 호출 할 때도 가상 함수를 써왔고 아 뭐 이렇게 느려지는 거
5.4 테이블을 쓰면서 두 번의 인증 액션 뭐 이런 기 없으면서
음 성능 그런게 있어서 오늘 성능 저하도 없어지기 때문에 그냥 손으로
처음부터 코딩 짜는 거란 크게 다를 바가 없는 결과가 나오는 거죠 그럼
그 송 코딩과 다르지 않지만
장점은 5p 로 구조를 쌓았기 때문에 좀 관리가 또 편해졌다는 것도 있고
그리고 원래부터 폴리머 p 즘 제대로 써 같고 뭐 가상함수 서화 빨려고
했던 것처럼 인터페이스에서 강제가 되는 거죠
왜냐 내가 커먼 렌더러 에 들어 함수를 만들어 놨어
그쵸 근데 극우 연체가 pc 에만 있잖아요
엑스박스 원을 만드는 데 그 엑스박스 파일 안에 또 그걸 또 구현은 안
해버리면 컴파일 자체가 안 되잖아요
9 연체가 없으니까 그래서 컴파일시 이걸 강요하는 그 입장에서는
아 인터페이스의 똑같은 걸 강조하기 위해서 썼던 그런 가상함수 책에 그런
게 고대로 인 볼 수가 되는 거죠 그래서 실제
멀티플랫폼 용으로 엔진을 만드는 회사가 되게 많잖아요 북미 쪽에는 여전히
그런 회사에서는 이런 구조를 되게 많이 써요
이에 이쪽에서 썼고 캡콤에서 썼고 생각보다 얼티 플랫폼을 좀 들 만들었다
한국에서는 이런 고민을 할 필요가 없었던 것 같은데 저는 심지어는 이게
예전에 모바일 쪽 엔진을 직접 만들 때도 요즘 유니티 많이 쓰지만 대로
만들 때도 이 방식으로 해서 아 많은 부분을 좀 해결해 나갔던 적이
있어요
그래서
뭐 지금 과연 유용성이 얼마가 될지 모르겠지만
리벌스 op 패턴은 생각보다 게이머 께서 만 있었고 그에 비해 뭐 패턴
책이라도 뭐 이런거에 나오지 않았던 이유가
패턴 책을 주로 만들었던 사람들은
잡아 쪽 사람들이었다 고 생각하고 옛날에 op 에 추상화가 맞는 이다
라고 생각했던 약간 좀 잘못된 생각을 하셨던 분들의 문제였고
그 사람들이 10불 부 에서만 어쩌면 가능한 이런 부분이 할 수는 없는
거죠
그냥 여담으로 끝내기 전에 이제 아까 처음에 얘기했듯이 샵으로 는 가능할
수 있다는 얘길 했던 이유가 뭐냐면
시 샵에 있는 파샤 1클래스 라는게 있어요
클래스 이름을 하는데 클래스를 여러 빨러 나누는 법이 있고 그리고 각 그
c 샵 은 이제 잡아 나 이런거 고 다르게 컴필레이션 스위치 라고 해서
아 그 c 풀뿌리 보는 #2 부디 파인드 대학교 이제 아이 컴파일이 안
되게 빼는 부분 코드를 빼는 방법이 있잖아요 그거를 시사회도 할 수가
있어요 그래서
웬 더러 를 하나 만들어 두고 그 외 렌더러 에 함수들을
이제 선언 부분 자체를 아예 다가 플랫폼 들로 뽑아 버리면
그리고 내가 어떤 플랫폼을 빌드한 에 따라 그 잎을 f 가 바뀌게
해놓으면 각 파일마다 그럼 pc 용으로 있던 렌더러 pc 해서 들어옴
써도 빠졌어
엑스박스 흠으로 이제 들어 pc 를 하려 아이 트롤을 하려고 그러는데
고기 아직 g 술 안 맞는거 야
그리고 이미 그걸 호출하는 코드가 어딘가 있겠죠 그럼 그 순간에 이
함수가 없다고 컴파일 에러가 날수 밖에 없죠 그래서 그런 식으로
약간은 이제 강제하는 법은 있어요
파샤 클래스가 있고 아까 그 파일 전체 단위로 그냥
잎을 f 에서 빼 버리는 법이 있기 때문에 그래서 시작도 가능은 하지만
모씨 샵에서 멀티플랫폼 돌려봐야 며 때면 돌린다고
자 마린 돌리 때 뭐 안드로이드 ios 윈도우 수용 이런거 할때는 그런것
좀 썩인 썼죠
8클래스 해서 하는 것 근데
게임 쪽에서는 * 없지 않을까 라고 생각을 해요
으
그리고 뭐
자 마린 쪽에서 만드는게 보통 앱 이라고 생각하면 게임이 아니라
뭐 가상함수 좀 떡칠 한다고 해서 크게 문제가 생기고 또 없을 수도 있고
그래서
그래픽 엔진 쪽 멀티플러그 만들때
음 이런 쓸데없는 가상 함수 호출에 대해 들어가는 오버 아이들을 피하기
위해서 그리고 뭐 op 적으로 좀 말이 안되니까
말도 안되는 이거 cop 패턴을 썼던 것들 경험들
그런걸 그냥 말하고 싶었고 멀티 플랫폼으로 개발하시는 분들은 한번쯤
생각해 보면 해요
내가 과연 실행 도중에
5 pc 를 열면 실행 도중에 오픈 gl 과 디렉 텍스를 그렇게 바꿔
살리기 있는가
차라리 exe 파일을 2개 만든 것인 하지 않은가 컴파일 2번의 고치면
되는 거니까 그런 생각을 하면은 그냥 제가 말했던 패턴으로 가고
게임 다 dex 게임 다 고품질 다 ex2 2개로 exr 컴파일 따라서
주는 훨씬 낫죠
그래서 좀
에 그 정도면 될 것 같아요 그래서 지금은 잘 안 쓸 지 모르지만 한때
제 삶의 활력을 줬던 그런 패턴 이거 소피 패턴 정식 이름 아시는 분
있음 알려주세요 저는
정식 이름을 들어본 적도 없어요 예 뽑혔습니다
