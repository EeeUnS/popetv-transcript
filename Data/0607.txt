안녕하세요, 포프입니다.

오늘도 제가 코딩 표준을 책임지고 있는 회사에서 금지된 코드 사용 부분을 또 하나 소개해 드릴게요. 일부는 제 웹사이트에도 올라가 있고 아니면 그 회사들의 내부 문서에도 일부 추가로 올라가 있습니다. 코딩 표준을 어겼을 때는 빌드가 안 되거나 테스트 실패하면서 배포가 안 되게 되어 있고요, 당연히 이건 제가 코딩 표준을 책임지고 있는 회사, 그 회사에서만 일어나는 일이고, 제가 그렇지 않은 회사, 다른 분이 정해준 코딩 표준이 있는 회사, 제가 거기에 맞춰가서 일해야 하는 회사에서는 당연히 그 코딩 표준대로 일을 해줍니다. 그래서 코딩 표준은 '내가 맞다.'가 아니라 그 회사에 있는 코딩 표준이라는 걸 이해해 주시면 좋겠어요.

오늘 말할 건 은근히 꿀팁이 될 수도 있어요. 그리고 좀 더 올바르게 데이터를 유지하는 방법일 수도 있고요. 뭐냐면 C# 같은 데서 JSON 같은 거 직렬화, 역 직렬화할 때 JSON.NET 쓰시거나 System.Text.Json 쓰시잖아요? 그럼 거기에 있는 직렬화, 역 직렬화 클래스라던가 함수 있죠? 저희는 이거 직접 사용 금지입니다. 저희는 따로 저희만의 함수가 있어요. 그 이유는 뭐냐면 이 JSON 직렬화, 역 직렬화가 굉장히 파워풀해요. 굉장히 자유로운 데이터를 열심히 직렬화할 수 있다. 역 직렬화할 때는 약간 복잡한 것들이 많아요. 다형성 때문에 그런 것들이 있어요. 그리고 여기 들어가는 클래스들을 어떻게 작성하느냐에 따라 어떤 프로퍼티는 직렬화가 될 수도 있고 안 될 수도 있고 여러 가지 복잡한 규칙들이 있어요.

저희가 이걸 다 봤을 때 버그가 많이 발생하는 부분이 여기였어요. 실제 코드에서 생성할 때부터 개체가 올바른 걸 강제하기 위해서 이상한 것들을 넣다 보면 어느 순간 직렬화되던 게 안 되기 시작해요. 안 됐는데 그 사실을 알지도 못해요. 나중에 돌리다 보니까 어떤 데이터가 누락돼 있고 이런 경우도 너무 많은 거예요. 그래서 '아! 이건 아니다. 우리가 파일로 직렬화하기 위해서 만드는 클래스는 그 클래스만의 어떤 규칙이 있어야겠다. 반드시 생성자는 이게 있어야 하고, 반드시 프로퍼티는 이렇게 만들어야 하고 반드시 이건 저래야 한다'라는 어떤 규칙을 만들고, 직렬화되는 모양도 어떤 건 최소화 되게 되는 게 있고 아니면 보기 편하게 최소화가 안 되게 하는 경우도 있잖아요? 크기를 줄여야 하냐, 보기 편하게 하냐 따라서 이런 여러 가지 규칙에 따라서 분류하고 싶었어요.

그래서 저희는 인터페이스를 만들었습니다. '이 인터페이스를 상속받으면 얘는 파일에 저장되는 애', '이 인터페이스를 상속받으면 우리 내부 API에서 주고받는 애', '이 인터페이스를 상속받으면 우리가 외부 퍼블릭에서 request를 받는 애'. 이런 식으로 해서 각 DTO 클래스가 인터페이스를 상속받게 했고요, 그럼 인터페이스를 상속받으면 이 인터페이스를 상속받은 클래스는 '어떤 요구 조건을 만족해야 한다'는 내부적인 규약이 있어요. 그리고 그 규약이 저희 테스트에 다 들어가 있어요. 그래서 전체적으로 어셈블리를 다 긁은 다음에 얘를 상속받는 클래스들은 다 이 규칙을 따르고 있고, 그 안에 들어간 내포된 또 다른 클래스들은 이게 퍼블릭 공개되어도 되는 건지, 아닌 건지. 왜냐하면 그 클래스를 딴 데서 공유했는데 이게 실제 내부 데이터가 들어갈 수 있거든요? 그것 따라 속성이 제대로 박혀있는 것까지 다 확인해요. 그래서 저희는 정형화된 몇 가지 인터페이스가 있고, 그 인터페이스에 상속받은 클래스만 직렬화, 역 직렬화를 해야 하기 때문에 이걸 위해서 Wrapper 클래스를 만들어버렸죠. 그래서 저희는 내부적으로 JSON Serialize를 호출하는 순간 배포가 안 됩니다. 저희가 가지고 있는 Converter라는 클래스를 따로 호출해야 하고, 거기에 들어갈 수 있는 데이터형은 어떤 클래스형인데, 그 클래스는 반드시 저희가 가지고 있는 몇 가지 인터페이스 중에 하나를 상속받아야 해요. 이걸 한 순간부터는 그걸 담당하는 유닛 테스트가 이미 다 있으니까 그냥 어떤 클래스를 만들어두고 관련 클래스를 고쳤을 때 실수로 뭔가 망가졌는데 그걸 모른 채 라이브 나가는 일이 없어졌어요. 저희는 이렇게 확실하게 관리해서 직렬화할 때 복잡한 규칙 최대한 빼는 거죠. 직렬화하는 데이터를 최대한 단순하게 만들기 위해서 노력하고 있고, 이것 때문에 꽤 도움이 됐어요.

또 한 가지 곁다리로 말씀드리면 보통 JSON 직렬화되는 클래스 파일 같은 거 만들 때 위에 JSON Property Name 이거고 뭐는 뭐고 이런 속성 많이 박잖아요? 저희 기본적으로 속성이 없는 방식으로 가고 있어요. 속성으로 받고 뭐 하는 순간 나중에 딴 JSON 직렬화할 때 이거 다 바꿔줘야 하거든요. 그래서 그냥 기본 동작으로 최대한 사용하고, 이름 최대한 매칭해주고, 아닌 것들 몇 개만 예외를 적용해 줘요. 왜냐하면 외부에서 오는 요청, 이건 저희 코딩 표준에 맞지 않는 필드명이 올 수도 있거든요. 이런 경우만 별도로 예외 처리를 해주지, 기본적으로는 다 저희가 관리하는 것에 모두 맞도록 디폴트 동작으로 돌게 바꿔버립니다.

이렇게 한 이후로 저희는 JSON 파일 직렬화하는 경우 아무 생각 없이 작성하면 굉장히 잘 됩니다. 이게 불확실성 없애는 거죠. 나중에 터지는 거 검증하는 일 없애는 거. 그래서 JSON 직렬화 굉장히 막강하고 파워풀한데, 이게 어떤 파일을 주고받고 뭐 하고 할 때는 제가 말한 것처럼 어떤 분류를 나눠서 규칙을 딱 만드는 게 나중에 그 데이터 종류가 많아져도 굉장히 관리가 편해요. 이게 안 되면 나중에 땅 짓고 헤엄치기고 나중에 뭐 하나 리팩토링하려고 하면 저게 깨지나, 안 깨지나 이 불안함 속에 살 수 밖에 없어요. 그래서 저희는 JSON 직렬화 빡세게 규제하고 있고요, 그 외에 저희가 CSV 직렬화하는 경우도 있어요. 이것도 규제를 점점 넣고 있습니다.

포프였습니다.