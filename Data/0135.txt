예 포프입니다
제가 C#을 굉장히 사랑한다고 누누이 밝혀 왔는데
그러면서도 C#이 최근 들어서 좀 여기저기 망가졌다
라는 얘기도 했었잖아요
최근에 제가 발견한 건 아니고
저랑 굉장히 친한 친구이자 동료가 발견한 건데
C#에서 또 하나의 문제점을 발견했어요
이거는 최근에 만든 것도 아니고
좀 오래된 코드인데, 오래된 클래스고
어 그에 비해
어 이거를 왜 거기다 냅뒀을까 생각이 들 정도로
좀 황당한 코드를 발견했죠
황당한 코드가 아니라 이제 C# 자체 라이브러리인데
XML Serializer 라이브러리가 있잖아요
XML Serializer가 하는 일이 이제
XML 파일을 두고 이제 그거를 오브젝트로 옮긴다든가
오브젝트를 XML로 바꾼다든가 이 짓을 해요
그럼 이제 당연히 C#이니까
reflection 시스템을 잡고 하는 건데
이게 XML Serializer가 굉장히 재밌게 작동을 하더라고요
XML Serializer로 처음에 오브젝트나 XML을
serialize, deserialize를 할 때
그 내부적으로 어셈블리 파일을 만들어요
그니까 어떻게 만드냐면은
뭐 reflection 통해서 아 그럼 이거는 이렇게 해석하고
저렇게 해석하고 어셈블리 파일을 만들어 갖고
그거를 cache를 해 놓더라고요 메모리에
그리고 그 다음에 또 똑같은 타입을
serialize나 deserialize를 할 때
그 만들어진 어셈블리를 가지고 그걸 쓰는 거에요
그래서 처음 serialize할 때는 좀 느리고
그 다음부터 할 때는 굉장히 빠르게 할 수 있게
그래서 굉장히
뭐 올바른 방법이긴 하죠
그래 뭐 괜찮은 방법이구나
뭐 어셈블리를 미리 따로 만들려면
또 다르게 할 수도 있지만
뭐 그래도 제가 지금 말하는 문제점은
똑같이 발생하더라고요
이거의 문제점이 뭐냐면
이 어셈블리를 재활용하는 거
이..
이거를 재활용 하는..
그.. path라고 해야 되나요?
그거는
XML Serializer가 생성자가 되게 여러 개가 있어요
그 중에서 딱 두 개만
이 재활용을 해요 어셈블리 만든 거를
그게 첫 번째 Serializer가
XmlSerializer 들어가고 그 다음에 Type 넣을 때
그게 하나고
그 다음 게 XmlSerializer하고 그 다음에 Type, String
그게 아마 root node name인가 뭐 그런
namespace인가 그런 걸 거에요
그래서 요 두 가지 constructor로 할 때만
이 만든 어셈블리를 재활용을 해요
그러면 그거 말고 다른 constructor도 있거든요
저희가 요번에
제가 요번에 처음
요번에 봤던 그 constructor는, 생성자는
그 첫 번째 매개변수로 Type을 받고
두 번째 매개변수로 추가적인 타입이라고 해서
Type[ ]를 받아요
근데 그거를 딱 할 경우에는 어셈블리를
똑같이 만들어요 처음부터 실행할 때
똑같이 만들고 그걸 이용해서
deserialize, serialize를 다 하죠
근데 여기가 문제가 있어요
이거를 재활용을 안 해요
다음에 또 똑같은 타입으로 serialize를 할려고 그러면
똑같이 다시 어셈블리를 만들고
그리고 또 serialize를 하고
일단 속도가 느린 것도 문제지만
이 속도가 저희가 요번에 봤던 경우는
이 어셈블리를 만드는 속도가 1.7초였어요
근데 어셈블리 재활용을 하면은
실제 serialize하는 시간은 0.1초 미만
그래서 엄청난 속도 저하도 있지만
더 웃긴 거는
아까 어셈블리를 만든다 그랬잖아요
그럼 그 어셈블리를 만든 게 가비지 컬렉션이 되느냐?
안 돼요
그냥 어셈블리 만들어 두고 또 나중에 또
또 어셈블리 만들어 두고
만들어 두고 만들어 두고
그래서 이게 계속 호출이 되면서
memory leak을 계속 만드는 거에요
그게 MSDN Documentation에 써 있긴 해요
근데 어이가 없는 거에요
왜 이 함수를 냅두고 있을까
그래서 MSDN Documentation에서 하는 얘기는
만약에 이 두 constructor가 아니라
다른 constructor를 불러서 XML serialize를 할 거면
니가 이..
new XmlSerializer하고
그..
다른 매개변수 넣어 갖고 만든
그 오브젝트를
dictionary라든가 어디에 넣어 갖고
미리 cache를 해 두고 나중에 그걸 확인해서
이미 한 번 serialize한 거면은 니가 꺼내다 써라
그러니까 그..
XML Serializer 함수 자체가 내부에서 하던 일을
저희보고 하라고 권하는 거죠
근데
진짜 이해가 안 됐어요
솔직한 얘기로 코드 짤 때 문서 하나하나
다 읽어 보고 짜는 사람들 별로 없잖아요 요즘
그냥 해서 어 이게
XML Serializer 있고
이 함수 받으니까 이렇게 되겠구나
라고 해서 만든 것뿐이거든요
근데 첫 번째 성능 저하도 문제지만
두 번째 진짜 웃기는 게
이 memory leak이라는 게 진짜 웃긴 거에요
그렇게 성능 저하를 줄 거면
그냥 memory leak을 더 만들지 말든가
아예 어셈블리를 안 만들고
그냥 serialize, deserialize하고 버리면
다 가비지 컬렉트되게 하든가
그것도 아니고 어중간하게
양쪽에서 나쁜 것만 골라 온 거야
속도 느리고 메모리 잡아먹고 메모리 풀리지도 않고
그래서
보면서 저는
야 이거는 진짜 잘못 만들어 놨구나
그래서 이 문제를 찾은 친구하고
얘기를 좀 해 봤는데 어젠가 술 마시면서
이 친구 말로는 그 constructor 그게
사실은 파워 유저를 위한 거고
그냥 일반 유저들은 앞에 거 두 개만 쓰는 게 맞다
라는 식으로 얘기를 해요
그러면 제 주장은
어차피 코딩을 하는 사람의 90%가 개판인데
죄송합니다
개판인데
뭐 개판까진 아니어도
그렇게 뛰어나지 않은데
그 사람들이 문서를 다 읽을 거라고
생각을 한다는 것 자체가 웃기잖아요
실수를 만들 여지를 남기는 게 웃기고
그럼 차라리 처음 두 constructor는
베이직 어셈블리에 넣어 놓고 그니까 라이브러리에
나머지 두 개는 정말 파워 유저를 위한
라이브러리를 따로 제공해도 되거든요
그럼 그게 오히려 맞는 방법이지
왜 그렇게 실수할 여지를 남겨 놓았는지가
더 이해가 안 돼요
그래서
요번에 보고 느낀 게
아 정말 언어라는 게 한 명이 만드는 게
아니라서 그런지는 몰라도
이리저리 하다 보면은 정말
실수가 생길 수 있는 부분이 많고
그 실수가 public으로 나오다 보면은
그걸 쓰던 사람이 있으니까 쉽게 바꿀 수도 없구나
근데 지금 XML Serializer 제가 본 거로는
이 정도는 breaking change를 만들더라도
다음 버전 나올 때 차라리 함수를
없애 버리는 게 나은 것 같아요 그 constructor 자체를
아니면은 그 constructor 내부에서
자체를 또 cache가 되게 해주든가
솔직히 cache 못 할 이유도 없거든요
그리고 정말 파워 유저를 위한
cache가 없는 그런 버전을 만들 거면은
그걸 따로 라이브러리로 주든가
그게 맞는 것 같은데
요번에 좀
저도 보고 많이 느꼈어요
저도 이제 처음에 그거를 성능을 잡다가
하도 느려 갖고 왜 이런가 했는데
뭐 이리저리 뭐 Stack Overflow나 이런 거 읽어 보면은
그거 다 cache 된다고
그래서
그래도 느린 거면 다른 문제가 있을 거
라는 식으로만 얘기를 했지
정말 그 매개변수가 이렇게 몇 개가 들어갔을 때
그거로 인해 아예 cache behavior가 없어지고
memory leak까지 난다는 게
MSDN을 깊게 뒤져야만 나오더라고요
요즘 사람들 솔직히 Stack Overflow 맨날 보지
MSDN 읽는 사람은 또 별로 없잖아요
그래서 참 안타까운 일이다 생각을 했고
XML Serializer 쓰시는 분들 중에 혹시라도 아까 처음에
말했던 그 constructor 두 개 쓰시지 않는 분들은
반드시 자체 cache를 만들도록 하세요
코드 찾아 갖고
그 정도면은
뭐 이거는 C#을 까는 거보다는 그냥
C#에서 문제가 생길 수 있는 부분에 대한
유용한 정보, 팁이었네요
예
그 정도면 됐죠 뭐
예 포프였습니다
