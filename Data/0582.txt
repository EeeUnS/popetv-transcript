얼마 전에 본 개발자 트위터에 이런 게 있었습니다. '프로그래머는 한 10년 정도 경력이 쌓여야지만 멀티스레딩을 잘할 수 있다.' 일단 10년 정도가 돼야지 멀티스레딩을 되게 잘한다는 얘기는 동의하고요, 일반적인 사람들이 그 정도 걸릴 거라고 저는 생각을 해요. 더 잘하면 그것보다 조금 더 빠르게 한 5~6년 차쯤에도 할 수는 있어요. 하지만 일반적으로 한 10년 정도가 맞는 얘기입니다. 그렇기 때문에 제가 POCU 아카데미 강의 만들 때도 멀티스레딩은 개념만 대충 설명하고 오히려 너무 깊게는 안 들어가요. 왜냐하면 이거는 실무에서 깨달아야 하는 거라고 생각을 해요. 기본 원리나 원칙은 학교에서 가르쳐야 하고, 그걸 잘 이해는 못하지만 대충 어렴풋이 알고 있다가 실제 멀티스레딩을 본격적으로 다루게 될 때, 학교에서 배웠던 지식과 서로 동기화가 되면서 실력이 확 늘어요.

그래서 멀티스레딩 관련 공부는 해놓기는 해 놔야 하는데, 해놓으면 일반적으로 10년 뒤에 큰 도움을 받을 수 있는 지식이기 때문에 요즘처럼 급박하게 돌아가고 참을성이 없는 세대들, 그 세대들은 이거를 무시하기 쉽죠. '왜 그러냐?'를 생각을 해보시면 되게 단순해요. 사람은 기본적으로 멀티 스레딩을 못해요. 자기가 멀티스레딩을 잘한다고 말씀하시는 분들은 일반적으로 자기 자신을 모르는 사람들입니다. 그냥 본인도 모르고 남도 모르는 그런 이상한 사람들이기 때문에 오히려 '제가 멀티 스레딩을 못해요'라고 말하는 사람보다 더 위험한 사람일 수 있어요. 사람은 기본적으로 직선으로 생각하는 거에 굉장히 익숙하고, 살아오면서 그렇게 훈련을 받아왔고, 두뇌 자체가 그렇지 않나 생각해요. 저희가 세상에 따라 하는 많은 프로세스나 가이드를 보면 1 2 3 4 5 6 7로 진행을 하지 1 2 1 2 3 4 5 6 7 8 9 7 6 이런 식으로 진행하지 않거든요? 이거 끝나면 다음 거 하고, 다음 거 끝나면 그다음 거 가고... 한마디로 한 번에 하나만 집중하는 데 굉장히 익숙하고 그걸 잘합니다. 근데 멀티스레딩을 하는 순간 직선으로 가다가 변수를 읽고 바꾸려는데 갑자기 중간에 다른 스레드가 들어와서 바꿔버리고... Race Condition이죠? 그걸 막겠다고 Lock을 걸면 다른 스레드가 기다려야 되는데, Lock이 걸리는 순간에 진입하면 서로 기다리면서 Dead Lock이 생길 수도 있고 여러 가지 문제가 생기는 거예요. 즉, 여태까지 있던 일직선인 코딩, 거기서 여러 가지 갈래가 생기면서 여러 스레드가 동시에 실행될 수 있기 때문에 스레드 간에 공유하는 메모리라던가 변수가 있으면 갑자기 망가지기 시작하는 겁니다. 그걸 다 신경을 쓰다 보면 갑자기 신경 써야 할 경우의 수가 너무 많아져서 코드를 제대로 작성 못 하는 거예요. 그리고 그 외에 멀티스레딩을 하면 당연히 Context Switch에 따른 오버헤드도 있기 때문에 Lock을 잘못 걸면 오히려 더 느려질 수도 있는 건데, 이런 고민에 이상한 생각까지 막 하게 되는 거죠.

그래서 요즘 멀티스레딩 방식은 이것보다는 훨씬 간단한, 사람의 직선적인 사고방식에 맞는 방향으로 패러다임이 점점 바뀌어왔고 그렇게 가고 있는데, 이게 역사를 알아야지 이해할 수 있거든요? 그래서 '그럼 왜 10년쯤 되면 멀티스레딩을 잘하냐?' 그러면 그거는 단순하게 코딩을 작성하는데 물이 올랐다는 겁니다. 제가 예전에 한번 Debug Assert 얘기한 적이 있어요. 'Debug Assert를 어디에 넣을지 모르면 너는 주니어다'라고 얘기를 했거든요? 그거랑 같은 개념이에요. 코드를 작성했는데 위에서 아래로 읽는 것만으로도 코드가 쭉 읽혀요. 뭔 얘기인지 알겠어요. 순서대로 어떻게 읽을 수가 있다는 거죠. 그러면 그 사람은 이미 코드를 제대로 작성하는 능력이 됐기 때문에, 그 순간에 다른 걸 던져놔도 직선으로 정렬하면서 두 가지 이상 브랜치가 생기지 않게 주의할 수 있어요. 근데 그게 아니라 내가 코드를 작성하는데 갑자기 여기서 if 체크하고 else 체크하고 if 체크하고 if else else if if else else 체크하면서 보니까 한 30가지의 경우의 수를 따지고 있어요. 그럼 이미 일직선으로 작성해야 하는 코드를 깔끔하게 정리해서 일직선으로는 못 만들었어요. 그럼 이 30개에다가 다른 30개의 경우의 수를 양쪽으로 추가해 버려요. 그러면 보통 이게 30 * 30 해서 900가지 경우의 수가 생기겠죠? 여태까지 30개 버그 터지는 것도 되게 힘들게 허덕거리면서 고치면서 했는데, 여기다 그거를 그냥 곱해버리니까 경우의 수가 더 많아지면서 관리가 안 되는 거예요. 그래서 10년쯤 된 사람들, 코드 제대로 작성해 오신 사람들은 코드 깔끔합니다. 그냥 함수 이름만 봐도 뭔지 알겠고 코드 위에서 아래를 보면 뭐 하는 건지 보여요. 그게 안 되면 중간중간에 적당히, 큰 스텝별로 주석을 한두 개라고 달아놓기라도 해요. 그럼 대충 보면서 구획 별로 문단을 나눈 거죠? 문단별로 이해가 되거든요? 그런 거를 잘하시는 분들은 나중에 멀티스레딩을 가도 거기에 여태까지 하던 경우의 수의 제곱으로 만드는 건데, 지금까지 해오던 것들이 최대한 단순화해서 거의 1, 2 정도로 해놨기 때문에 4가지 경우의 수로 봐도 상관이 없다는 거죠. 근데 일반적인 사람들이 거기까지 가는데 굉장히 많은 훈련이 필요해요. 그 얘기를 하는 겁니다. 그래서 싱글 스레드 마스터가 되면 멀티 스레드 주니어로서 시작할 수 있는 거죠. 근데 그 주니어에서 다시 마스터가 되는 데 오래 걸리지 않고, 내가 싱글 스레드 코드 작성하는데도 들쭉날쭉하고 이상한 경우의 수 만들어서 계속 뽀개고 있는데 거기다가 경우의 수의 제곱을 던지니까 제대로 작성할 리가 없죠.

그래서 간단한 사고방식이 되게 중요 코딩을 많이 하면 할수록 한 번에 소화해야 하는 정보의 양이 적게끔, 성능이 느리지 않게끔 코드를 작성해요. 이게 또 핵심입니다. 그냥 코드를 두 줄마다 함수 나눠서 호출하는 건 되게 쉬워요. 그럼 단순해 보이긴 해요. 근데 성능은 어떻게 잡을 건데요? 그 성능을 잡으려면 함수 하나 아래에서 코드 정리도 굉장히 중요하고, 글쓰기랑도 비슷해요. 논문 많이 해보신 분들은 알아요. 처음에 논문 쓰면은 논문 되게 들쭉하고 뭔지 모르지만, 그거를 두 번, 세 번, 네 번 다듬으면 갑자기 정보가 이해되기 시작합니다. 처음에는 내가 다 그럴듯하게 써놨어요. 근데 내가 그 순간에 집중했던 거에만 맞춰서 써놨기 때문에 읽다 보면 흐름이 안 맞을 수도 있고 이 정보가 갑자기 뭔지 모를 수도 있어요. '아 Context가 여기서 저기서 바뀌었구나! 이런 것 때문에' 그럼 그걸 정리하고 위에서 아래를 쭉 읽으면 무슨 내용인지 알 수 있는, 보고서나 논문이나 리포트 같은 걸 작성하듯이 코드도 작성이 돼야 합니다. 그리고 그게 경력이 많아질수록, 직장 일을 많이 하면 할수록, 회사에 오래 다니면 다닐수록 보고서를 잘 쓰게 되거든요? 그런 거랑 마찬가지예요. 잘 읽히는 코드를 만들어야 하지만 거기까지 가는 데 시간이 걸릴 수밖에 없고, 새로운 패턴 나와서 새로운 거 해야 하면 또 흐트러질 수 있잖아요? 다양한 패턴을 학습해서 결과적으로는 많은 패턴에서 언제나 사용할 수 있는 코드를 쓰는 방식, 글 쓰는 방식이랑 같죠? 이게 내 몸에 익어서 흐트러지지 않았을 때 몇 가지 경우의 수를 제곱을 해서 올려도 멀티스레딩을 할 수가 있는 겁니다.

멀티스레딩 당장 못 한다고 고민하실 필요는 없고요. 지금 당장 책임져야 할 것들은 싱글 스레드에서 깔끔한 코드가 나오게 마스터하고 그다음에 멀티스레딩 올리면 됩니다. 깔끔한 코드가 안 나오는데 멀티스레딩 올려봐야 일반적으로 더 큰 문제를 만들고 재떨이 처맞고 회사 그만두는 거고요. 그러지 않기 위해서 올라가는 단계들이 있어요. 3년 차가 멀티 스레딩을 못한다고 그걸 욕하는 회사는 정말 이상한 회사고, 정말 훌륭한 개발자만 있는 회사면 5년, 일반적으로 10년 정도의 기대를 할 겁니다.

포프였습니다.