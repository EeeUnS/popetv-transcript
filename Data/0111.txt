어떤.. 어떤 비디오인지 모르겠는데
전에 어떤 비디오를 만들다가
재가 그런 얘길 했어요
그.. 언어가 같은 거가 언어 디자인을 잘했냐 말았냐
그러니까 뭐 언어라고 말했지만 영어가 아니라
프로그래밍 언어
디자인을 잘했냐 디자인이 어떠냐 설계를 잘했냐 말았냐 하는걸 판단을 할때는
default behavior 굉장히 중요하다고 말씀을 드렸어요.
default behavior 라고 하면은
아 뭐라고 그래야 돼
기본 동작?
기본 작동 방법?
예를 들어서 뭐....
어떤 코드를 짰을때 내부적으로 어떤게 기본이고 그거를
그 기본 default.. behavior로 바꿀려면 그 새로운 함수를 호출해야하고 이런 것들이 있잖아요.
그거를 말하는 건데
일단 재가 생각하는 훌륭한 언어 디자인에
기본적인 거는
프로그래머가 프로그램을 짰을때
그 코드가 실제
어떻게
컴퓨터에서 돌 거냐 라는 건지 대충 판단이 가능해야 한다고
생각을 하거든요
그래서
저 같이 이제 좀
오래 프로그래밍 한 사람들 예전부터
하드웨어 쪽에서 가깝게 프로그래밍 한 사람들은
C를 좋아하는 이유가 그거에요. 사실은 C나 C++를 굉장히 좋아하는 이유가
코드를 딱 봤을때 이 코드가 어떻게 어셈블리(assembly)로 갈지를 알고
어셈블리라는게 기계어 인스트럭션(instruction)이잖아요. 그래서 각 그
기계마다
지원하는 그 가장 낮은
수준의 명령어 거든요.
뭐 그거를 보면서 대충 판단이 되는거죠.
아 이런 하드웨어에서는 이게 어느정도로 빠르게 돌거고 어떤 문제가
있을거고 기타 등등...
그다음에 나온 언어들을 보면 뭐
여러가지 언어가 있지만
여전히 그런 게 깔끔하게 보이게 디자인한 언어가 있고
그런걸 완벽히 뭉클어 트려서 속에 도대체 어떤식으로 
작동할지를 모르게 하는
그런 언어들도 있어요.
제가
그 스크립트(script) 언어를..
쓰긴 쓰는데
스크립트 언어가....
굉장히 마음에 안 드는 것 중의 하나는 단지 스크립트 언어라서 그런건 아니죠 사실은
그 형(type)이 정해져 있지 않은 것이 있잖아요. 
타입
타입이 언제나 바꿀수 있는 그런... ㅂ
그걸 별로 안 좋아해요.
그래서
C# 같은 경우에는 var나 c++에는 auto같은게 나오면서
그런 건 이제 타입을
추론은 가능하지만
바꿀 수 없게 하는 그런걸 strong타입들 이라고 하거든요. 타입을 언제나 정해야 하는
그게 굉장히
뭐 좋아 하는 이유도 그중에 하나죠. 
딱 봤을때 어떤식으로
메모리에서 이게 어떻게 들어가고 코딩이 어떻게 돌건지를
판단이 가능하고
타입이 바뀔 때 과연 얘가 뒤에서 뭘 할지 저는
그게 감이 안오니까
그러면 그 외에 옵티마이제이션(optimization)이 되는 이유도 있구요.
그 원래 말하려고 했던 본론으로 돌아가서
그때 그 얘기를 했을때 그 재가 뭐 swift 예기를 잠깐 했고 막 이런얘기를 했는데
그때 어떤 사람이 답글로 swift좀 막 까달라고 그랬거든요.
(웃음)
그래서 오늘 차라리 얘기를 하는 김에 그거를 할려고 해요.
암.....
재가 볼때 그래서 swift, c#
그리고 다른 언어까지 예기를 할거 같은데
일단은 기본 behavior,
default behavior에 대해서 좀 더 생각을 해볼게요. 뭐든 간에
C나 C++를 보면은
뭐
뭐 상당히
버그가 많았다고 하기는 어려운데
그....
알아야 되는 규칙이 굉장히 많았어요. 어떻게 보면은 예를 들어서
뭐...
한국말로 승격이라고 하나? 그.. 만약에
숫자를 unsigned char 숫자를
넣어가지고 계산을 해가지고
이걸 int에 넣으면은
이게 integer로 자동으로 되는지 뭐 앞에 무슨 브래킷
넣어 가지곤 그걸 int라고 해야지만 바뀌는지 int에서
char갈땐 어떤지 이런 여러가지 룰이 있잖아요.
어찌보면의 비트 수 높은걸로 
올라간다 뭐 이런건 좋은 예긴대
뭐 뭐 이해도 되고
가끔 애매한 경우도 있구요. 사실은 그럼 이제
그런데서 버그가 생기는 것도 가끔은 있어요.
이제 뭐 unsigned int나 int간에 어떻게 왔다 갔다 하는지 이런것부터시작해서
C나 C++에서 상당히
하...
그 뭐라 그래야 하나
잠재적인 그런 규칙이 많아요
그러니깐 딱 봤을때
확실하게 이렇게 작동한다는 게
아니라
이게 내부적으로는 스펙엔 있어요.
근데 그냥 코드만 보고 나서 아니면 상식적으로 생각해서
그게 그렇게 작동을 한다고 판단하기가 어려운 부분이 있죠.
그래서 C나 C++가 굉장히
어려운 언어 중의 하나 이기는 해요. 그런 의미에서
그거를 굉장히 많이 고쳤던 언어 중에 하나가, 이제 뭐
뭐 중간에 다른 언어가 있었지만
그 델파이도 좀 그런 비슷한 이유중 하나였다고 생각을 하는데
그 델파이 개발자가 가서 만든게 C#이잖아요.
C#을 보면은
C#초기 한..
1이나
2.0?
한 3.0까지 때만 해도
굉장히
깔끔했어요.
코드를 보면은
딱 감이 와
아 이게 C하고 비슷할수도 있지만 대충 어떻게 어떻게 돌겠구나 감이 오면서도
결과적으로 C에서 조금 위험하다고 여겨졌던
포인트라든가 이런 것들을 많이 뺐고
물론 지원은 가능하지만
기본적으로 빠져 있죠
뭐 그 이후에 포인트가 없어진 대신
자바처럼 모든게 reference타입으로 전달이 되는데
reference타입이 아니라 value타입으로 되는거는
이제 기본형들 하고 struct 그래서 뭐 integer라든가
뭐.. short 이런 거 있잖아요. 
그런거 다 기본형들은 다 기본적으로
값으로 copy를 하죠 레퍼런스 copy라는 거는 레퍼런스가 결과적으로 포인터랑 같은 의미에요.
근데 포인터에
직접 접근하지 못하는것 뿐이죠.
근데 이제
그럼 레퍼런스하고 벨류하고 차이가
생기다보니까
한가지 default behavior를
처음으로 도입을 해야만 했어요.
그게 뭐였냐면은
struct 그러니깐 물롱ㄹ C#... c에서 생각 할때 class하고 struct하고 별 차이가 없잖아요. 근데
C#에서는 struct는 언제나 value 타입이에요.
그래서 struct로 들어가는거는
struct를 그냥 함수에 전달할때는 값을 전부다 복사를 해요.
C에서 예기를 하면 그냥 Object를 집어 넣는거하고 똑같죠.
그리고 C에서는 class라는게 있잖아요.
그걸 이제
C#에서는 개념이 똑같 아요. class는
근데 이제 class에 있는 그 오브젝트를 그냥 함수로 전달할때는 이거는
암시적이라고 해야겠죠.
implicit하게 알아서 포인터로 엮어 레퍼런스하게 전달을 하죠.
그래서 거기서 한가지 한가지 룰이 생겨난거에요.
아.....
모든 오브젝트 클래스로 만든 오브젝트는 레퍼런스 타입으로 들어간다.
그리고 모든 struct는 밸류 타입으로 들어간다.
사실 C#을 전혀 몰랐던 사람들이라면
C++만 한  사람들이라면 이게..
코드만 보고는 나올수는 알수는 없는 규칙이죠. 사실은
근데 결과적으론 나중엔 알게 되고
그래서 요 한가지 규칙이 생겼어요. 그렇게 외우기 힘든 규칙은 아니죠.
그러고 뭐 이 struct하고 class사이를 왔다 갔다 할때가 있잖아요.
예를 들어서 뭐 모..
integer도 class형의 integer가 있어요.
C#에서는
마찬가지 얘기로 container에 들어갈 때도 오브젝트로만 바꿔야 되는 경우도 있고
뭐 요즘은 안 쓰지만 잘
그래서
그런 게 생기면서
이제 거기서 나오는 퍼포먼스 이슈의 문제도 생기기 시작했어요
근데 그거는 말 그대로 규칙이 명확하니까 이해하기가 쉬웠죠
다 좋았는데
쩝..
이제
제 생각에는 C#을 원래 만드시는 분이 아마 그 팀을 더 이상 리드하지 않는 게 아닌가 싶은 생각도 들고
버전이 조금 더 높아가면서
새로운 것들을 막 추가하기 시작을 했거든요
그 가장
뭐 링크도 그때 추가된 거고
뭐 에이싱크(async)라는 것도 그때 추가된 거고
뭐 패러럴 태스크(Parallel Task) 이런 것도 추가된 거고
개인적으로 페러럴 팀은 굉장히 뛰어난 일을 했다고 생각해요
그거는 제가 굉장히 좋아하고 굉장히 깔끔하게 나왔다고 생각하고
뭐 잡 시스템 만져 보신 분들이라면 패러럴 태스크 시스템 써 보면
아 이거 정말 제대로 만들었고
뭐 실수..
뭐 할 순 있죠
근데 굉장히 잘 만들었다는 생각이 딱 들어요 보면서
쩝..
문제는
제가 최근에 발견한 것 중의 하나에요
웹 프로그래밍 하다 보니까
에이싱크나 뭐 이런 걸 쓸 일이 있어서
아직도 개념이 뭐 100% 확실하진 않지만
에이싱크가 굉장히 문제가 많더라고요
에이싱크 작업을 하면서 보통 뭐 그런 거 있잖아요
태스크 해 갖고 이제 웨이트할 때 어웨이트 하는 거 C#에서 아시는 분들 아시겠지만
그 어웨이트 할 때
특히 웹.
웹기반에서가 문제인 것 같아요
이제 그 어떤 잡을 해 놓고 어웨이트할 때 이게 태스크가 쫙 나갔다가 끝나고 돌아올 때 있잖아요
그러면 이게 기본 동작이 되게 웃겨요
기본 동작이 이 잡을 시작을 했던 컨텍스트 뭐 이런 게 있잖아요
그러면 이 에이싱크 잡을 실행을 하면서
이게 끝났을 때 원래 컨텍스트로 돌아오려고 하는 게 기본 동작이에요
그니까 한마디로 뭐
컨텍스트(Context)라고 생각하면 그냥 스레드(Thread) 번호가 내가 1번에서 이거를 실행했다면
끝나고 나서 1번으로 돌아올려고 하는 그런
작동을
그거를 기본 작동으로 해요
근데 그럴 필요가 없는 경우가 거의 대부분이거든요
저는 왜 그럴 필요가 있는지도 잘 몰랐는데
열심히 뒤지다 보니까
UI 쪽에선 그래야만 한대요
저도 뭐 더 깊이 파진 않았어요
제가 UI를 할 일이 없어서
그래서
C#에서 UI에서 그런 에이싱크를 막 할 때
필요하잖아요 아무래도 UI를 막으면 안 되니까
그러면 그때 원래 컨텍스트로 돌아와야만 원래 UI를 업데이트하고 이런 게 있나 봐요
뭐 WPF의 얘기일 수도 있고 실버라이트 얘기일 수도 있는데
제가 정확히 어디의 UI인지는 모르겠어요
그거를 위해 기본 동작을 원래 컨텍스트로 돌아오게 만들었다는데
문제는
이거를 ASP.NET 웹 환경에서 돌리다 보면은
데드락이 일어날 때가 있어요
예를 들어서 얘는 에이싱크 시작되고 떠났는데
돌아오는 순간에 이제 원래 컨텍스트로 돌아올려고 하죠
근데 다른 리퀘스트 콜이 있어 갖고 웹 서버 쪽에
그 원래 있던 컨텍스트를 딴 놈이 가져 가
딴 놈이 가져 가서 뭔가 또 실행을 하다가 얘도 누군가를 기다리면서 데드락이 걸리는 거에요
그래서 저는 데드락을
테스트할 때는 안 나오다가
프로덕션
그....
서버에 올렸을 때 그걸 발견을 했거든요
제가 짠 코드가 아니었고 원래 있던 코드였는데
프로덕션에 올렸을 때 이렇게 막 스레드 수 많아지고
뭐 거의
태스크 풀이 있잖아요 ASP.NET 쪽에는
그게 많아지면서 그게 막 데드락이 걸리기 시작하는 거에요
그래서 뒤지고 뒤진 끝에 찾았어요 문제가 뭔지
해결하는 방법은 솔직히 간단해요
그 다음에 함수를 호출할 때 그 에이싱크 잡을 호출할 때 그 뒤에다 닷 하나 찍고
컨피규어
컨피규어 어웨이트(ConfigureAwait) 어쩌구라는 함수가 있어요
그거를 false로 해 주면
원래 그.. 뭐
테스크 아이디? 아니 그니깐 뭐야
컨텍스트로 돌아갈려고 하지 않는다 그러더라고요
그래서 그건 그냥 리턴할 때 그냥 아무 컨텍스트나 또 잡아 갖고 계속 실행한다고
그래서 그게 해결 방법은 간단한데
문제는
코딩을 짜는 사람 입장에서
왜 그거를 언제나 넣어야 되는지가 말이 안 된다는 거죠
기본적으로 코딩을 짜는 사람에선
기본
기본 동작이 아무거나 잡아 갖고 데드락이 없는 상황으로 가게 하고
정말 자기가 뭔가 위험한 일을 할 때
데드락(Deadlock)도 발생할 수 있지만
아니면 특히 뭐 UI 쪽에 특별한 그 스페셜한 목적으로 그걸 해야 될 때?
그때는 이제 ConfigureAwait를 자기가 직접 짜야죠
그니까 ConfigureAwait가 없으면
데드락 없이 그냥 아무 컨텍스트 잡아서 갈 수 있는 그런.. 개념으로 가고
정말 원래 컨텍스트로 돌아가야만 하는 특별한 경우라면
그때 새로운 함수를 뒤에다 붙여야만 된다고 생각을 하거든요
그래서 디자인을 잘못한 거에요
그리고 그것 때문에 실제 저희 프로덕션에서 오류도 있었고
제 생각에는 저희가 아직 모르는 그런 오류가 많을 수도 있어요
데드락 계속 걸리기 시작하면은 보통 웹에서는
어 페이지 안 뜨네 그럼 F5 한 번 더 누르잖아요
그럼 새로운 리퀘스트 가서
새로운 거 운 좋게 데드락 안 걸리면
그 결과 받아 오고
그러다 보면 웹 서버에서 계속 데드락 걸리는 태스크가 있을 거고
어느 순간 웹 서버가 너무 느려진다
그래 다시 부팅하자
이 개념으로 가는 경우도 있을 것 같아요
한마디로 모르는 거죠
그래서 굉장히 위험한 default behavior라고 생각을 하고
그게 기본으로 들어가 있다는 게 굉장히 저는 불만스러워요 일단은
그거.. 그건 하나고
두 번째 또
(웃음)
C#에서 요즘 마음에 안 들던 거는
그 iterator 같은 거 있잖아요 C#에
아 예를 들어서 뭐
링크해서 해 갖고 뭐
링크해서 해 갖고 셀렉트 해 갖고 뭐 이렇게 잡아 갖고 새로운 링크 뭐 스트럭쳐 만드는 거 컨테이너 만드는 거
이게 C#에서
이제 레이지(lazy) 로딩이라는 걸 시작을 한 건데
그니까 한마디로
링크 안에 뭐
한 세 가지 셀렉트 잡을 넣어 갖고
배열 세 개를 만들려고 한다고 생각해 봐요
그러면 실제 이...
그....
데이터를 쓰기 전까지
이 실행문이 실행이 안 되는 거에요
그래서
(웃음)
뭐 레이지 로딩 개념은 언제나 있어 왔지만
그게 과연 default여야 할까라는 생각이 들기 시작을 하는 거죠
기본적으로 이게 사실은 코딩을 짰을 때 레이지 로딩이 아니라는 거를..
레이지 로딩이 아니라고 가정을 하고 코딩을 짜는 게 전 올바르다고 생각을 하거든요
근데 이거를 레이지 로딩을 default로 했기 때문에
사람들은 코딩을 짜고 레이지 로딩으로 나중에 되는 거죠
물론 sql이나 이런 걸 생각할 때는 뭐
당연히 그게 나은 걸 수도 있는데
쓰읍...
과연 코딩을 짜는 사람이 이게 짜면서
아 이건 레이지 로딩이구나라고 생각을 할까?
기본적으로 다들 이거는 곧바로, 
곧바로 로딩하는 이거(eager) 로딩이라고 하죠.
이그얼...
그니까 이제
뭐라 그래
열정적으로 곧바로 로딩한다고
그때 그때 실행하는 거
그게 저는 일반적인 프로그래머가 생각하는 거라고 생각을 해요
근데 레이지 로딩을 그걸 기본으로 기초로 해 놓다 보니까
하아...
또 거기서 몇 가지 버그가 이리저리 발생을 하더라고요
그니까 사람들은 당연히 이게
이거 로딩이라고 생각하고 썼는데
나중에 보니까 이게 레이지 로딩인 거야
그래서 뭐 그거를 고치는 법은 있긴 한데
일단 뭐 그거는
레이지 로딩이 필요하면 그냥
그걸 넣으면서 거기다 레이지라고 써야 되는 게 아닐까
아까 데셀렉트(Deselect) 레이지 뭐 이런 식으로
그럼 이거는 레이지라는 거 딱 보이게
그러면은 그게 훨씬 좀 깔끔한 코드라고 생각하거든요
그 기본 behavior가 전 그거 잘못됐다고 생각을 해요
근데 뭐 아까 말한 그 컨피규어어웨이트처럼 아주 잘못된 건 아니고 그냥 제 선호 사항에서 잘못됐다고 생각을 하고
여기서 오는 또 하나 버그를 발견한 게 되게 웃겼던 게 뭐냐면
링크를 딱 해 갖고 그럼 뭐 셀렉트문을
그니까 뭐 링크 안에서 셀렉트 해서 언제나 다른 함수를 호출하는 거를 셀렉트를 했다고 생각을 해 봐요
그러면 이 링크를 잡아다가
그 컨테이너를 포이치(foreach)로 돌리면서
넥스트 멤버를 잡다 보면은 잡을 때마다 그 함수를 호출해 주는 거에요. 얘가
함수를 호출할 때 그 함수가 예를 들어서 뭐 숫자를 1씩 증가시켜서 반환을 하는 거다
그런 함수라면 되게 재밌는 게 발생을 하더라고요
링크 스테이트먼트(statement)에
셀렉트를 두 번을 해 갖고 넣는 거에요
그러면 숫자가 0하고 1이 나오겠죠 결과적으로는
그리고 밑에서
그 링크 스테이트를 돌면서 포....이치
그.. 뭐.
뭐
배.. 배 바리어블(variable) 잡아 주고 그 안에
그러니까
각 링크 안에 셀렉트가 두 개 들어갔으니까
두 개만큼 돌리면서
그 값을 잡아 갖고
프린팅을 한다 그러면 화면에
zero하고 one이 0하고 1이 출력이 돼요
그 다음에 또 여기서 재밌는 게 이거에요
그 링크 스테이트 아까 있잖아요
그 위에 링크 오브젝트
그거를 딱 잡고
프린트를 한 번 더 하면서
닷 퍼스트를 하면은
이게 그 다음 번호가 나와요
0 1 2 이렇게
그...게
뭐 왜 그러냐면 레이지 로딩이기 때문에 그렇죠
그 안에 들어 있는 셀렉트문은 있고
그 셀렉트문은 그냥 다른 함수를 호출하는 거기 때문에
그거를 한 번 한 번 호출할 때마다 그렇게 되는 거에요
근데 처음 링크를 캡쳐했을 때는
우리가 두 개를 잡는다고 이미 해 놨으니까
두 개인 거까진 알고 그거를 포이치로 돌릴 수는 있어요
근데 그게 나온 경우에
이미 이 두 개를 호출했기 때문에
아.. 뭐
그 함수가 숫자를 하나씩 증가해서 반환하는 거잖아요
그 함수는 이미 1까지 반환을 한 거에요
그러면 여기여기 호출하고
다음 포인트가 여기로 와 있는 건데
아직 아무것도 없는 거
여기서
이 상황에서
아 그래 이거 두 개 돌려 가면서 0하고 1을 보여 줬으니까
그럼 이번에는 처음 거를 다시 보고 싶다라는 개념으로 하면은
어 함수가 퍼스트가 있네
그러면 링크 닷 퍼스트 하면은
그 어레이 생각하고
이게 처음의 거라고 생각하잖아요
근데 레이지 로딩이기 때문에 그 퍼스트가 사실은 넥스트에요
아니면 현재 포인터 가리키고 있는 데가 퍼스트거나
그래서 퍼스트를 하면은 이게 호출이 되면서
아직 그 안에 들어가 있는 값이 없으니까
새로 함수를 호출해서 2가 나오더라고요
그래서 저는 그 퍼스트라는 이름 자체도 굉장히 지금 불만이 많아요 사실은
뭐 다른 iterator 쓰다 보면은
자바가 그랬던 것 같은데
넥스트 쓰잖아요 언제나
저는
자바가 넥스트인가?
C가 넥스트인가?
퍼스트가 아니라 언제나 넥스트라고 하거든요
겟넥스트라든가 무브넥스트라든가
그러면 개념이 딱 오잖아요
아 넥스트니까 이거는 그 다음 거겠구나라는
코드에서 확실히 볼 수가 있는데
이거는 퍼스트다 보니까
진짜 꼼꼼하게 생각하지 않으면
이게 퍼스트인지
이게 다음 거인지 퍼스트인지 헷갈릴 수가 있더라고요
실제 제가 그 버그를 코드에서 봤고
다른 사람이 짠 거를
뭐 이거를 해결하는 방법은
처음에 링크 스테이트먼트 넣고
그 두 개의 셀렉트로 한 다음에
닷 투 어레이 하면은 해결은 돼요
그러면 그때부터 어레이니까
첫 번째 거 두 번째 거 보여 주고
다시 첫 번째 거 보여 주면
어레이에서 첫 번째거든요
그럼 또 하나의 문제가
이게 옛날에 STL같은 경우에서 가끔 나왔던 문제인것 같긴은 한데
STL개념 자체가 STL 컨테이너요.
개념 자체가 그거였잖아요.
그 인터페이스는 똑같고...
행동도 똑같아야 된다고 했나 달라야 됬나?
행동도.. 아 그거까진 제가 모르겠네요. 제가 그쪽으로 하두 짧아서 그쪽이..
근데 제 개념은 그거 였던거 같았거든요.
그러니깐 예를 들어서 어떤 형인지 어레이인지 뭐 리스트인지 상관없이
그냥 퍼스트부터 끝까지 밈대로 이터레이터 하면서 볼수 있다.
퍼스트하면 언제나 퍼스트로 갈수 있는 그점 그개념이라고 생각했거든요.
이거는 순식간에
그...
캡쳐 하는게
링크.......
그 이뉴머러블(enumerable)타입인지 아니면 어레이 타입인지
이냐에 따라서 퍼스트의 behavior가 바뀌는 거라고 생각을 해요. 곧바로
굉장히 혼란스럽고 또 C#같은 경우에서는
변수를 auto변수가 있잖아요.
var라고 해서 그냥 어떤 함수를 호출해서 이 함수가 이뉴머레이터(enumerator)를 반환을 했을때
그냥 여긴 var해가지곤 k 해 놓으면
이 형이 뭔지는 코드상에선 안보이지만
얘가 추론을 해서 아 그래 이게 이뉴머레이터구나 하고 쓰잖아요.
그렇게 되기 시작하면은 이게 만약에 그게 함수가 바뀌어서
이뉴머레이터를 반환을 안하고 어레이를 반환을 하기 시작하면은
그 코드 자체도 바뀐 코.. 코드 자체의 행동도 바뀌게 된다는 얘기거든요.
그래서 차라리 둘간의 인터페이스를 공유하지 않는게
훨씬 버그를 막을수 있는 길인데
왜그랬을까?
저도 그것도 굉장히 맘에 안드는 부분이기도 했어요.
레이지 로딩이 처음부터 아니고 이거(Eager) 로딩이였으면 이런 문제가 조금 적었을 거고
레이지 로딩이 필요하면 따로 레이지 로딩이라고 하면 되는거고
아니면 그...
아까 말했던 그 링크 이뉴머러블
그...
인터페이스에
퍼스트라는 이름 자체가 잘못된게 아니냐
차라리 넥스트 라든가 커런트(Current) 라든가
이런 이런 이름이 훨씬 나은거죠.
그래서 그것두 좀 그렇고
그 외에도 에이싱크 해볼려고 그러면 앞에 에이싱크 붙이고 어웨이트 붙이고 뭐 코드가 굉장히 드러워 졌거든요.
그래서 아 이게 어느순간부터 갑자기 C#이 망가지는게 보이는 거에요.
아 이게 원래
설계자가 없는게 아닌가 생각이 들고 들 정도고
C#얘기는 거기까지
그다음에 할얘기는 swift에요.
swift를 처음 나왔을때 스펙 다 읽어 보면서 검토를 해봤어요.
일단 Objective-C보다 훨씬 좋아요.
뭐 그것보다 안좋을수가 없죠.
Objective-C자체가 워낙에 개판이 었. 랭귀지였으니깐 언어 자체로는
일단 뭐 제가 swift같은거 좋아하는 아니 뭐 Objective-C나 swift를 다른것보다 좋아했던 이유들 중에 하나는
그 레프 카운팅(Reference Counting) 때문이구요.
전에 왜 레프 카운팅이 왜 가비지 컬렉팅(Garbage Collecting)보다 낫냐 라는 얘기를 몇번이나 해왔고
그거는 좋고 굉장히 여러가지 신경을 많이 썼어요.
뭐 예를 들어서
아 뭐..
성능 향상을 위해서는 아무래도
변수 보다는 상수가 중요하거든요.
컨스트(const) 변수라고 하죠 뭐
그런것도 신경을 많이 썼고 많은 신경 쓰면서 아 굉장히 많은 노력을 했구나 뭐 익슨텐션(extension)부터 시작해서
그래 성능상으로 아 그러니깐 자동적으로 옵티마이제이션(optimization)하기가 훨씬 좋은 언어에요.
그러면서 사용자가 사용하기에는 그렇게 힘들지 않은 언어고
한가지 단점은
얘내가 정말 말도 안돼는 default behavior를 새로 만든게 문제였어요.
개념이 이해가 안돼는 거야.
점점 얘내 왜 이짓을 했을까.
제가 한가지 딱 한가지가 마음에 안들어요 솔직히 지금 생각으론
뭐냐면
그... 어레이하고 딕셔너리라고 그러나 얘내 맵이라고 그러나
해쉬테이블이라고 그러나 뭐 어찌 되었든 C#용어로 어레이하고
아...
쩝
뭐라고 그래
딕셔너리라고 할게요.
어레이가 있으면 C#에선 어레이가 오브젝트에요.
그래서 어레이를 다른 함수에 그러니깐 어레이를 딕셔너리를 똑같이 오브젝트이기 때문에
이거를 다른 함수에 인자로 전달을 해주면은 이게 레퍼런스 단위로 들어가요.
복사가 안 일어나는 거죠.
그래서 그냥 그거를 가져다가 쓰면은 되는거고 복사하는데 시간 낭비하는 것도 없고
그러고 그 값을 바꾸면 원본이 바뀌는 단점은 있어요.
근데
그거를 이미
당연하다고 써 온 사람들이 많고 그리고 저는 그게 일반적인 지금 프로그래밍 페러다임이라고 보거든요.
그렇지 않으면 원래 어레이에
어떤 값을 추가 할려고 할때 이거를 함수로 전달 안하면 어떻게 하겠다는거야.
그쵸 원래 어레이 그니깐 원래 어레이 어레이가 아니라 이거는 뭐
C#용어로는 리스트라고 해야될거고
C++용어로는 백터라고 해야겠죠.
STL백터
거기에 원래 새로운 값들을 추가해서 그냥 그 원본에 계속 추가하고 싶은데
그 백터를 계속 전달해주고 싶은 경우가 있잖아요. 매개변수로
그러면 그냥 레퍼런스로 가기 때문에 편하잖아요.
한마디로 뭐 C에선 포인터로 전달 한다거나 아니면 이
펭귄마크(&, Ampersand) 써갖고 레퍼런스로 전달하거나 같은예기죠.
그게 기본 behavior였어요. 
왜냐면 C#에서는 분명하게 말하니깐
오브젝트는 무조건 레퍼런스 타입으로 전달되고
스트럭트는 무조건 밸류타입으로 전달되기 때문에
Objective-C도 그랬거든요 재가 알기론
그런데 얘내들이 바꾼거에요.
어레이하고 딕셔너리는 이제부터는 모두다 밸류타입이래요.
그래서 어레이랑 그거를 딴데 대입을 하거나
패스를 하면은 밸류타입이 되면서 새로운 카피가 만들어 지는거에요.
혼란스럽죠. 흠.. 
이게 뭐야 근데 더 혼란스럽게 만들었어요.
딕셔너리는 무조건 밸류타입으로해서 카피가 되는데 어레이는 아니래요.
어레이는
패스가 되면 밸류타입이긴 한데 복사가 이루어나지 않다가
어레이 타입에 그.. 컨테이너 사이즈가 바뀌거나 
그안에 값이 바뀌면 그때 복사를 한대요.
들으면서
이게 무슨 개소리야
이유는 알아요. 이유는 뭐 아까 말했듯이 복사 막고 성능을 빠르게 좋은데
다 좋은데 
문제는
이
그
코드를 봤을때 보이지 않는 그 온갓 자잘한 규칙을 사람들이 왜
사람들이 외워야 하는지 모르겠고
그리고 Objective-C에서 이거를 만든이유가
삼..  아무래도 아이폰쪽 개발하는 사람들중에 캐주얼한 사람들이 많다보니까
C나 C++처럼 투철하게 프로그래밍하는 사람도 적고
좀 대충하는 사람들이 많기 때문에 실수를 할수 있다는 것 때문에
이거를 실수가 적은 랭귀지를 만들려고 그짓을 한거거든요.
근데
그 사람들이 그 규칙을 왜울리가 없어
(웃음)
절대 안 왜워요 .
규칙은 말그대로 한가지 두가지 뚜렷한 규칙이 있고 이유가 있고 언제나
컨시스턴트(consistent)하게 되어야 한데 그게 아니라
어레이를 하면은 이게 그래 내가 사이즈를 바꾸거나 내용을 바꾸면 그때 복사가 이루어 나고 그렇잖으며....ㅁㅇㅁ
보면서
이 언어 저것 때문에 욕 디게 먹겠다. 
그런 생각이 딱 들었어요
그래서
굉장히 잘못 설계한 부분이고
언어자체는 그나마 뛰어나요.
그 부분이 굉장히 잘못 됐어요.
올바른 방법은  C#부분이 옳아요.
사실은
왜냐면 C#에서 말그대로 
제가 딕셔너리가 있어요.
이거의 사본을 만들고 싶으면 그냥 닷 투 딕셔너리 이런식으로 하면 되요.
그러면 사본을 만들어줘요.
아니면 그냥 함수를 따로 만드시거나
카피라는 함수를 만들어 주던가.
기본적으로는 원래 규칙상
모든거는 오 오브젝트는 레퍼런스 타입이니깐 레퍼런스 타입으로 전달이 되지만
정말 니가 사본이 필요로 하면 함수 호출해서
닷 카피라던가 
닷 투 어레이라던가
이렇게 사본을 받으면 되는거거든요.
그러면 얼마나 깔끔해 
내가 복사하고 싶으면 복사하고 아니면 말고
이거를 왜 그따위로 하는지 이해가 안되더라구요. 
그래서
재가 swift를 깔건 그것 뿐이고 사실은
그게 굉장히 마음에 안들었어요.
언어 얘기가 나왔으니깐 말인데
요즘 진짜 재대로 언어를...
새로운 언어가 몇개씩 나오거든요.
정말 재대로 디자인한 언어는 
재가 최근에 본것중에는
모질라에서 만들고 있는 러스트(rust) 하나뿐인것 같아요.
뭐
걔네 개념은 이제 웹에서 도는 컴파일 되는 언어거든요.
웹에서 이제 스크립트 언어가 워낙 느리다 보니까
PHP 버추얼 머신 만들고 PHP로 컴파일하는 이런 개소리도 하고
근데 걔네들은 아얘 컴파일 되는 언어를 만들겠다는 거에요.
그래서 엄청 빠르게 돌수 있는
재밌는거는 그런 비슷한 언어가 또하나 있죠.
아.. 구글에 고랭(go lang)이라고
개내들 비슷한 개념으로 시작해서 만들었죠?
무슨 뭐
최근에 안거지만 예전에 뭐 C++나  뭐 이런 그쪽을 디자인 했던 뭔가
뛰어난 아저씨들이 할아버지들이 모여서 만든 거다 뭐 이런식으로 얘기를 하는데
그래서 저도 한번 봤죠.
고랭을 많이 쓴다고 그래서
구글에서
딱 봤는데
보고 튜토리얼 좀 보고
좀 코드 좀 몇번 짜보고 그냥 던졌어요.
뭐
짜잘하게 뭐 뭐 굉장히 리스트 리스트 액션(무슨 말인지 모르겠다.)둬 갔고
실수를 못하게 하갰다는 의도 자체는 좋은데
신택스(syntax) 딱 보는순간 아 이거는
막  막 70년대 80년대 신택스구나
정말 쓰기 싫은 신택스?
그러고 막 치다보면 손가락이 아픈 신택스
뭐 그러니깐 예를 들어서 쉬프트를 누를일이 많다거나 뭐 이런 이상한 짓들 보면서
쩝.
저건 아니다
저거는 코드 가독성에 문제가 생기는 언어더라구요 저한테는
신택스상의 문제로
저거는 재가 정말 손대기 싫은 신택스고 
저는 죽어도 안만지게 될거가고
제가 안만지면 다른 사람도 안만질거라고 봐요
그래서 고랭은 그냥 제 생각에는
특화된 분야 구글쪽에서 열심히 쓰다가 뭐
 알아서 사장될것 같고 제 생각에는
쩝..
러스트 언어를 보면은
정말 그 스위프트가 할려고 했던거를 얘내가 일단 다 했구요.
그... 뭐..
최적화 가능 할 수 있도록 기본적으로
기본 방식을 되게 잘했어요. 
모든 변수는 기본적으로 모두 상수에요.
일단 대입을 하면은 바꿀수가 없어요.
바꾸고 싶은면 변수를 선언할때
이게 상수가 아니다라고 선언을 해야되요.
상당히 개념적으론 맞는 예기거든요. 어찌 보면은
그러면은 컴파일러가 볼때 어.. 상수인거는 알아서 다 컴파일 하고 최적화 할수 있는거구 변수는 안하고
그런것도 잘되어 있고
이런 그 뮤터블(mutable) 뭐 임뮤터블(immutable) 
그런 예긴데 결과적으론
이렇게 값이 변하지 않는거면 멀티스레딩을 뽑을때도 훨씬 안전하잖아요.
값이 변하지 않는게 분명하고 변할 변할려면은
이제 컴파일러가 에러를 주니까
이건 변하지 않는 값이니깐 멀티스레딩를 뽑아도 뭐.. 레이스 컨디션(Race Condition)같은거 날 경우도 없고
뭐 문법도 되게 깔끔하고 굉장히 모던한 문법도 많이 따라 갔구요. 사실 뭐
약간 C하고 C#하고 비슷한 경ㅇ 보이기도 하고 뭐
옛날에 이상한 그런 언어하곤 전혀 다르고
아직도 열심히 개발중인 거고
아직도 초기이긴 한데
일단 스펙 읽어보고 코드 읽어볼때는
보면서 이해가 되요 정말 깔끔하구나 그리고 최근 언어들이 지원하기 시작한 온갖 그런 것들 다 지원하고
재가 볼때는 가장 생각을 열심히 잘했고
가장
기본 behavior를 확실하게 만들고 있는 언어 같긴 해요.
보면서 아.. 저 언어가 빨리 좀 나와서
어떻게 메인 스트림이 되면 참 좋겠다고 생각하는데
최근에 삼성이 그거를 돕기 시작했다나 그래 가지고 안믿으시는 분들이 조금 있더라구요 삼성이랑 모질라가 함께 하면 조금 이상하다고
그거까지는 모르겠고
오늘 하려고 했던 얘기는 그거에요 언어가 좋고 나쁘고는 말그대로 기본 동작이 뭐냐가 되게 중요 한것 같아요.
뭐 제가 예전에
그..
마이크로소프트 포럼에서 가끔 답 달아줄때 어떤 학생들은
왜 숫자가 1이 아니라 0부터 시작하냐 어레이같은거 접근할때
너무 너무 혼란스럽고 복잡하다 이런 얘기를 했는데
뭐 10진수를 주로 써온 사람
그리고 일반적으로 1을 첫번째 숫자로 생각하는 경우가 많잖아요.
사실은 1,2,3,4,5,6,7,8 이런식으로
우리가 0,1,2,3,4 이렇겐 안따지니까
거기서 오는 혼돈은 알겠는데
어레이 접근을 할때는 이제 뭐 특히 C++에서
메모리 포인터 연산하고 그게 또 맞아 떨어지느 그게 있거든요. 그래서
0이면은 내가 시작하는곳 1이면은 지금에서 한 발자국 더 나아간곳 이런 개념으로 들어 가는 거기 때문에 시작이  0부터 하는건데
그런 기본 behavior도 어찌 보면은
보는 사람에 따라
다르게 봐줄수가 있는거죠 
아 이거 정말 불편하다 정말 편하다
근데 만약에 그사람한테 이렇게 되서 이것때문에 우리가
이런 규칙으로 가는거다라는 그런 확실한 규칙을 보여줄수 있다면
저는 그거는 괜찮은 기본이라고 봐요.
오히려 저는 어레이같은 거를 1,2,3,4로 가는 거는 나중에 포인터 연산을 할때 마다 숫자 바꾸고 하는거 따지면은
오히려 버그를 만들 가능성이 높다고 갱각 하기 때문에
기본동작 재대로 박고 확실하게 정립할거 정립하고 확실하게 강요할거 강요하지만
정말 말도안돼는 기본동작은 좀 그만 좀 만들었으면 좋겠어요.
아까 말했던 스위프트 스위프트에서 그..
복사 문제도 그렇고
뭐 C#에서 몇가지 말했던거
C#은 제가 나쁘게 말할 여지가 많던게 최근에 나쁜 면모를 많이 봐서 그래요.
그리고 나쁜 면모가 되게 웃긴게
코어 랭귀지 쪽 보다는
나중에 이제 웹쪽이나 UI쪽을 서포팅을 어떻게 하면서
거기서 억지로 넣기 시작하면서 생긴 거에서 문제가 많이 생겼다는게 되게 웃겨요.
제가 볼땐 다른 팀이 만들었거나 아니면 원래 기획자가 나간 것 같은데
러스트는
아 모질라가 정말 제가 볼때는 기술력은 뛰어 난것 같아요. 비지니스 센스는 좀 안좋을진 몰라도
보면서 야~
저정도 언어를 그래도 만드는구나
물론 오픈소스죠
오픈소스여 같고 열심히 같이 만드는건데
최종 결정은 아무래도 모질라 쪽 사람들이 하는게 아닐까 싶어요.
그 쪽에 있는 사람들이 뭐 모질라
회사라기 보단 그쪽에 있는 사람이
보면서 야~ 저 언어 진짜 언제 쓰고 싶다.
라는 생각을 하는데
쩝..  뭐 언어는 사실 툴이 따라 와야죠.
그래서
비주얼 스튜디오만한 툴이 저기에 들어가고 아니면 
비주얼 스튜디오가 러스트를 지원 할 수 있다면 좋겠고
아니면 쩝.. 마소에서 새로운 언어를 만들어도 되구요. 사실은
마소에서 C#정도 만든걸로 컴파일 되는 언어 
C#을 컴파일 할려고 하고는 있지만
지금 C#이 좀 많이 드러워진 상태라
하아~
C#에 대해선 앞으로 걱정이 조금 많아요.
제가 C#스펙 한 3.0에서 머무르고 2.0이나
그러고 거기다가 패러럴 라이브러리 정도만 쓰는 거면은 굉장히 깔끔한 코드가 나올텐데
그 외에 문제가 좀 많더라구요.
하아.. 프로그래밍 얘기를 하면 언제나 얘기가 길어져
포프였습니다.
