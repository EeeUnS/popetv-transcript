안녕하세요, 포프입니다. 동영상 제목을 뭘로 할까 고민하고 있는데, 좀 눈길을 끌 만한 걸로 나갈 것 같기는 해요. 제가 POCU 아카데미에서 'COMP2500: 개체 지향 프로그래밍 및 설계' 과목을 가르칠 때 했던 얘기 기는 해요. 개체 지향 프로그래밍 자체가 대단한 개념은 사실 아니에요. 우리가 포장해서 굉장히 대단하다고 말하고 싶어 하긴 하는데, 개체 지향을 한때 약 파시던 분들이 그렇게 말해서 정신승리하는 게 있어요. 그러나 지금 다 쓰고 있는 방식이라는 건 다 동의하는 얘기고요. 결과적으로 그 당시에 개체 지향이 막 나오기 시작할 때 그런 말을 하신 분들이 있어요. 그것도 꽤 깨어 계신 컴퓨터 공학자들 중에서요. 개체 지향 프로그래밍이 대기업에서 굉장히 인기가 많은 이유, 그리고 대기업이 그것을 굉장히 빨리 접목한 이유는 사실 한 가지예요. 실력이 뛰어나지 않은 프로그래머들이 "이것저것 만져서 고장 내는 일을 막기 위해서이다"란 이야길 해요. 이 얘기를 들어보신 분들은 별로 없을 거예요. 왜냐하면 그 이후에 실제 대학에서 프로그래밍 가르치시는 분들 중 특히 개체 지향을 가르치시는 분들이, 그런 업계에서 훌륭한 위치에 있어서 어떤 언어를 왜 사용하는지 모르시는 분들도 꽤 있었기 때문인 거 같아요. 그 말이 100%는 아니지만, 굉장히 맞는 이야기이긴 해요.

예전에 C언어의 경우 접근 권한을 제한하는 데 어려운 부분들이 있었어요. 헤더 파일 #include 하거나 이것저것 다 할 수 있고, 소스코드 파일, 기타 등등 다 만질 수 있거든요. 어떤 프로그래머가 어떤 소스코드를 책임지는지 권한을 관리하기가 조금 어려웠고, (할 수는 있었지만) 귀찮았죠. 근데 개체 지향이 들어오면서 결과적으로 모든 것에 Access Modifier(접근제어자)가 생기기 때문에 '클래스를 누구 한 명이 책임진다. 이 그룹의 프로그래머가 이 클래스를 책임지고, 다른 사람은 못 고친다.'라는 규칙을 확실히 박아버리면 그 클래스 내부를 아무나 손댈 수가 없는 거죠. 이렇게 사람들에게 책임을 딱딱 분리하기에 좋았어요. 그런데 '이게 그런 쪽으로 근데 사용이 많이 됐냐?'라고 질문을 하면, 대기업은 그런 식으로 좀 많이 사용했어요. 그래서 대기업으로 갈수록 정말 이상한 코드를 많이 볼 수가 있어요. 있다가 좀 뒤에 하나의 예시로 말씀드릴게요. 그러나 소규모 기업이라던가, 아니면 모든 언어가 그냥 개체 지향으로 흘러가니까 그런 실력 없는 프로그래머가 코드를 망가뜨리는 게 문제가 아닌, 실력 있는 프로그래머가 굉장히 많은 쪽의 업계들은 그 개체 지향을 이상하게 사용하는 습관을 안 따라갔죠. 그래서 실제 사용하는 프로그래밍 언어는 OOP 기반이지만, 코딩 습관 자체는 OOP 언어가 아닌듯한 거죠. 게임업계가 이렇죠. 게임업계에는 굉장히 훌륭한 프로그래머들이 많이 있었기 때문이에요. 이 쪽은 좀 다른 방향으로 갔어요. 개체 지향의 편리함도 사용하면서 성능도 최대한 뽑아내는 쪽으로 갔죠.

반면에 반대쪽, 좀 이상하다고 제가 말한 쪽, 코드 몽키라고 할게요. 코드 몽키들이 개체 지향을 사용할 때, 코드 망가뜨리는 거 막기 위해서 온갖 배리어(barrier)로 떡칠을 하면서 성능은 포기하는 방향으로 갔죠. 어느 쪽이 옳냐 틀리냐는 별 의미가 없어요. 어떤 사람들과 일하느냐에 따라 달라요. 정말 좋은 프로그래머들만 있는 회사라면 제약은 많이 풀어도 되죠. 그게 아니라 실력 없는 프로그래머가 많으면 어떻게 해서든 제약을 마구 걸게 하고요. 어디든 실력 좋은 소수는 있거든요? 그 소수만이 그 제약에 자유롭게 그 속(시스템)을 다 만든다거나, 아니면 다른 사람들이 사용할 수 있는 클래스들을 만들어서 제약을 다 걸고 '넌 이것만 사용해. 자, 너는 버튼 하나만 눌러. 다른 거 죽어도 하지 마' 이런 식으로 알려 주는 거예요. 그렇게 할 수 있는 것 중에 하나를 제가 말씀드릴게요. 이건 저도 회사를 운영하는 입장이고, 웹을 하는 상황에서 게임 쪽에 있는 프로그래머들보다는 조금 실력이 그렇게 뛰어나지 않은 프로그래머들하고 일했어요. '아, 저 사람들이 우리 코드를 유지 보수하기 너무 힘들 정도로 망가뜨리는 짓을 막으려면, 어쩔 수 없이 (제한)해야 되겠군.' 하면서 제약을 걸면서 발견한 것들 중에 하나예요.

요런 상황이 있다고 생각해보죠. 어떤 함수가 있고, 이 함수에서 받는 매개변수가 여러 개 있어요. 근데 매개변수 형이 어떤 경우에는 클래스를 받기도 하고 어떤 경우에는 int 같은 기본 데이터형 받기도 해요. 즉, 예를 들어서 어떤 매개변수 형이 Human이다. 그러면 내가 뭘 만드는 건지는 모르지만, 사람이라는 개체를 가리키는 굉장히 특정적인 데이터 타입이에요. 이걸 저는 강한 타입(Concrete Type, 구체적인 타입)이라고 말해요.

func(Human)

제가 말하는 게 무슨 스태틱 타입, 다이내믹 타입 이런 게 아니라 그냥 개념상으로 딱 하나만 가리키는 굉장히 강력한 타입이에요. 근데 그게 아니라 가끔은 이런 것도 받아야 되잖아요. 사람의 나이 (정수 타입으로 int, unsigned int, byte들이 있겠죠), 사람의 키(cm), 전화번호 등을 int로 받을 수가 있잖아요? 그런 거를 한 네 개 정도를 받는 함수가 있다고 생각해보죠.

func(int age, int heightCentimeter, int weightKilogram, int phoneNumber)

라는 함수를 작성했어요. 그러면은 누군가 함수를 호출하잖아요? 그러면 대부분 제대로 호출할 거라고 생각하죠. 근데 그 생각과 다르게, 실수하는 사람들이 있어요. '함수 호출을 누가 실수해요?'라고 그러지만, 실제 실수하는 사람들이 굉장히 많아요. 왜? 매개변수가 다 똑같은 int 자료형이니까요. 생각 없이 내 머릿속에서는 '나이가 뭐 보다 먼저 와야 해', '키가 나이보다 먼저 와야 해. 왜냐하면 나는 사람을 묘사할 때 키 다음에 나이를 생각하고, 다른 사람은 나이 다음에 키를 생각하니까'라는 자기만의 생각에 빠져요. IDE가 이 매개변수는 age를 넣어야 한다고 알려도, 잘 신경을 안 쓰고 본인 생각대로 코딩하는 거예요. 집중을 안 하면 그렇게 돼요. 그렇게 코드를 넣으면 자기가 지금 넣었던 숫자에는 제대로 작동해요. 테스트도 적당히 다 돌고요. 그럼 자긴 됐다고 생각하고 끝난 거예요. 근데 자기가 사용한 데이터 말고 실제 올바르지만 다른 데이터가 들어간다고 해보죠. 그렇게 매개변수를 잘못 넣으면 깨뜨릴 수 있는 경우를 넣었을 때는 쫄딱 망하죠. 실제 라이브 돌면서 버그가 나오고요. 그거를 코드 리뷰에서 잡을 수 있다? 쉽진 않아요. 왜냐면 코드 리뷰 보는 사람은 호출하는 코드만 보지, 실제 메서드에 함수 signature가 어떤지 다 찾아보기는 어렵거든요. 바뀐 코드만 보는 게 일반적이니까요. 그래서 함수 호출 같은 경우에는 '어떤 매개변수가 들어가 있다' 정도만 보지 그게 올바른 순서인지 판단하기가 어려워요. 코드 리뷰 보는 사람은 그래서 (매개변수 순서) 못 잡고 넘어가요.

A: "테스트해 봤어?"
B: "다 했어요. 잘 돌아요."
A: "오케이."

하고 모두 퇴근했어요. 갑자기 늦은 밤에 911(긴급상황)이 터졌어요. 그런 경우들이 있어요. POCU에서 그런 일이 최근에 있었어요. 요것보다는 조금 복잡한데, 최근에 조교님들을 위해서 어떤 학생의 빌드 리포트 같은 것을 보면서 검토해 줄 때 학생들의 제출된 과제 파일 몇 개를 다운로드할 수 있는 기능을 넣었어요. 이 기능에 필요한 인자들을 보면, 그 파일을 가져와야 하잖아요? 그럼 인자 중에 하나가 학생이 만든 빌드가 있으니까 빌드 ID(GUID, UUID 타입)가 들어가야 하고, 그 외에 학생 유저 ID가 들어가야 해요. 그 학생의 유저 ID 폴더에 가서 파일을 찾아와야 하니까요. 그래서 두 개를 사용해서 함수를 호출하면 되는 거였어요. 함수에 같은 GUID 타입이 2개 들어가잖아요. 그렇죠? 그러면 첫 번째 만들 수 있는 실수가 뭐냐면, 유저 ID와 빌드 ID의 순서를 바꾸면 문제가 되겠죠. 그런데 이건 구현하는 사람이 당연히 테스트를 하면 바로 잡힐 거예요. 그 두 개 Guid가 바뀌었을 때 폴더를 못 찾을 테니까요. 이것과 다른 상황은 뭐였냐면, GUID 순서는 똑바로 넣었어요. 근데 문제가 뭐냐면 아까 유저 ID라고 말한 거 있죠? 원래 학생의 유저 ID가 제대로 들어가 있었는데, 우리 프로그래머가 자기 딴에 이거 리팩토링 한다고 좀 예쁘게 바꾸다가 로그인 한 유저의 유저 ID로 바꿔 넣은 거예요. 자, 내가 조교라고 해봐요? 내가 학생의 빌드 리포트를 보고 있어요. 로그인 한 사람 누구예요? 조교죠? 그럼 조교의 유저 ID를 넣고, 학생이 만든 파일들을 가져오라고 했는데 당연히 그 파일을 못 찾잖아요? 그래서 파일을 못 찾고, 서버에서 문제가 생기는 이른바 라이브 문제가 생겼던 거예요. 그럼 이 프로그래머가 문제를 왜 못 잡았냐고요? 테스트 한 데이터가 자기를 조교로 등록해두고 자기가 빌드를 한 다음에 자기 빌드 리포트를 본 거예요. 그러면 로그인 한 유저와 빌드를 만든 학생의 유저 ID가 똑같잖아요. 그래서 자기 딴에는 그게 제대로 돈다고 생각하고 넘어갔던 거죠. 그리고 코드 넣어두고 신경도 안 쓰고 있다가 다음 날 새벽인가 문제 터졌었어요. 그래서 이걸 보면서... 어이는 없죠. 왜냐하면 여태까지 저희 다른 프로그래머가 그런 문제를 만든 적이 없어요. 여태까지 일하던 프로그래머들은 굉장히 잘하는 친구들만 있었고, 지금부터 서서히 좀 사람들을 채용해 가고 있기 때문인데요. 생각보다 부주의한 프로그래머들이 있어요. 그럼 이제 그 부주의한 거를 보면서 요런 문제를 일으키는 프로그래머는 당연히 이 문제 하나만 일으키진 않겠죠? 다른 비슷한 것도 일으켰겠죠? 그러다가 든 생각이 그거예요. '첫 번째 문제는 그 매개변수를 UUID로 받는 게 문제다.' 왜? 빌드 ID, 유저 ID, 과제 ID 등 어떤 ID던지 다 UUID로 보통 관리를 하는데요. 그걸 실수로 잘못 넣거나, 아니면 처음에는 제대로 넣었는데 나중에 누가 함수 signature를 고치면서 다른 데 있는 모든 것을 확인 안 한 거죠. 기본적으로 프로그래머는 해야 돼요. 근데 안 하시는 분들이 또 있어요. 제가 좀 전에 말했던 그런 문제 만드시는 분들 (확인) 절대 안 해요. 그러면 자기는 몇 개 테스트 돌았다고 넘어가는데, 다른 데서 깨지는 경우들이 있거든요. 그게 라이브 중에 어디서 나올지 모르고요. 이런 상황들이 있는 거예요. 그래서 보면서 '아, 이거 쉽지 않겠구나. UUID가 있는 게 문제다.' 그러면 우리가 만약에 어떤 함수에 빌드 ID 인자를 받고 싶어요. 그러면 차라리 BuildID라는 클래스를 만들면 돼요. 그게 내부적으로는 GUID 멤버 변수 하나만 가지고 있어도 그 클래스를 만들면은 어쨌든 간에 매개 변수는 BuildID란 클래스를 받아 가잖아요? 그래서 그걸 잘못 넣을 가능성은 없어요. 그런데 우리가 겪은 유저 ID의 문제는, 로그인 한 유저의 유저 ID냐, 빌드를 만든 사람의 유저 ID냐의 문제죠. 둘 다 유저 ID잖아요? 그럼 어떤 걸로도 작동하니까 똑같은 실수는 발생해요. 그럼 해결책이 뭐가 있을까요? 우리가 지금 생각하는 콘텍스트(문맥)가 있죠? 그 문맥에 맞는 개체를 또 만들면 돼요. 클래스를 BuildOwnerID (빌드를 소유하고 있는 사람의 ID), 그리고 로그인 한 유저의 ID면 (LoggedInUserID)을 만드는 거예요. 그 클래스가 따로 아예 생겨버리면, 클래스 매개변수를 잘못 넣을 수가 없어요. 이 얘기를 하면 '이 무슨 미친 소리야' 이럴 수도 있어요. 불편하거든요. 당연히 처음 클래스를 만드는 사람은 불편해요. 그러나 그 클래스 가져다 사용하는 사람 입장에서는 차이가 없죠. 왜냐하면 내가 유저 ID 불러서 넣나, 아니면 어떤 함수가 유저 ID를 반환하는데 그게 UserID 오브젝트로 반환해서 그걸 내가 넣나 별 차이가 없어요. 그래서 처음에 이 배리어 막고 실수 막으려고 하는 사람들만 코드만 쓸데없이 많이 작성하는 거지, 사용하는 사람들은 별 문제가 없는 거예요.

그래서 이게 되고, 아니면은 이게 어렵다면 코드에서 문제가 분명히 보이도록 어떤 Naming Convention이 들어가면 코드 리뷰 할 때 잡을 순 있어요. 그거는 제가 지금 고민하고 있는 거고 아직 최종 결정이 안 났는데, 데이터 트랜스포머? 데이터 브리지? 이런 식으로 좀 개념을 잡아가려고 해요. 예를 들어서 빌드에서 나온 유저 ID가 있고, 그리고 이거를 우리가 가져다 사용하고 싶다고 하죠. 로그인 한 유저 ID가 아니라 그러면 어떤 트랜스포머 클래스나 브리지 클래스에 빌드를 입력으로 넣어주고 거기서 UserID를 직접 반환하는데 최소한 트랜스포머란 클래스를 사용하는 모습이 코드 리뷰에서 보일 테니까 BuildTransfomer.GetUserID(...) 이런 식으로 말이죠. 그러면 그 안에 매개변수로 빌드가 들어갈 거 아니에요 최소한 매개변수 이름을 보면 '아, 이건 빌드의 UserID구나'라는 모습이 텍스트로 보여요. 그래서 그런 걸로 추가 보완을 하려고 생각하는데, 이건 나중 이야기고요.

다시 원래 얘기로 돌아가면, 이렇게 필요한 문맥마다 클래스를 만들어서 사용하는 법. 그래서 최대한 일반적인 데이터 형태를 사용하는 횟수를 줄이고, 그리고 기본 데이터형을 클래스로 바꿔 버리면은 실수를 많이 막을 수가 있어요. 특히 부주의한 사람의 실수, 이거는 어려워서 하는 실수가 아니에요. 그냥 부주의하고 기본적으로 자기가 일하고 확인하는 습관이 안 돼 있고 또는 할 생각도 없는 사람들을 잡을 수가 있는 거예요. 이걸 잡아서 그 사람들이 변할까요? 절대 아니에요. 그 사람들은 그 사람들이 할 수 있는 수준의 코드를 작성할 뿐이에요. 근데 그런 코드를 작성할 사람은 필요하거든요. 물론 간단한 일 주는 거죠. 왜냐면 비싼 프로그래머 데려다가 간단한 일 시키기는 좀 가성비가 안 맞으니까요. 이게 어찌 보면 대규모 코드 몽키 군단을 지니고 회사를 운영해야 하는 대기업에는 어울리는 방식이죠. 분명 이상하게 생각하는 사람도 있을 거예요. 근데 자기 회사에 있는 코드를 보세요. 정말 그 조그만 int 하나까지 클래스로 만들고 있는 데가 있는지요. 분명히 있어요. 저 그런 코드 굉장히 많이 봤어요. 특히 한국에서 하청 하는 Java 코드 베이스에서 정말 많이 봤어요. 그 이유가 이거예요. 이런 실수 막으려고요. 재밌지 않아요, 이거? 근데 Java 쪽에서 이러는 건, 성능을 더럽게 죽이는 거긴 해요. 그래서 실제 성능을 생각하는 괜찮은 프로그램들은 Java 코드로 클래스로 감싸는 거를 굉장히 싫어해요. 왜냐하면 '아무리 우리가 못 하는 프로그래머가 있고, 걔네들이 실력이 안 올라간다고 해도 이렇게 제품의 성능을 줄여야겠어?' 하니까요. 막 2배, 3배, 10배, 20배도 느려지고 100배도 느려질 수 있어요. '이렇게까지 이 짓을 해야 되냐? 이런 짓 해서 성능 느려져 서버 더 증설해야 하는 거 생각하면, 차라리 못 하는 애들을 자르고 잘하는 애들 채용에서 하는 게 더 맞지 않냐?' 이런 고민을 할 수밖에 없는 일들이 있어요. 그러나 자바는 그 배경으로 열심히 발전해 온 언어기 때문에 그 상황에 머물러 있는 거고요.

그게 아닌 자바랑 비슷하면서 성능의 제약을 많이 받지 않는 언어들이 있어요. 대표적인 게 C#이에요. 저희 회사는 어쨌든 C#을 사용하기 때문에, 약간 익스 트림하고 미친 것처럼 보이는 방향으로 서서히 가고 있어요. 이거의 장점이 뭐냐면 이렇게 강하게 코드를 망가뜨릴 수 없는 장치를 박아두면, 앞에서 컨트롤러에 들어가는 코드는 뭐 Junior가 어떻게 작성하든 간에 코드 리뷰 대충 안 해도 돼요. 그거는 기능상의 하자로 바로 보일 테니까, 데이터도 명백하거든요. 단, 그런 아까 말했던 클래스 작성하고 함수 작성하고 이런 것들 있죠? 어떤 Strong 타입 들어오게 작성하는 그런 거 작성하는 코드 부분은 Senior급의 잘하는 프로그래머가 다 코드 리뷰를 보겠죠. 즉, 코드 리뷰를 볼 부분과 안 볼 부분이 확실히 구분이 돼버리고요. 프레젠테이션 레이어는 좀 많이 망가져도 신경 안 써요. 그거 다 리뷰 못 보거든요. 어차피 우리 시간 없어서 그 대신 내부에 중요한 것들 그거만 깔끔하게 유지할 수 있는 방법이 있는 거예요.

어쨌든 C# 얘기로 들어왔는데, C#에 뭐가 있냐고요? 구조체가 있습니다. C#의 구조체는 Value 타입이에요. Value 타입이 뭔지 C/C++ 공부하신 분들은 알죠? 이건 함수에 인자로 패스해도 Heap 메모리에 할당 안 하고요. 무조건 Stack 메모리에 할당해요. 구조체 사이즈가 클 때 그거를 참조로 전달하는 법도 있어요. 참조로 전달을 하면 Copy를 하지도 않아요. C++에서 개체를 직접 전달하는 것과, Object를 Stack 메모리에 안 만들고 new로 만들어서 그거를 포인터로 전달하는 것의 차이는 다 아시죠? 대부분의 경우에 개체를 스택에 만들어서 그냥 전달해 버리죠. 개체 크기가 엄청 크지 않은 이상은 그게 거의 무조건 빨라요. Stack 메모리의 장점이죠. Stack이 빠른 이유, Heap이 느린 이유 다 아셔야 하죠. 그렇기 때문에 그걸 아는 사람들은 자바에서 개체를 수백 개씩 만들어 가지고 패스하는 거 짜증 나죠? 가비지 컬렉터 들어올 거고 더럽게 느려질 거 아니까요. 하지만 C#에서는 struct를 사용하는 순간 그럴 문제가 없다는 거예요. struct는 벨류 타입이고 매개변수로 전달하는 순간 카피가 일어나고, 아니면 C++에서 레퍼런스 전달하듯이 스택에 있는 걸 전달해서 어떻게든 속도를 빠르게 하는 게 가능한 거죠. 예를 들어서 그 구조체에 만약 GUID 멤버 하나만 들어가 있다고 할게요. C/C++ 하신 분들은 이게 어셈블리어로 어떻게 될지 대충 머릿속에 감이 오잖아요? 그냥 내가 Guid 하나 전달하는 거나 struct 하나 만들어서 전달하는 거나 어셈블리 레벨로 내려가면 거의 똑같아야 돼요. 최적화만 잘 됐다면요. 실제 성능의 저하는 없는 게 정상이에요. 그게 성능의 저하가 있다면 Microsoft 열심히 다구리 쳐서 고치라고 해야 하는 거죠. 근데 Microsoft도 C#의 struct 얘기하면서 매개변수 전달 관련 얘기하면서, 이럴 때 성능이 좋은지, 성능 비교해 놓은 자료가 있어요. Microsoft가 제대로 해 놓은 거예요.

그러면 여기서 또 한 가지 할 말은 struct를 패스해요. 매개 변수를 그냥 패키지로 만들어서 한 번에 패스하는 거죠. 단일 매개변수더라도 그냥 스트롱 타입 struct로 만들어 갖고 패스해 버리는 겁니다. 그럼 실수할 일이 진짜 많이 줄어들어요. 처음에 struct 작성하는 비용만 좀 들지만, 사용하는 사람들의 비용은 거의 안 들어가게 돼요. 그렇죠? 그럼 여기서 한 가지 문제가 생겨요. 내가 어떤 개체를 패스를 했어요. 그 개체를 패스했을 때 함수 안에서 또 struct 개체 속을 바꿀 수도 있잖아요. 그러면 기분이 나빠요. 왜냐면은 나는 매개변수를 전달한 게 순수한 int, float 등을 단지 전달만 한 거고, 그걸 바꿀 거라고 생각하지는 않거든요. "네가 바꾼다고 내 쪽에서 바뀌는 건 아니지만(Value Copy 특징), 나는 순수하게 데이터를 그냥 전달해 주려고 한 거야." 이거를 무슨 상태를 유지하고, 나중에 바꾸고 등의 일반적으로 생각하는 개체의 개념이 아니라고요. 개체는 상태를 가지고 함수 호출을 통해서 상태가 바뀌는 게 중요한 거잖아요. 우리가 struct를 사용하는 이유는, 순수 데이터 덩어리지, 데이터 저장소가 아니에요. 단지 매개변수 전달할 때 쓰는 거거든요? C#에서는 이럴 때 사용할 수 있는 게 또 있어요. 바로 readonly struct (읽기 전용 struct)에요. 한 번 만들면 속의 내용을 절대 못 바꿔요. 자, 그러면 실제 내용을 바꾸든 말든 어셈블리 레벨에서는 큰 차이가 없어요. 근데 C#에서 struct를 readonly로 만드는 순간, 그 순간 컴파일러는 알겠죠? '얘는 순수하게 정말 스택에 값 복사하고 그거 사용하는 게 목적이구나. 별 다른 행동 안 하는구나, 복사할 필요도 없고 아무 신경도 안 쓰는구나'를 딱 알죠? 그래서 readonly로 만들고 그런 식으로 매개변수 전달하는 순간, 최적화란 최적화는 다 해줄 수 있겠죠. 그래서 최적화가 돼요. C#에서 readonly struct 사용해서 strong 타입을 굉장히 강하게 만드는 것, 굉장히 구체적으로 만드는 것들을 잘하면은 제 생각에는 정말 이상한 실수하는 사람들 꽤 많이 잡을 수 있을 거예요. 나중에 함수 시그내처 바뀔 때도, 타입 자체가 바뀌거나 아니면 타입이 들어간 위치가 바뀌어 버리니까 컴파일 에러 다 나겠죠? 컴파일 시간에 다 잡을 수 있어요. "이거를 잡기 위해서 유닛 테스트를 많이 만들면 됩니다." 하는 사람이 있을 텐데요, 왜 굳이 그러죠? 그냥 함수 시그내처가 다 해주는 건데요? strong 타입 집어넣으면 다 끝나는 건데요? 그리고 C#에서는 성능 저하도 없는걸요? 왜 그걸 굳이 시간을 쏟아부어서 그런 매개변수 제대로 넣는 거 까지 유닛 테스트를 작성해야 하죠? 말이 안 되죠.

자, 이렇게 언어 설계가 잘 되고, 그리고 정말 막으려고 하는 문제와 그걸 어떻게 풀려고 하는 해법 그리고 해법이 배보다 배꼽이 안 크게 하는 법 이거를 다 알려면요, 하드웨어와 언어를 다 알아야 되는 거고 그 외에도 다 알아야 하는 거지만, 그거를 알면은 그 회사에 맞는 적당한 해법이 나올 수가 있어요. 자, 제 개인적인 입장에서 이 해법이 정말 뛰어나고 내가 정말 좋아하는 해법이냐고요? 아니요. 저는 그것보다는 훌륭한 프로그래머랑 일하는 걸 더 좋아하기는 해요. 그러나 어쨌든 간에 Junior가 들어오면서 Junior가 뭔가를 덜 망가뜨려야 하는 상황, 누군가가 리뷰를 열심히 봐줄 수 없는 상황이라면 그 Junior는 잘하면 성장하겠죠. 그러나 어쨌든 간에 처음에 실수로 막아주는 방어는 있어야 하고, 그 방어를 시스템적으로 만들려면 이런 방식이 있다. 그 방식을 보고 어떤 Junior가 '왜 이거 왜 이렇게 불편할까?' 그 고민을 하고 '아, 이게 이래서 불편하구나!'라고 깨달으면 훨씬 좋아지는 Junior고, 이걸 보면서 '아, 불편하구나. 불편한데 뭐 내 알 바 아니니까 그냥 사용해야지. 그냥 이렇게 사용하면 돼(그러나 사실은 잘못된 사용법일 때)' 라면서 사용하다가 아무 생각 없이 나중에 뭔가 좀 더 중요한 일 하라고 (회사 또는 상사가) 좀 더 자유를 줬어요. 그 순간에 시스템을 망친다면, 이 사람은 시스템을 보면서 왜 그 시스템이 있는지 고민하지 않는 사람이죠. 그러면 역시 발전 가능성이 있는지 없는지도 알겠죠.

자, 얘기가 중구난방적으로 많았어요. 그러나 OOP가 나왔던 이유 중에 하나가 프로그래머가 다양한 거를 망가트리지 못하게 하는 거다라는 얘기를 했고요. 그런 거를 하는 방법 중에 하나가 지금 제가 말씀드린 것처럼, 굉장히 구체적인 타입을 사용하게 강제하는 것이죠. 모든 게 개체화되고, 모든 게 클래스가 되는 방식이다. 그런 방식이 실제 대기업에서 많이 보이는 방식이고요. 소규모 기업에서는 좀 잘 안 하는 이유가, 그거 하나하나 하기 힘들기도 하고요. 잘하는 사람들이 모여 있는 소규모 회사일수록 그 성능 저하를 받아들이기가 너무 힘든 거예요. 그래서 못했지만, C# 같은 훌륭한 언어가 있다면 충분히 할 수도 있다는 것이라는 말씀을 드릴게요. 저도 시도해 볼 거고, 장점은 다 얘기한 거 같으니까 단점이 나오면은 그때 또 다른 비디오를 만들던가 할게요. 참고도 이것도 UX의 일부예요. 내 프로그래머는 어떤 사람이냐? 그 사람들이 실수를 하지 않으려면 어떤 시스템을 줘야 되고, 그 시스템이 제대로 돌 수가 있느냐? 그 사람들이 얼마나 시간을 낭비하느냐? 그걸 하기 위해서 시스템 만드는 사람들이 시간을 얼마나 낭비하느냐? 그러면 그 시스템을 만든 사람이 낭비하는 시간을 어떻게 보상해 줄 수 있느냐? 저는 그 해답을 아까 코드 리뷰 볼거리가 확 줄어든다라는 얘기로 조금은 드렸죠. 어쨌든 뭐 그렇게 다양한 얘기를 했고, 중간에 말도 엄청 빠르게 했으니까, 대충 이 정도로 끊겠습니다. 포프였습니다.
