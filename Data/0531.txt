안녕하세요, 포프입니다
'동영상 제목을 뭘로 할까' 
고민을 하고 있는데
뭐, 어쨌든 좀 눈길을 끌 만한
걸로 나갈 것 같기는 해요
제가 POCU 아카데미에서
'개체지향 프로그래밍 및 설계'
그 과목을 가르칠 때 했던 얘기기는 해요
그 개체지향 프로그래밍 자체가 
뭐 대단한 개념은 사실은 아니에요
우리가 굉장히 포장해서
대단하다고 말하고 싶어 하긴 하는데
그거는 개체지향을 한참 약 파시던 분들이
그렇게 해서 좀 정신승리 한 것도 있고
그러나 지금 다 쓰고 있는 방식이라는 거는 
다 동의하는 얘기고
결과적으로 그 당시에 개체지향이
막 나오기  시작할 때 
그런 말을 하신 분들이 있어요
그것도 꽤 깨어 계신 컴퓨터공학자 중에
개체지향 프로그래밍이 대기업에서
굉장히 인기가 많은 이유
대기업이 이거를 굉장히 빨리 접목한 이유는
사실 한 가지다
실력 뛰어나지 않은 프로그래머들이 
이것저것 만져서 고장내는 일을 
막기 위해서다란 이야길 해요
그 얘기를 들어보신 분들은 별로 없을 거예요
왜냐면은 그 이후에 실제 
대학에서 프로그래밍 가르치시는 분들
특히 개체지향 쪽 가르치시는 분들이 
그런 업계에서 훌륭한 위치에 있어서
어떤 언어를 왜 사용하는지
모르시는 분들도 꽤 있었기 때문인 거 같아요
이거를 말씀드리면 그 말이 100%는 아니지만
굉장히 맞는 이야기기는 해요
예전에 C 언어 같은 경우에는 
접근 권한을 제한하기가 
어려운 부분들이 있었어요
헤더파일 인클루드하거나 별거 별거 다 할 수 있고
소스코드 파일 다 만질 수도 있고
기타 등등 이런 게 있었고
어떤 프로그래머가 어떤 소스코드를 책임지는지
그 권한을 관리하기도 좀 어려웠고
기타 등등 이런 게 있었는데
뭐 할 수는 있었지만
그 조금 귀찮았죠
근데 개체지향으로 들어오면은 
결과적으로 모든 거에
Access Modifier(접근제어자)가 생기기 때문에
클래스를 누구 한 명이 책임진다
요 그룹의 프로그래머가 요 클래스를 책임지고
다른 사람은 못 고친다라는
규칙을 확실히 박아 버리면
그 클래스 내부를 아무나 손 댈 수가 없는 거죠
그렇기 때문에 그런 식으로
책임
사람들에게 책임을 딱딱 분리하기에 좋았어요
그래서 
'이게 그런 쪽으로 근데 사용이 많이 됐냐?'
라고 질문을 하면은
대기업은 그런 식으로 좀 많이 사용을 했어요
그래서 대기업으로 갈 수록 
정말 이상한 코드를 많이 볼 수가 있어요
그거의 한 예를 좀 뒤에 말씀을 드릴게요
그러나 소규모 기업이라던가
아니면 모든 언어가 그냥 개체지향으로 흘러가니까
지금 말했던 것처럼
그런 실력없는 프로그래머가 코드를 망가뜨리는 게 
문제가 아닌 실력 있는 프로그램을 굉장히 많은 쪽
그런 업계들은 그 개체지향을 
좀 이상하게 사용하는 듯한 습관을 
안 따라갔죠
그래서 실제 언어는 OOP 언어지만
코딩습관 자체는 OOP 언어가 아닌듯한?
게임업계, 이런 애들이 좀 그렇죠
게임업계 쪽에 굉장히 
훌륭한 프로그래머들이 많이 있었기 때문에
그런 쪽은 이제 좀 다른 방향으로 갔어요
그래서 그 쪽은 개체지향에 편리함도 사용하면서
성능도 최대한 뽑아내는 쪽으로 갔고
그게 아니라 이제 저쪽
아까 좀 이상하다고 제가 말한 쪽들
개체지향을 사용하면서 뭐~ 그냥 코드몽키라 할게요
코드 원숭이들이 코드 망가뜨리는 거 막기 위해서
온갖 배리어(barrier)를 떡칠을 하면서 성능은 포기하는
그런 쪽으로 가게 됐죠
뭐 어느 쪽이 옳냐 틀리냐 이거는 별 의미는 없어요
그냥 어떤 사람들과 일하느냐
정말 좋은 프로그래머들만 있는 회사라면
제약은 많이 풀어도 되고
그게 아니라 실력없는 프로그래머가 많으면
어떻게든지 제약을 마구 걸고
어디든 실력 좋은 소수는 있거든요
그 소수만이 그 제약에 제한이 없이 
이거를 그 속을 다 만든다거나
아니면 다른 사람들이 사용할 수 있는 클래스
뭐, 이런 걸 만들어서 제약을 다 걸고 
'넌 요거만 사용해'
'자, 너는 버튼 하나만 눌러. 다른 거 죽어도 하지 마'
이런 식으로 알려 주는 거예요
그렇게 할 수 있는 것 중에 하나를 제가 말씀을 드릴게요
이건 저도 이제 회사를 운영하는 입장이고
웹 쪽을 하는 상황에서
게임 쪽에 있는 프로그래머들 보다는
조금 실력이 그렇게 뛰어나지 않은 프로그래머들하고
일하게 되면서 
'아, 저 사람들이 정말
우리 코드를 유지보수하기 너무 힘들 정도로
망가트리는 일을 막으려면은 어쩔 수 없이 해야 되겠군'하면서
제약을 걸면서 발견한 것들 중에 하나에요
 요런 상황이 있다고 생각을 해 봐요
어떤 함수가 있어요
이 함수에서 받는 매개변수가 여러 개가 있어요
근데 매개변수 형이
어떤 경우에는 클래스를 받기도 하고
어떤 경우에는 int 같은 기본데이터형 받기도 해요
즉, 예를 들어서 어떤 매개변수 형이 Human이다
그러면 내가 뭘 만드는 건지는 모르지만
사람이라는 개체를 가리키는
굉장히 특정적인 데이터타입이예요
이걸 저는 강한 타입이라고 얘기해요
Concrete Type. 구체적인 타입
제가 말하는 게 무슨 스태틱 타입
무슨 다이나믹 타입 이런 게 아니라
그냥 개념상으로 딱 하나만 가리키는
굉장히 강력한 타입이에요
근데 그게 아니라 가끔은 이런 것도 받아야 되잖아요
어떤 사람의 나이
그러면 int, 아니면 byte도 상관없고
아니면 unsigned int도 상관없고
나이, 뭐 어떤 사람의 키, 센치미터 까지만
그럼 또 int로 받고
그 사람의 전화번호
그럼 또 int로 받을 수가 있잖아요
그럼 그런 거를 한 네 개 정도를 받는
함수가 있다고 생각을 해봐요
이 함수를 작성을 했어요 
그러면은 누군가 함수를 호출 하잖아요
그러면 대부분 제대로 호출할 거라고 생각을 하죠
근데 생각보다 안 그런 사람들이 있어요
'함수 호출, 그거 뭐 누가 실수해요?'라고 그러지만
실제 실수하는 사람들 굉장히 많아요
왜? 똑같은 int 형이야
생각이 없이
내 머리 속에서는 '나이가 뭐 보다 먼저 와야 돼'
내 머릿속에는 
'키가 나이보다 먼저 와야돼' 
왜냐하면 나는 사람을 묘사할 때
키 다음에 나이를 생각하고 
다른 사람은 나이 다음에 키를 생각하니까 
그냥 자기 생각에 빠져서
IDE가 이거는 age를 넣어야 한다 보여 줘도
잘 신경을 안 쓰고 내 생각대로 치는 거야
집중을 안 하면 그렇게 돼요
그럼 그렇게 코드를 넣으면은
자기가 지금 넣었던 숫자에는 제대로 작동을 해요
테스트도 적당히 다 돌아
그럼 자긴 됐다고 생각하고 끝난 거야
근데 자기가 사용한 데이터 말고
실제 올바르지만 다른 데이터
단, 그게 내가 매개변수를 잘못 넣으면 깨뜨릴 수 있는 경우
그런 경우를 넣었을 때는 쫄딱 망하죠
실제 라이브 돌면서 버그가 나오죠
그거를 코드 리뷰에서 잡을 수 있다? 
쉽진 않아요
왜냐면 코드리뷰 보는 사람은
호출하는 코드만 보지
실제 메서드에 시그네쳐가 어떤지를 다 
찾아보기는 어렵거든요
바뀐 코드만 보는 게 일반적이니까
그래서 함수 호출 같은 경우에는 
'어떤 매개변수가 들어가 있다' 정도만 보지 
그게 올바른 순서인지 판단하기가 어려워요
코드리뷰 보는 사람은
그래서  못 잡고 넘어가요
A: "테스트해 봤어?"
B: "다 했어요. 잘 돌아요"
A: "오케이"하고 다 나갔어
갑자기 밤에 911(긴급상황) 터지는 거야
그런 경우들이 있어요
POCU에서 그런 일이 최근에 있었어요
뭐였냐면은 
요것보다는 조금 복잡한데 
최근에 조교님들을 위해서 
어떤 학생의 빌드 리포트 같은 것을 보면서
검토 해 줄 때
학생들의 파일 몇 개를 다운받을 수 있는
실제 과제 관련 파일을
그 기능을 넣었어요
그럼 이 기능에 필요한 인자들을 보면은
그 파일을 가져 와야 되잖아요
그럼 인자 중에 하나가 
학생이 만든 빌드가 있으니까
빌드 ID가 들어가야 되고
Guid 형이에요. Uuid 타입
그리고 빌드 ID 외에 학생의 유저 ID가 들어가야 돼요
그 학생의 유저 ID 폴더에 가서
파일을 찾아와야 하니까
그래서 두 개를 사용해서 함수를 호출하면 되는 거예요
근데 함수에 Guid가 2개가 들어가잖아요
그죠?
그러면 첫 번째 만들 수 있는 실수가 뭐냐면은
유저 ID하고 빌드 ID의 순서를 바꾸면
문제가 되겠죠
그런데 이거는 구현하는 사람이 당연히 테스트를 하면
바로 잡힐 거예요
그 두 개 Guid가 바뀌었을 때 폴더를 못 찾을테니까
요번 상황은 뭐였냐면은 Guid 순서는 똑바로 넣었어요
근데 문제가 뭐냐면 아까 유저 ID라고 말한 거 있죠?
우리 프로그래머가 원래 학생의 유저 ID가
제대로 들어가 있었는데
자기 딴에는 이거 리팩토링 한다고
좀 예쁘게 바꾸다가
로그인 한 유저의 유저 ID로 바꿔 넣은 거예요
자, 내가 조교라고 해봐요? 
내가 학생의 빌드 리포트를 보고 있어
로그인 한 사람 누구예요? 조교죠?
그럼 조교의 유저 ID를 넣고
학생이 만든 저 파일을 가져 오라고 했는데 
당연히 그 파일을 못 찾잖아?
그래서 파일을 못 찾아 가지고 서버에서 문제가 생기고
라이브 문제가 생겼던 거예요
그럼 이 프로그래머가 문제를 왜 못잡았느냐?
테스트 한 데이터가 자기를 조교로 등록해두고
자기가 빌드를 한 다음에 
자기 빌드 리포트를 본 거예요
그러면 로그인 한 유저와 
빌드를 만든 학생의 유저 ID가 똑같잖아
그래서 자기 딴에는
그게 제대로 돈다고 생각하고 넘어 갔던 거야
그리고 코드 넣어두고 신경도 안 쓰고 있다가
다음 날 새벽인가에 문제 터졌었어요
그래서 이걸 보면서...
어이는 없죠, 사실
왜냐하면은 여태까지 저희 다른 프로그래머가 
그런 문제를 만든 적이 없어요
여태까지 일하던 프로그래머들은 
굉장히 잘 하는 친구들만 있었고
지금부터 서서히 좀 사람들을 
채용해 가고 있기 때문인데
생각보다 부주의한 프로그래머들이 있어요
그럼 이제 그 부주의한 거를 보면서
요런 문제를 일으키는 프로그래머는 당연히 
고 문제 하나만 일으키진 않겠죠?
다른 비슷한 것도 일으켰겠죠?
그러다가 든 생각이 그거예요
그러면 우리가 첫 번째 문제는
그 매개변수를 uuid로 받는 게 문제다
왜? 빌드 ID, 유저 ID
어떤 ID든... 뭐, 과제 ID 
다 uuid로 보통 관리를 하는데
그걸 실수로 잘못 넣거나
아니면 처음에는 제대로 넣었는데
나중에 누가 함수 시그내처를 고쳤어
고치면서 다른 데 있는 모든 것을 
확인 안한 거야 
기본적으로 프로그래머는 해야 돼요
근데 안 하시는 분들이 또 있어요
제가 좀 전에 말했던 그런 문제 만드시는 분들
절대 안 해요
그러면 자기는 몇 개 테스트 돌았다고 넘어가는데 
다른 데서 깨지는 경우들이 있거든
그게 라이브 중에
어디서 나올지 모르고
그래서 그런 것들이 있는 거예요
그래서 보면서 '아, 이거 쉽지 않겠구나'
'uuid가 있는 게 문제다'
그러면 우리가 만약에 빌드 ID 인자를 받고 싶어요
그러면 차라리 BuildID란 클래스를 만들면 돼요
그게 내부적으로는 Guid 멤버변수 하나만 가지고 있어도
그 클래스를 만들면은  어쨌든 간에 
매개 변수는 BuildID란 클래스를 받아 가자나요
그래서 그걸 잘못 넣을 가능성은 없어요
그런데
우리가 준 유저ID의 문제는 
로그인 한 유저의 유저 ID냐
빌드를 만든 사람의 유저 ID냐의 문제죠
둘 다 유저 ID잖아
그럼 어떤 걸로도 작동하니까 똑같은 실수는 발생을 해요
그럼 뭐가 있느냐
우리가 지금 생각하는 컨텍스트(문맥)가 있죠?
그 문맥에 맞는 개체를 또 만들면 돼요. 클래스를
BuildOwnerID
빌드를 소유하고 있는 사람의 ID
그리고 로그인 한 유저의 ID면 
LoggedInUserID
그 클래스가 따로 아예 생겨버리면 
클래스 매개변수를 잘못 넣을 수가 없어요
이 얘기를 하면은
'이 무슨 미친 소리야'
이럴 수도 있어요
왜냐면 불편하거든
당연히 처음 클래스를 만드는 사람은 불편해요
그러나 그 클래스 가져다 사용하는 사람
그 사람들한테는 차이가 없죠
왜냐면 내가 유저 ID 불러서 넣나
아니면 어떤 함수가 유저 ID를 반환하는데 
그게 UserID 오브젝트로 반환해서 
그걸 내가 넣나
별 차이가 없어요
그래서 처음에 이 배리어 막고
실수 막으려고 하는 사람들만
정말 코드만 쓸데없이 많이 작성 하는 거지
그걸 사용하는 사람들은 별 문제가 없는 거예요
그래서 이게 되고
아니면은 이게 어렵다면
코드에서 문제가 분명히 보이도록
어떤 네이밍컨벤션이 들어가면은 
그걸 잡을 순 있어요
코드리뷰 하면서
그거는 제가 지금 고민하고 있는 거고
아직 최종 결정이 안 났는데
데이터 트랜스포머? 데이터 브릿지?
이런 식으로 좀 개념을 잡아 가려고 해요
예를 들어서
빌드에서 나온 유저 ID가 있고
그리고 이거를 우리가 가져다 사용하고 싶다
로그인 한 유저 ID 가 아니라
그러면 어떤 트랜스포머 클래스나
브릿지  클래스에 빌드를 입력으로 넣어주고
거기서 UserID를 직접 반환을 하는데
최소한 트랜스포머란 클래스를 사용하는 모습이
코드 리뷰에서 보일 테니까
BuildTransfomer.GetUserID(...) 이런 식으로 말이죠
그러면 그 안에 매개변수로 빌드가 들어갈 거 아니에요
최소한 매개변수 이름을 보면 
'아, 이건 빌드의 UserID구나'
라는 모습은 보여요. 텍스트로
그래서 그런 걸로 좀 추가 보완을 하려고 생각을 하는데
이건 나중 이야기고
다시 원래 얘기로 돌아가면 
이렇게 필요한 문맥마다 
클래스를 만들어서 사용하는 법
그래서 최대한 
일반적인 데이터 형태를 사용하는 횟수를 줄이고
그리고 기본 데이터형을 클래스로 바꿔 버리고
이러면은 정말 실수를 많이 막을 수가 있어요
특히 부주의한 사람의 실수
이거는 어려워서 하는 실수가 아니예요
그냥 부주의하고 
기본적으로 자기가 일하고 확인하는
습관이 안 돼 있는 애들
아니면 할 생각도 없는 애들
그런 사람들 잡을 수가 있는 거예요
이걸 잡아서 그 사람들이 나아지냐? 
절대 아니예요
그 사람들은 그 사람들이 할 수 있는  수준의 
코드를 작성할 뿐이고
근데 그런 코드를 작성할 사람이 필요하거든요
물론 간단한 일 주는 거죠
왜냐면 비싼 프로그래머 데려다가
간단한 일 시키기는 좀 가성비가 안 맞으니까
이게 어찌보면 대규모 코드몽키 군단을 지니고
회사를 운영해야하는 대기업에는
어울리는 방식이죠
이 말하면 분명 이상하게 생각하는 사람도 있을 거예요
근데 자기 회사에 있는 코드를 봐 봐요
정말 그  조그만 int 하나까지 
클래스를 만들고 있는 데가 있는지
분명히 있어요
저 그런 코드 굉장히 많이 봤어요
특히 한국에서 하청하는 Java 코드베이스에서 
정말 많이 봤어요
그 이유가 이거예요
이런 실수 막으려고
재밌지 않아요, 이거?
근데 자바 쪽에서 이러는 거 
성능을 더럽게 죽이는 거긴 해요
그래서 실제 성능을 생각하는
괜찮은 프로그램들은
자바코드로 이런 거 하는 거를 굉장히 싫어해요
왜냐면 
'야? 아무리 우리가 못 하는 프로그래머가 있고
걔네들이 실력이 안 올라간다고 해도
이렇게 제품의 성능을 줄이면서까지...'
막 2배, 3배 10배, 20배도 느려지고 
100배도 느려질 수 있어요
'... 그러면서까지 이 짓을 해야 되냐?'
'이런 짓 해서 성능 느려져 
서버 더 쳐 박아야 하는 거 생각하면
차라리 못 하는 애들을 자르고
잘하는 애들 채용에서 하는 게 더 맞지 않냐?'
이런 고민을 할 수밖에 없는 일들이 있어요
그러나 자바는 
그 배경으로 열심히 발전해 온 언어기 때문에
그 상황에 머물러 있는 거고
그게 아닌 자바랑 비슷하면서
성능의 제약을 많이 받지 않는
그런 언어들이 있어요
대표적인 게 C#이에요
저희 회사는 어쨌든 C#을 사용하기 때문에
약간 익스트림 하고
미친 것처럼 보이는 방향으로 
서서히 가고는 있어요
이거의 장점이 뭐냐면 
이렇게 강하게 
코드를 망가트릴 수 없는 장치를 박아두면은
앞에서 컨트롤러에 들어가는 코드는 뭐
주니어가 어떻게 작성하던
코드리뷰 대충 안 해도 돼요 
그거는 기능상의 하자로 바로 보일테니까
데이터도 명백하고 
단, 그런 아까 말했던 클래스 작성하고 
함수작성 하고 이런 것들 있죠?
딱 어떤 스트롱한 타입 들어오게 작성하는
그런 거 작성하는 부분
그런 코드가 있는 거는 시니어 급이
잘하는 프로그래머가 다 코드리뷰를 보겠죠
즉, 코드리뷰를 볼 부분과
안 볼 부분이 확실히 구분이 돼버리고
프리젠테이션 레이어는 
좀 많이 망가져도 신경 안 쓰고
그거 다 리뷰 못 보거든 
어차피 우리 시간 없어서
그 대신 내부에 중요한 것들
그거만 깔끔하게 유지할 수 있는 방법이 있는 거예요
어쨌든 C# 얘기로 들아오면... C#에 뭐가 있냐?
구조체가 있습니다
C#의 구조체는요 밸류(값) 타입이에요 
C/C++ 공부하신 분들은 알죠?
밸류타입이 뭔지
자, 이거 함수에 인자로 패스해도 
힙메모리 할당 안 하고요
무조건 스택 메모리 할당해요
그거를 참조로 전달하는 법도 있어요. C#에서는... 
참조로 전달을 하면은 카피를 하지도 않아요
그 구조체 사이즈가 클 때
그러면 C++에서 보면은 개체를 직접 전달하는 거와
개체를 스택에 안 만들고
new로 만들어서 그거를 포인터로 전달 하는 것과
그 차이는 다 아시죠?
대부분의 경우에 개체를 스택에 만들어서
그냥 전달해 버리죠
그게 거의 무조건 빨라요
개체 크기가 엄청 크지 않은 이상은
뭐 스택의 장점이죠
스택이 빠른 이유
뭐, 힙이 느린 이유
다 아셔야 하죠
그렇기 때문에 그걸 아는 사람들은
자바에서  개체를 수백개씩 만들어 가지고
패스하는 거 그 짜증나죠?
가비지 컬렉터 들어올 거고
더럽게 느려질 거 아니까
근데 그럴 이유가 없다는 거야. C#에서는
struct를  사용하는 순간
그거는 벨류 타입이고
그거를 매개변수로 전달하는 순간
카피가 일어나던가
아니면 C++에서 그런 거를 전달하면서
레퍼런스 전달하듯이
스택에 있는 거를 그런 식으로 전달해서
어떻게든 속도를 빠르게 하는 게 가능한 거죠
그리고 이게 그 구조체에 만약 
Guid 하나만 들어가 있어요. 예를 들어서 
그러면 C/C++ 하신 분들은 이게 어셈블리어로
어떻게 될지 대충 머리 속에 감이 오잖아요
그냥 내가 Guid 하나 전달하는 거나 
struct 하나 만들어서 전달하는 거나
어셈블리 레벨 내려 가면 
최적화만 잘 된다면 
거의 똑같아야 돼요
실제 성능의 저하는 없는 게 정상이야
그게 성능의 저하가 있다
그러면 이제 마이크로소프트 열심히 따구리 쳐 갖고
고치라고 해야 되는 거죠
근데 마소도 C#의 struct 얘기하면서 
매개변수 전달하는 얘기하면서
이럴 때 성능이 좋고
막 이런 비교 다 해 놓은 게 있어요
(마소가) 제대로 해 놓은 거야
그러면 여기서 또 한 가지 할 말은 
struct를 패스를 해요
그러면은 이게 
'아, 매개 변수를 그냥 패키지로 만들어 가지고
한 번에 패스 하는 거구나'
단일 매개변수더라도 그냥 스트롱 타입
struct로 만들어 갖고 패스 해 버리는 거구나
그럼 실수할 일이 진짜 정말 줄어들어요
처음에 struct 작성하는 비용만 좀 들지만
사용하는 사람들 비용은 거의 안 들어가게 돼요. 그죠?
그럼 여기서 한 가지 문제가 생겨요 
아, 내가 어떤 개체를 패스를 했어
그 개체를 패스했을 때
함수 안에서 또
struct 개체 속을 바꿀 수도 있잖아요
그런 기분이 나빠요
왜냐면은 나는 매개변수를 전달한 게 순수하게 int라던가
float이라던가 그냥 전달을 한 거고
그걸 바꿀 걸로 생각하지 않거든요
뭐 네가 바꾼다고 내 쪽에서 바뀌는 건 아니지만
나는 순수하게 데이터를 그냥 전달해 주려고 한 거야
이거를 무슨 상태를 유지하고 나중에 바꾸고
일반적으로 생각하는 개체의 개념이 아니라고요
개체는 상태를 가지고 
함수 호출을 통해서 상태가 바뀌는 게 중요한 거잖아
우리가 struct를 사용하는 이유는 
순수 데이터 덩어리야
데이터 저장소도 아니야
그냥 전달할 때 쓰는 거야
이거거든? 
이럴 때 사용할 수 있는 게 또 있어요. C#에...
readonly struct
읽기 전용 struct
한 번 만들면 속의 내용을 절대 못바꿔요
자, 그러면 실제 내용을 바꾸던 말든
어셈블리 레벨에서는 큰 차이가 없어요
근데 C#에서 struct를 readonly로 만드는 순간
그 순간 컴파일러는 알겠죠?
아, 얘는 순수하게 정말 스택에 값 복사하고
그거 사용하는 게 목적이구나
그 외에 별 다른 생각 안 하는구나
복사할 필요도 없고 
아무 신경도 안 쓰는구나
딱 알죠?
그래서 readonly로 만들고
그런 식으로 매개변수 전달하는 순간
최적화란 최적화는 다 해줄 수 있겠죠
그래서 최적화가 돼요
C#에서 readonly struct 사용해서
스트롱 타이핑
타입을 굉장히 강하게 만드는 거
굉장히 구체적으로 만드는 거
잘하면은 제 생각에는 
정말 이상한 실수 하는 사람들
꽤 많이 잡을 수 있을 거예요
나중에 함수 시그내처 바뀔 때도 
타입 자체가 바뀌거나
아니면 타입이 들어간 위치가 바뀌어 버리니까 
컴파일 에러 다 나겠죠?
컴파일시에 다 잡을 수 있어요
뭐 이거를
그거 잡기 위해서 뭐
유닛 테스트를 많이 만들면 됩니다
왜? 굳이? 
그냥 함수 시그내처가 다 해주는 건데?
거기다 스트롱 타입 집어 넣으면 다 끝나는 건데
그리고 C#에서는 성능저하도 없는데?
왜 그걸 굳이 시간을 쳐 부어서
그런 매개변수 제대로 넣는 거 까지
유닛테스트를 작성해야 돼? 
말이 안 되죠
자, 이렇게 언어 설계가 잘 되고
그리고 정말 막으려고 하는 문제와
그걸 어떻게 풀려고 하는 해법
그리고 해법이 배보다 배꼽이 안 크게 하는 법
이거를 다 알려면요
하드웨어 다 알아야 되고
언어 다 알아야 되는 거고 
막 이렇게 다 알아야 하는 거지만
그거를 알면은 그 회사에 맞는
적당한 해법이 나올 수가 있어요
이런 식으로
자, 제 개인적인 입장에서 
이 해법이 정말 뛰어나고
내가 정말 종하는 해법이냐? 
아니요. 저는 그것보다는 
훌륭한 프로그래머랑 일하는 걸
더 좋아하기는 해요
그러나 어쨌든 간에 주니어가 들어오면서
주니어가 뭔가를 덜 망가뜨려야 하는 상황
누군가가 리뷰를 열심히 봐줄 수 없는 상황
그 주니어는 잘 하면 성장을 하겠죠
그러나 어쨌든 간에
처음에 실수로 막아주는 방어는 있어야 되고
그 방어를 시스템적으로 만들려면 
이런 방식이 있다
그 방식을 보고 어떤 주니어가 
'왜 이거 왜 이렇게 불편할까?'
그 고민을 하고
'아, 이게 이래서 불편하구나' 라고 깨달으면은 
훨씬 좋아지는 주니어고
이걸 보면서 
'아, 불편하구나'
'불편한데 뭐 내 알일 아니니까 그냥 사용해야지'
'그냥 이렇게 사용하면 돼' 라면서 사용하다가
아무 생각 없이
나중에 뭔가 좀 더 중요한 일 하라고 
좀 더 자유를 줬어
그 순간에 딱 뽀갠다면은 
이 사람은 시스템을 보면서
왜 그 시스템이 있는지
고민을 하지 않는 사람이죠
그러면 역시 발전 가능성이 있는지 없는지도 알겠죠
자, 얘기는 중구난방적으로 많았어요
그러나 OOP가 나왔던 이유
그중에 하나가 프로그래머가
다양한 거를 망가트리지 못하게 하는 거다
라는 얘기를 했고
그런 거를 하는 방법 중에 하나가 
지금 제가 말씀드린 것처럼
굉장히 구체적인 타입을 사용하게 강제하는 거
그래서 모든 게 개체화가 되고
모든 게 클래스가 되는 게 방식이었다
그 방식이 있고
실제  대기업에서 많이 보이는 방식이고
소규모기업 뭐 이런 데서는 좀 잘 안 하는 이유가
그거 하나하나 하기 힘들기도 하고
잘하는 사람들이 모여 있는 소규모 회사일수록
그 성능저하를 받아들이기가 
너무 힘든 거예요
그래서 못했지만
 C# 같은 훌륭한 언어가 있다면 
충분히 할 수도 있다
라는 말씀을 드릴게요
저도 시도를 해 볼 거고 
장점은 다 얘기한 거 같으니까
단점이 나오면은 
그때 또 다른 비디오를 만들던가 할게요
참고도 이것도 UX의 일부예요
내 프로그래머는 어떤 사람이냐
그 사람들이 실수를 하지 않을려면 
어떤 시스템을 줘야 되고
그 시스템이 제대로 돌 수가 있느냐?
그 사람들이 얼마나 시간을 낭비하느냐?
그걸 하기 위해서 시스템 만드는 사람들이 
시간을  얼마나 낭비하느냐?
그러면 그 시스템을 만든 사람이 낭비하는 시간을
어떻게 보상해 줄 수 있느냐?
저는 그 해답을 아까 코드리뷰 볼 거리가 확 줄어든다
라는 얘기로 조금은 드렸죠
어쩄든 뭐 그렇게 다양한 얘기를 했고
중간에 말도 엄청 빠르게 했으니까
대충 이 정도로 끊겠습니다
포프였습니다
