네 안녕하세요 포프입니다
오늘 이야기해 볼거는 C#에 대해서 한번더 이야기 해보려해요
사실
얼마전에는 그냥
뭐하다 든 생각인지는 모르겠는데
뭐하다가 든 생각인지는 말할 수 없을거 같고요
기업비밀이 좀 있기때문에
제 기업말고 다른 기업
얼마전에 그런 생각이 한번 들었어요
C#이 C++보다 더 빨라질 수 있겠구나
라는 생각을
일단 뭐
몇 가지 잘못 생각하시는것들에 대해 이야기좀 할게요
흔히들 생각하시는 것이 C#이 C++에 비해 너무 느리다
그렇진 않아요
느리긴 느려요 현재로썬
아무래도 C++에서
처럼 이렇게 직접적으로
하드웨어나 메모리 주소를 접근하거나
메모리 관리를 직접하거나
그런게 아니기 때문에
당연히 C++가 C# 보다
빨라요 현재로는
근데 그것도 뭐 당연히 어떻게 짜느냐 나름이겠지만
근데 뭐 C++는 당연히
여러가지 위험이 존재하죠 메모리를 잘못 건들면은
메모리 릭도 생길 수 있고 뭐 이것저것 할 수 도있고
뭐 근데
C#도 Virtual Machine 때문에 메모리 릭이
여전히 생길수 있다 이런 이야기도 있는데
뭐 C++로
난리 칠 수 있는 것보다 C#으로 난리 칠 수 있는것이 훨씬 적기 때문에
여전히 C++가 위험성이 더 많죠
그리고 C#은 아무래도 개발 속도도 빠르고
툴도
개발툴도 아무래도 C++보다 좀더 낫고요
뭐 그 이유는 사실
RTTI, Runtime type
뭐지? 그 RTTI가?
Runtime Type Information
Runtime
Type
Information
그것 때문인데
그것 때문에 여러가지
컴파일러
컴파일러? 툴
IDE, IDE에서 지원 할 수 있는 그런 여러가지 도구가 많은거죠
뭐, 뭐든간에
느리긴 느려요 근데 제가
얼마전에
작년인가
한 리서치 작업중에
복셀 에디팅이 있었거든요 복셀로 에디팅하는
그거를 했었는데
저 C#으로 발랐거든요?
C# 하고 이제
DirectX 내부적으로 해가지고 SharpDX 인가?
SlimDX인가? SharpDX 였던거 같아요
SharpDX 써 가지고 그걸로 프로토타입을 하나 만든게 있는데
마틴 큐브나 이런거 엄청나게 했었는데도 불구하고
속도가
그렇게 느리지 않았어요
물론 C#에서는 Parallel for가 자동적으로 지원이 되기 때문에 그런걸 훨씬
CPU도 거의 90%, 100% 이용할 수 있는 장점도 있고
굉장히 프로토타입 한것도 빨랐고
개인적인 거에서는 물론 C++로 갔으면 한 최소 10% 많으면 20% 정도 까지도 속도향상이 있을수 있었을 텐데
그래도 C#이 그렇게 느리지 않았고 충분히 쓸만한 정도 였어요
심지어 툴을 다 이걸로 만들어도 되겠구나
그 생각까지 했으니까
근데 현재 C++가 빠른 이유가 역시 기계어로 컴파일이 된다는 거자나요.
언어 자체도 기계어로 곧바로 컴파일 하기가 좋은 언어고
그래서
타겟 플래폼 용으로 최종 instruction set 이라고 있잖아요
CPU에서 지원하는 move, add, multiple
right shift, left shift 이런거 부터 시작해서
그 안에 벡터 유닛이 있으면
원래 float
타입 하나에 계산해야 될것을
float 4개를 한번에 써서 한번에 계산하는 그런 뭐 SIMD라고 하죠?
그런것도 있고
그런걸로 컴파일이 되서에요
근데
여기에 이 문제점이 새로나온게 뭐냐면 제가 최근에 생각하게 된건데
사실
PC용으로 게임 만드시는 분들은 보면은
그 VisualStudio 안에 보면은
instruction set을 어떤거를 지원할건지를 고를수 있는 옵션이 있어요
거기보면은 SSE1을 지원하겠다 SSE2를 지원하겠다
그 다음에 나온게 또 뭐있죠
SSE3하고 SSE4도 나왔던거 같고 4는 모르겠다 3는 있었던거 같은데
그리고 또 뭐에요
BFX인가 AFB인가
뭐 새로운거 있어요
예전에는 뭐 2개 동시에 하는거 있으면 이번에는 4개 하고 16개를 한꺼번에 할 수 있는 뭐 그런것들
그런  instruction set을
사실은 인텔 쪽에서 굉장히
리써치를 하면서 계속
발전을 시키는 거거든요 그러면 AMD는 자기네 자체 규격이 있었다가도
인텔 CPU가 워낙 dominant(지배적) 하니까
시장 규모가 크니까 인텔쪽으로 많이 지원을 하면 자기들도 인텔  instruction set을 지원을 해야되요
근데 그거를 지원하는데 AMD는 완전 뒤쳐져 있거든요
약간씩
그래서 인텔은 계속 이거를 새로운것을 만들어 나아가고있고
근데
어 그래 그러면 인텔의 새로운  instruction set 용으로
컴파일을 해보자 라고 생각을 했을 때는
그 컴파일러 옵션을 고쳐야 되잖아요
그럼 이게 기계어를 뱉어내줘요
근데 문제는 이거를
AMD 아니면 더 옛날 CPU 이걸 새로운걸 지원 안하는 CPU에서 돌리면 당연히 안돌아요
그래서 C의 문제는 그러면 어떻게 할꺼냐 그럼 EXE 파일을 각 플랫폼 마다 만들어 줄꺼냐
그러는 사람은 거의 없죠
왜냐하면 새로운 EXE파일을 만들때 마다
QA 새로 해줘야되고, 테스트 새로 해줘야되고 이것저것 다른게 있을 수 가 있으니까
그만큼 QA비용이 높아지기때문에 안그런다고요
그래서 보통 저희가 하는거는
그니까 내부적으로 돌릴게 아니면 그렇게 외부적으로 가져다 팔거면은
가장 낮은
instruction set을 고르죠
지금 현재 왠만한 CPU는 다
SSE1은 당연히 지원할거고 SSE2도 지원할거에요 아마
그래서 SSE2 정도로 맞춰놓고 컴파일해서 보내요
그러면
정작 아무리 고성능 CPU가 있더라도
이거의 가능성은 훨씬 높은데 그거를 충분히 못살리는거죠
실제 그것보다
어떠 프로그램에 따라 틀리겠지만
벡터라이제이션만 잘해도
계산을
floting 하나하나 4개를 할것을 16개 한꺼번에 해도
이론적으로는
4배 6배 8배 성능향상이 있지만
사실적으로는 20% 30%의 성능향상이 충분히 있을 거에요
특히 계산이 많은 프로그램 일수록
뭐 물리같은것도 좋은 예 일수있고
에니메이션도 좋은 예 일수있고 여러가지가 있겠죠
그러면 이거를 c++쪽에서 어떻게 해결할거냐
쉽지가 않아요 정말 EXE파일 가져다 주는것도 그렇고
그렇다고
EXE파일을 예를들어 SSE2 지원하는거 하고 SSE4 지원하는거를
두개를 만들어 놓고
바이너리를 하나 합친다음에
실행할때 어떤건지를 확인해서 이쪽 바이너리로 점프를 해서 실행하는것도 애매하고
그럼 EXE파일이 두배가 뜨니까 그러면 c++ 쪽에서는
쉬운 해결방법이 아직은 없어요
물론 제가 들은 바로는
이제 그런걸 해결하려는 움직임은 있어요
근데 그거야 당연히 컴파일 제조하는 회사쪽에서 많이 도움을 해줘야 되는거고
CPU 칩 메이커 쪽에서도 아무래도 많은 도움을 줘야겠죠
공동작업으로 이루어지지 않을까 혼자 생각은 해요
근데
C#으로 가면 그게 훨씬 간단해져요 C#은
컴파일 랭귀지가 아니거든요
C#은 뭐냐면은
C#으로 짜놓은 언어가 있으면 거기서  Intermediate Language라고
MSIL이라고 할거에요  Intermediate Language라고
그냥 다른 언어로 코딩을 만들어 놓는거에요
그리고 실제 최종 타겟 플랫폼에서 실행을 할 때
그거를 보면서
여기서는 SSE4를 지원하는 플랫폼 이니까
이 float 계산 4개 5개 6개를 하는거를 한꺼번에 뭉쳐 가지고 한번에 돌려야지
그리고 중간중간에 이제
그런식으로 바이너리 인젝션이 가능 하다고요
한마디로 실행시키는 동안에 컴파일을 하는 느낌과 같은건데
그럼 결과적으로 이거는
고성능 하드웨어의 효과를 즉시즉시
이용할 수 있다는 거에요
물론 이게 그렇게 쉽진 않죠 왜냐하면은
벡터라이제이션 같은걸 할 때는 당연히 다른 코드도 같이 분석을 해서
아 이게 6개 7개 같이 계산을 하는거니까 하나로 묶어도 되겠구나
그러고 이거를 하나로 묶어도
예를들어서 배열이라면
배열 두번째 요소가 첫번째 요소의
계산값을 다시 쓰지 않는구나
이런것도 생각을 해야되거든요
8개를 한꺼번에 더하기를 시키는거하고
첫번째 배열요소에 무엇을 더하고 그 값을 가져다가 다시 더하는거 하고는
결과가 틀려지니까
그런 알고리즘도 돌려야되고
그래서 여러가지 따져보면은 쉽진않아요
그러고 당연히 C++ 컴파일러가 시간이 오래걸리는 것도 그런짓을 하기 때문이에요
C++ 현재 컴파일 타입을 보면은 굉장히 길잖아요
그 긴것을 따졌을때
당연히
그런 분석을 확실하게 C#에서 돌리기 까지는 아직은 무리가 있겠다 생각은 들어요
근데 모르죠 시대가 지나가면 지나가고
CPU 백터라이제이션이 정말 미친듯이 올라가고 뭐 한꺼번에 100, 200개 정도 계산할 수 있다거나
그렇게 되면은 아주 간단한
그런 알고리즘을 돌리는 것만으로도
C#의 성능이 C++에 가까워 질 수 있겠다 라는 생각은 해요
어쩌면 더 빨라질 수 도있고
근데 그거는 좀 먼 미래 같기는 한데
컴퓨터 쪽에서 먼 미래라고 해봐야 5년, 10년일 수 도있고
C# 뿐만이 아니죠  JAVA도 마찬가지인데
마이크로소프트만큼 컴파일러를 제대로 만들 수 있는 회사가 두 셋 밖에 없기 때문에
그냥 일반적으로 C#이라고 하는거에요
C#쪽에서 발전이 엄청나게 되면은 C#도 괸장히 좋은 언어가 되겠라는 생각은 해요 성능쪽에서
뭐 그래도 여전히 문제가 되는거는 두가지 있죠
가비지 컬렉터
두가지가 아니구나 가비지 컬렉터가 약간 좀 문제죠
C#에서 그 문제는 아직도 남아있겠지만
가비지 컬렉터나 레퍼런스 카운팅에 대해서는
다음기회에 이야기 하기로 하고요
좀 할말이 있기 때문에
그래서 오늘 하고 싶었던 말은
C#이 빨라질 수 도 있구나
그럴 수도 있겠다 라는 생각?
왠만하면 써보세요 굉장히 좋아요
저는 5년안에 모든 게임을 C#으로 만들 수 있다고 생각은 해요
가능하지 않을까 싶어요
물론 역시 가비지 컬렉터만 좀 제대로 어떻게 해주면
오늘은 그정도고요
다음엔 또 다른 주제로
찾아 뵙지요 할말은 많아요 아직도
예 포프였습니다
