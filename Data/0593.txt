안녕하세요, 포프입니다.

저번 편에는 '왜 ChatGPT가 생각보다 개발자한테 큰 도움이 되지 않냐?'라는 얘기를 했어요. 그러면서 제가 했던 얘기가 GitHub Copilot이 훨씬 지금 좋은 거고, 그리고 가성비로서는 지금 가장 훌륭한 도구 중의 하나예요.

왜냐? GitHub Copilot은 기본적으로 IDE하고 연동해서 사용하는 게 정석이예요. 그래서 Visual Studio가 되던 Visual Studio Code가 되던 IntelliJ가 되던 IDE와 함께 연동됩니다. 그러면 내가 코드를 작성하는 순간 화면에 회색으로 '네가 작성하려는 코드가 이거지?' 하면서 어떤 코드를 제시해 줘요. 그럼 빠르게 보고 '어? 이거 내가 원하는 거랑 80% 맞는데?' 싶으면 탭을 치면 완성해 줘요. 그러면 컴파일해 보고 조금 고쳐서 내 스타일에 맞추고 넘어가면 거의 끝나요. 이게 함수 통째로 해줄 때도 있고 한 줄 해줄 때도 있고 한 블록 시켜 줄 때도 있어요. 근데 치는 순간 내가 원하는 게 아니다? 그럼 그냥 계속 쳐요. 그러다가 어느 순간 원하는 게 나오면 그때 받으면 되는 거예요.

이게 ChatGPT보다 빠른 이유가 뭐냐? 내가 키보드를 치고 있는 순간 그 화면에 코드를 완성해 주고 나는 그걸 받아들이는데 키 스트로크 한 번이면 돼요. ChatGPT처럼 물어보고 알려주고 검증해 가면서 쓰는 게 아니에요. 그냥 그 순간에 완성을 시켜줘요. 그러면 실제 ChatGPT 한 번 사용할 시간에 내가 타이핑 막 치면서 Copilot이 제시한 걸 보고 검토하는 걸 최소한 대여섯 번은 할 수 있어요. 그리고 나면 내가 원하는 결과의 80%가 나오지만, ChatGPT는 한 3~4번은 왔다 갔다 해야 결과가 나올 수도 있고 아닐 수도 있어요. 3~4번 했을 때 아마 내가 원하는 결과의 한 50% 정도가 나올 거예요. 나는 그동안 15~20가지 선택지를 보고 이미 80% 이상의 품질로 완성할 때예요. 그러면 속도 차이가 어마무시하거든요? 그래서 Copilot 쓰시는 분들은 거기서 잘 벗어나지 않아요.

그러면 'Copilot으로 뭐가 되냐?'가 일단 궁금하잖아요? 일단 그걸 알아야 얘기할 거 아니에요? 생각보다 당신이 원하는 걸 굉장히 많이 해줘요. 많이 일어나지 않지만 가장 이상적인 시나리오, 내가 어떤 함수 안에서 보통 코드를 작성하고 있어요. 작성하는 순간 함수의 코드를 Copilot이 이해하고 '네가 이런 코드를 완성하려고 하는구나? 맞네?' 이렇게 받아들일 때가 있어요. 하지만 언제나 이렇게 돌진 않아요. 함수 이름이 좀 구릴 수도 있고, 아니면 여러 가지 이유 때문에 이 AI가 약간 뽕을 맞췄을 수도 있고요. 그래서 그다음에 하는 건 주석을 달아요. 이제 여기 추가할 코드가 뭔지 주석을 달아요. '이런 걸 해서 저런 걸 할 거야.' 그리고 실제 타이핑을 몇 개 치다 보면 제대로 완성해 줄 수도 있고 아닐 수도 있어요. 결론은 빨라요. 완성 안 시켜주면 내가 계속 치면 돼요. 끝.

그리고 또 다음 거는 뭐였냐면 어떤 함수의 시그니처를 내가 만들어요. 새로 만든 함수예요. 예를 들면 어떤 텍스트 파일 다른 걸로 변환하는 거, 자막 파일 SRT를 SBV로 변환하겠다? SRTtoSBV 해서 string 들어오는 거 입력 하나 있고 string 나가는 거 출력 하나 있고, 그리고 실제 치기 시작하면 뭔가를 멋지게 완성해 줘요. 실제 저한테 있었던 일이에요. 근데 왜인걸? 틀렸네? 두 줄 쳤는데 또 완성 안 시켜줘요. 완성했는데 틀리네? 이랬어요. 그래서 기분이 나쁜 거예요. 그래서 SRT 실제 파일에서 한 6줄 7줄을 복사해서 주석으로 달고 그리고 위에 SRT 예제라고 쓰고, SBV에서 또 이제 6줄 복사해서 붙여놓고 SBV 예제라고 썼어요. 그리고 아래 가서 딱 키보드를 치기 시작하니까 제대로 완성해 주더라고요. 실제 SBV에서 SRT를 옮기는 과정을 하나하나 String Parsing하고 디버깅하고 하면 좀 시간은 걸리거든요? 그것보다 훨씬 빨리 처리했죠.

그리고 또 됐던 게 뭐 하나가 있냐면 어떤 정형화된 json 데이터 파일들. 그걸 보다 보니까 우리가 json을 쓸 필요가 없어요. 그냥 언제나 코드를 바꾸더라고요? 그래서 '이거는 바뀌지 않는 데이터니까 코드로 그냥 들어와야겠다.' 그래서 그거를 약간 배열 같은 걸로 바꾸려고 했는데 하나하나 치기 귀찮잖아요? JSON 갖고 와서 주석 처리해 버리고 위에 데이터 구조체 조금 쳐주니까 완성해 줬어요. 이런 거 있었고, 그리고 또 하나는 저희가 프로세싱을 돌리는 게 있는데 거기에 약간 잘못된 것이 있고 그걸 고칠 방법은 없는 데이터가 있었어요. 그래서 이 데이터는 무시하고 넘어가는데, 모든 데이터를 무시하고 넘어가면 나중에 우리가 실수를 발견했을 때도 assert가 나지 않으니까 assert는 유지하고 '단, 이런 케이스, 파일 이름이 요렇고 요런 문자열이 있을 때만 이거는 우리가 이미 검토한 거니까 넘어가자'라는 식으로 배열을 만들고 있는 게 있었어요. 그리고 그 배열에 넣을 때 한 줄 넣어놓고 막 하다가 데이터 돌리다 보면 어디선가 또 딱 오류가 터지잖아요? 그럼 오류 메시지가 있잖아요? 그 오류 메시지를 주석으로 복붙해 놓고 아래 한 줄 추가하려고 배열에 엔터 치니까 또 완성. 거의 90% 맞게 해 주더라고요.

그래서 이런 식으로 Copilot은 어떤 단순한 일들 데이터를 A에서 B로 옮기는 일들을 굉장히 편하게 해주기도 하고, 코딩할 때도 이미 많이 정형화된 코딩들, 아까 SRT를 SBV로 변환하는 경우, 그런 경우들도 많이 해줘요. 잘해줘요. 그리고 그게 아니라 '이거를 얘가 어떻게 알고 하지?'라고 하는 것까지도 꽤 해주는 게 많아요. 얘도 틀릴 수 있어요. 처음 주는 답은 제 생각에는 틀릴 확률이 50% 이상이에요. 하지만 대여섯 번을 받다 보면 80% 이상 맞는 답이 나와요. 그리고 대여섯 번 가는 과정이 어떤 개발자의 타이핑 치는 순간을 방해하지 않기 때문에 가능한 거예요.

이제는 Copilot 제 주변에서 많이 써요. 제가 많이 추천도 해주고 모르던 사람한테 추천하고 '써보세요'하는 사람도 있어요. 실제 자기가 뭘 원하는지 아는 사람들은 굉장히 Copilot을 좋아해요. 이게 무슨 얘기냐면 잘하는 인터미디엇도 똑같고 시니어급까지 가면 내가 어떤 일을 받으면 그 일을 모르면서 코딩을 어마무시하게 짜진 않아요. 못해도 한 인터미디엇 정도면 50% 이상은 대충 알아요. '내가 이 정도로 작성하고 이건 모르는 거니까 좀 더 보자' 이런 식으로 한 내가 원하는 코드가 정확히 어떤 건지를 50~80% 정도 알고 있기 때문에 뭘 하는 순간 Copilot으로 굉장히 빠르게 검수가 가능한 거예요. 근데 Copilot을 줬을 때 그것 때문에 '힘들어서 안 쓰겠다'라고 하는 개발자도 있었어요. 그 개발자가 경력이 적은 개발자가 아니었는데 그랬어요. 근데 나중에 한참 지나고 나서 보니까 이 개발자가 다른 걸로 문제들이 여러 개 생겼는데, 결과적으로는 뭐였냐면 우리가 이제 흔한 말로 하는, 약간 장난처럼 말하는 거죠? 난독증이 있으신 분이에요. 이걸 좀 더 정상적인 용어로 말하면 정보 습득 능력이 굉장히 느렸던 거예요. 그리고 내가 뭘 작성해야 하는지 모르고 시작해요. 그러면 처음 코드를 작성해서 3개, 4개 키보드를 쳤는데 처음에는 뭐가 나와요. 그러면 나는 이게 내가 원하는 거랑 맞는지 아닌지도 내 생각이 없으니까 모르겠고, 일단 읽는 거예요. 읽는데 코드 읽는 속도가 느려요. 그래서 그거 읽고 '아니네?' 그리고 무시하고 또 치고 두 글자 치면 또 나와요. 또 읽고 '아니네?' 읽고 '아니네?' 하는데 읽는 과정, 그게 너무 오래 걸릴 거예요. 그래서 오히려 자기들 속도가 안 나온 거예요. 그에 비해 잘하는 사람들은 뭐냐면 내가 세 글자를 치고 글자를 보겠다는 생각조차 하지 않아요. 그냥 내가 지금 이거를 읽는 것보다 빨리 칠 수 있는 부분이 있을 거예요. 그럼 거기까지 막 쳐요. 그게 보통 한 줄, 두 줄, 세 줄 정도 수준이에요. 그리고 나서 이제 제시하는 게 좀 더 정확할 가능성이 높거든요? 그럼 그때부터 이제 고민해요. 근데 그것도 이미 머릿속에 있는 것도 있고 타이핑이 빠르고 '내가 원하는 게 뭔지 안다'는 분들은 정보 습득력도 빠르신 분들이에요. 코드는 빨리 읽어요, 정말 이상한 코드가 아니라면. 그럼 읽고 버리고 읽고 버리고 읽고 취하고가 되는 거예요. 근데 여기에 도달하지 못하신 분들은 일단 정보 습득력도 동일 경력자 대비 느리고, 습득을 남들보다 훨씬 덜 했을 거기 때문에 내가 원하는 게 뭔지 모를 가능성도 높고 똑같은 양을 읽었을 순 있어요. 집중해서 읽지 않았기 때문에 모르는 걸 수도 있고, 아니면 남들보다 패턴 인식이 늦어요. 그래서 남들과 정말 동일한 데이터를 동일한 집중도로 읽었음에도 불구하고 결론을 못 내렸기 때문에 비슷한 일이 나오면 '어떤 거를 해야겠다'는 원칙없이 진행하다가 그런 문제가 생겼을 가능성도 있어요. 그래서 이게 여러 가지가 솔직히 겹쳐 있어요. 근데 제가 Copilot를 줬을 때 결과적으로는 잘하는 분들은 잘했어요. 근데 '잘하는 분들의 정의가 뭐냐?'라고 물으면 이분들은 내가 이 일을 할 수 있는데 이거를 타이핑 치고 뭐 하는 게 오히려 물리적인 시간이 너무 드는 거예요.. 지적으로 힘든 게 없어요. 물리적인 시간이 너무 들어요. 그런 경우에 일반적으로 이 분들이 하는 게 뭐예요? 자기 밑에 사람한테 그 일을 줘요. 그 일을 지시하고. 그러면 밑에 사람들은 그 일을 해요. 근데 문제는 사람과 사람이 대화하다 보면 의사소통 문제가 생기죠? 그러면 그 의사소통 문제를 깨달은 데까지 시간이 걸릴 수도 있고 그게 코드로 들어왔을 때 코드가 잘못돼서 리뷰를 보고 고쳐가는 과정일 수도 있어요. 결과적으로 물리적으로 시간이 드는 시간? 누군가의 시간이 들고 아까 지시했던 잘하는 사람들은 나중에 또 보고 고쳐줘야 하는 거죠. 그러면 얘랑 Copilot을 비교했을 때, 집중력을 비교했을 때 잘 생각을 해봐요. 그러면 되게 재밌는 결론이 나오고 아마 그것 때문에 지금 잘하는 프로그래머들이 Copilot을 굉장히 좋아하는 걸 수 있어요. 그게 뭐냐면 Copilot은 일단 내가 코드를 작성하는 동안에 거기에 집중하고 있는 거고 거기서 일을 끝내버리면 다시 볼 일이 없어요. 집중이 깨지는 문제도 없고, 집중이 흐트러질 때마다 시간이 낭비된다고 그러잖아요? 그 순간에 끝나버려요. 그리고 그게 왔다 갔다 하는 시간이 이미 내가 힘들게 작성해야 하는 코드, 내가 10분 동안 작성해야 하는 코드를 1분 안에 검토가 끝나고 추가 1분에 디버깅하고 끝나는 정도의 시간이 돼요. 이걸 남에게 주면은 내 시간 10분을 아낄 수는 있어요. 허나 그 사람한테 일을 지시할 때는 최소 2, 3분의 시간이 걸릴 거예요. 거기서 끝나면 다행인데 잘못 일을 해올 가능성이 생각보다 꽤 높아요. 그러면 잘못 일하면 검토해 주고 뭐하고 하면 '내가 처음부터 짜는 게 더 빨랐을 수도 있겠는데?' 이런 생각이 드는 경우들이 있어요. 하지만 '밑에 사람들이 성장을 해야지만 내가 일이 편해진다'는 게 있기 때문에 여전히 일 잘하시는 분들은 밑에 사람들한테 얘기해 주고 멘토링을 하는 것뿐이죠. 또 하나의 문제는 이렇게 백날 멘토링을 해줘 봐야 나아지지 않는 사람들도 은근히 많이 존재해요. 그럼 어느 순간 일 잘하는 분들이 사람 피하는 경우들이 있어요. 그게 뭐냐면 이게 약간 좀 밑 빠진 독에 물 붓기가 되어버리는 거예요. 일을 줬어요. 그 사람이 일을 대충 해와요. 내가 지적하고 뭐하고 뭐하고 해서 고쳤어요. 다음에도 비슷한 일을 줘 똑같은 일이 반복돼요. 이 시니어가 나한테 일을 주고 내가 이 정도 퀄리티로 일을 해가도 이 시니어가 고쳐주는 게 이제 당연한 것처럼 여겨지는 거예요. 그냥 회사의 프로세스인 거예요. 그럼 시니어는 어느 순간에 '저거 내가 하는 게 더 빠른데 왜 남을 주고 있지?' 근데 그걸 한다고 하면 또 PM들이 말리거든요? '그걸 왜 네가 해? 그 쉬운 일을.', '내가 하는 게 더 빠른데?', '아니야 아니야. 그렇지 않아', '실제 빠른 거 같은데?' 근데 Copilot을 딱 줘요. 그러면 그 문제가 사라지는 거예요. 시니어라고 하면 밑에 사람들 못하든 잘하든 한 대여섯 명을 멘토링해야 하는 느낌이었는데, 이제는 잘하는 한 사람만 멘토링해도 되는 세상이 와버리고 있는 거죠. 그게 차이가 생기는 거예요. 되게 웃기죠? 이게 좀 무서운 거더라고요.

여기까지 얘기하면 이제 왜 시니어들이나 이런 사람들이 Copilot을 잘 사용하는지 알았죠? 근데 여기서 보면 대충 이 Copilot이 일 잘하는 분들한테는 굉장히 큰 도움이 되지만 'AI의 미래' 에피소드를 공유했을 때 나왔던 '우리의 일은 생각보다 그렇게 빨리 없어지지 않아요.'라고 했는데 갑자기 '어? 내 일은 없어질 것 같은데?'라는 걱정을 하시는 분들이 생길 수 있죠? 그게 왜 그렇게 되는지는 비디오가 길어지니까 지금 말은 못 하겠고, 다음 편 또 하나 만들어서 거기서 좀 더 얘기하는 게 좋을 것 같아요. 지금 있는 Copilot과 그것 때문에 주니어 프로그래머들, 아니면 타이틀은 인터미디엇인데 사실 하는 일은 주니어급인 프로그래머들한테 미치는 영향들. 그러지 않기 위해서는 Copilot을 어떻게 좀 더 사용해야 위험성이 없는지. 왜냐하면 Copilot이나 ChatGPT나 이거 통해서 짧게는 6개월, 길게는 평균 1년 그리고 더 길게는 3~4년까지도 자기 실력보다 좋은 대우를 받을 수 있는 가능성은 충분히 있어요. 그 뒤에 장기적으로 봤을 때 갑자기 일이 없어지거나 아니면 내 미래의 대우를 너무 앞당겨 받아서 전체적인 대우가 안 좋아지는 경우도 생길 수가 있거든요? 이거에 대해서는 다음 편에서 말하도록 하겠습니다.

포프였습니다.