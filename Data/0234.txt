안녕하세요 포프입니다
굉장히 오랜만에 차세대 C++에 대해서 얘기해 보는데
예전에 내가 쓰는 C++ 11 이런 얘기는 몇 번 만들었죠
이걸 이제 제목을 바꿔야 될 것 같아요
차세대 C++, 내가 쓰는.
뭐 어쨌든 오늘 할 얘기는..
모듈
C++에 드디어 모듈이 들어와요
(*정정: C++17에 정식으로 들어온게 아니라
TR로 허가난겁니다.)
C++의 모듈의 개념이 뭐냐면
C++하고 자바, C++하고 C#을 볼 때
큰 차이점이 있잖아요
C++은 헤더(.h)하고 cpp 파일(.cpp)이 분리가 돼 있고
자바나 C#은 그렇지 않아요
그런데 C++에서는 헤더를 잘못 #include하기 시작하면
막 서로 컴파일도 안 되고 뭐 이거 알 수 없네
이게 중복이네 난리가 나지만
C#은 그런 일도 없죠
그 차이가 뭐냐면 C#과 자바는 모듈 시스템이고
C++은 모듈 시스템이 아닌 거에요
모듈 시스템이 뭔지 설명하기보다 C++이
어떻게 돌았는지를 말씀을 드리는 게 편할 것 같아요
C++에는 헤더와 cpp를 넣었죠
헤더에는 뭘 넣는 거였냐면은..
함수 시그너처(Function Signature)
클래스 시그너처(Class Signature)
내 함수는 실제 요런 API가 있고
요런 거를 호출할 수 있고
요런 멤버 변수가 있습니다
cpp에서는 이제 그거에 대한 구현들
이 API는 이 함수로 이렇게 구현했으니까
이게 함수, 함수, 함수
이렇게 구현한 거에요
그런데 다른 파일에서 이 클래스를 써야 된다
그러면은
이 당시에는 #include를 썼잖아요
#include가 뭐냐면,
이 파일에서 이 헤더 파일을 #include 해요 그럼 이거를
copy & paste를 하는 거에요
복붙해요 복붙
컴파일할 때
복붙해서
그럼 아 이 API가 있으니까 나는 얘를 호출할 수 있구나
그럼 컴파일하고 끝
그리고 다른 파일 또 헤더 파일을 참조(reference) 하면은
복붙해 갖고
아 난 API가 있으니까 난 이 API가 있으면
일단 컴파일은 가능해
그러면 object를 만들고
나는 이 API를 호출해야 돼라고
기억을 하는 거에요
그러다가 나중에 아까
implementation(구현)이 돼 있던 파일 있었죠
그게 컴파일 되면
이것도 다른 object 파일이 돼요
.obj라는 파일 형태에요
비주얼 스튜디오(Visual Studio)에서는
그러면 나중에 링크(link) 작업이 있어요
링크(link)는 이 object 파일을 다 모아서 합치는 거에요
합칠 때
어 얘가 이 API의 A란 함수를 호출했었어
근데 내가 어디 있는지 몰라
근데 링크하다 보니까 object 파일에 이게 있어요
아 그렇구나 그러면 이거를
아 그래 너는 얘를 호출하는 걸로 해서
점프 테이블(jump table)이겠죠 보통
어셈블리(Assembly)로
이 메모리 주소로 점프해서 끝
이렇게 컴파일이 됐기 때문에 되는 거에요
그렇기 때문에
근데 문제는 만약에 cpp파일 아까 구현한 게
여기에 include가 된다? 가능해요 사실은
#include 는 copy & paste기 때문에
가능해요
그럼 여기 들어와서 implementaion이
이 API에 A함수가 있고, 이 object에서도 API에 A함수가
있어요 그러면 링크하는 도중에 에라(error)가 나요
어 A라는 함수가 두 번 있어
어떤 걸 써야 될 지 모르겠어
에라(error)
뻗어
뭐 컴파일러 최적화해서 좀 그거를 실제
중복되는 건지 확인해서 제거해줄 순 있겠지만
어쨌든 그래요
그래서 이게 굉장히 좀 복잡했죠 왜냐면은
그러면 이 헤더에서 다른 헤더로 포함해야 되는데 이 다른 헤더는 얘를 포함해야 돼 그럼 그 순간 안 돼요
그럼 그거를 해결하기 위해서
아 헤더를 포함하는 대신에 "이런 게 있어"라고
forward declaration(전방선언)이라고 있거든요
나는 그냥 "이런 게 어딘가 있어"라고 타이핑을 치는 거야
나는 클래스 A라는 게 있어
내부는 모르겠지만 클래스 A라는 게 있고
클래스 A가 있다는 정도로 컴파일이 되면은
예를 들어 포인터(pointer),
레퍼런스(reference) 같은 경우는
점프 테이블(jump table)이기 땜에 그 클래스가
존재한다는 거만 알면은 컴파일은 되거든요
그래서 그런 온갖 꼼수가 나온 거에요
근데 C#과 자바는 어떤 식이냐면
뭐 내부적으론 제가 정확히는 지금 모르겠는데
이런 걸 거에요
C#은 모든 클래스와 implementation이
한 파일에 들어가 있죠
사실 이게 깔끔하고 보기 좋아요
짧고 보기 좋은 건 아니지만
한 군데서 관리된다라는 거에서 보기가 좋아요
그러면 그..
컴파일러라고 해야 되나?
컴파일러까진 아니지만
비주얼 스튜디오.. 뭐 있을 거에요
정확히 제가 개념이 안 잡히는데
거기서
그럼 헤더 파일에 이게 다 있잖아요
그럼 그 정보를 기억을 하고 있는 거에요
그래서
다른 클래스에서 이걸 호출할려고 했다
어 그래 나는 이게 있으니까 링크해 줄게
한 마디로 헤더 파일이라는 거를
자동으로 생성을 해 줬다고 보는 게 맞죠
그리고 이제 뭐
그게 메모리에 있든 다른 파일에 있든
그걸 서로 참조하면서
어 그래 난 이거 파일 있으니까  쓸 수 있어
이런 개념이고
그래서 이제 그 시스템을 C++에 들여오겠다는 거에요
그래서 그 제안이 있었고 C++17에 기능이 들어와요
(*정정: C++17에 정식으로 들어온게 아니라
TR로 허가난겁니다.)
그래서 이제 모듈 시스템이라고 해 갖고
아 제가 파일 확장자는 정확히 기억이 안 나는데
어떤 확장자에서 그 파일을 모두 넣는 거에요
그러면 이제
아니다
cpp파일을 쓰고 모듈 기능을 키면은
얘가 그 cpp파일..
그니까 모든 그 뭐라 그럴까
클래스하고 모든 게 있는 거에서
지가 알아서
그.. 아까 말했던 그..
헤더 같은
자동 헤더를 만들어서 그거를 서로 참조를 하는 거죠
그래서 이렇게 되면은 장점이 뭐냐면
C++의 가장 속도 저하의 요인이 뭐였냐면 컴파일 시에
헤더파일
왜냐면 내가 이 파일에서 헤더파일 10개를 포함했는데 각 헤더파일에서 다른 헤더파일 10개씩 포함해
그러면 파일 긁고 복사하고 붙이는데
막 천 개 include 해 갖고, cpp 파일 하나 컴파일하는데
천 개씩 막 파일 집어 넣어 갖고 하는
그런 경우가 있었거든요?
그래서 그런 거 문제라는 거죠
그래서 그게 그걸 해결해 줄 것 같고
실제 뭐 C#이나 자바의
컴파일 속도가 빠른 것도 그게 커요
그리고 이게 지금 비주얼 스튜디오에 들어와 있긴 해요 2015 지금 버전에
근데 이게 커맨드 라인(Command Line)으로 켜야 돼 
experimental, 실험적인 기능, 모듈 시스템 이런 식으로
그래서 저도 아직 안 써 봤어요 제대로
보면서
아직 experimental인 이유는
C++ 17의 허가가 났는데 최종안이 안 나온 것 같아요
최종안을 아직도 만들고 있어요 그게 나오면
그거 제대로 지원하고 정식 기능으로 뽑을 것 같아요
그러면 제가 다음 C++ 프로젝트를 한다면
모듈 시스템을 쓸 것 같아요 컴파일 시간 때문에
그래서 그 컴파일 시간 해결할려고 막
말도 안 되게 DLL을 만들어 갖고 쉽게 한다거나
별별 짓 다 했거든요 막 유니티 빌드라고 해 갖고
cpp 파일을 100개를 하나로 뭉쳐서 컴파일 한다거나
그걸 고칠 수 있을 것 같고요
제가 봤던 C++ 기능 중에는 가장 맘에 드는 것 같아요
지금은 최근에 나온 기능 중에
그래서 그렇게 돼 있고
그리고 이제
또 이제 C++에서 그러면 한 가지 문제가 되는 게
그러면 우리는 그 #ifdef 했던 거 어떡하냐
엄청 많이 했잖아요 옛날에 막
그..
#define으로 해 갖고 엄청 이상한 짓 많이 한 거
그거 따라 막 헤더 파일 다르게 컴파일 되고
막 이런 것도 있었고
그것도 지금 비주얼 스튜디오 블로그에 나온 거 보면은
지원을 한대요
그래서
제대로 쓸 수 있다
그거는 그냥 #ifdef 해 갖고
컴파일 정도 바꿀 때 얘긴 거 같고
그..
막 함수 대신에 #ifdef로 함수 만드는 경우?
그 경우까진 어떻게 되는지 아직 모르겠어요
그건 좀 더 봐야 될 것 같고
음..
"지금 다 써 봐라"라고 하고 싶진 않아요
그냥 이게 온다는 걸 알고 계시고
비주얼 스튜디오에서 정식으로 지원할 때
그때 한번 써 보시길 바라요
테스트 한번 해 보시고 괜찮은지
제가 여태까지 읽은 바로는
안 괜찮을 이유는 별로 없어요
요 최근 그니까
이상하게 매크로 떡칠 해 놓은 그런 코드가 아닌 이상은
크게 문제가 없을 것 같아요
그래서
아 모듈 시스템 드디어 들어오는구나라는 게 기쁘고
어떻게 구현할지 되게 궁금했는데
다행히 그냥
비주얼 스튜디오에서 컴파일을 하면은
이제 어떤 파일
자기 확장자가 있더라고요
그 확장자로
헤더 파일 자동 생성 해 주고
다른 파일에선 그 헤더 파일 하나 보는 것만으로
아 이게 어떻게 도는구나를 알 수 있게 해주는
그런 방식으로 만들었더라구요
그래서 뭐
결과적으로 좋은 점은
헤더를 손으로 일일이 포함해 줄 필요가 없이
나는 이 모듈을 쓰겠다라고 선언하는 게 전부죠
이 모듈을 쓰겠다 뭐 C#에서 using 이런 걸 쓰듯이
자바에서 import 쓰듯이
그럼 이제 그거를
그게 패키지가 어디 있는지 그런 것들
이제 막 예전처럼 경로 설정 안 해주고
이제 뭐..
IDE...에서가 아니겠죠
경로는 어떻게 설정해
그냥 IDE에서 알아서 해결해 준다?
현재 폴더 안에 들어 있는 모든 그 클래스들의..
그건 좀 더 봐야겠네요
어떻게 모듈 최종 resolve하는지
그것까지는 제가 설명을 못 봤어요
정확히 directory structure가 어떻게 되는지 이거는
제가 볼 때는 자동으로 해결해 주는 것 같은데
C++ 컴파일러 스펙 상에서
뭐 모듈..
아 아니다 있다있다
모듈 폴더를 아마 정해줘야 됐던 것 같애요
그래서 모듈 폴더를 정해 줘 갖고
그 폴더 안에 있는 전부 모듈을 긁어서 알아서 봐 주는
어찌 보면은
그리고 아마 서브디렉토리(subdirectory)도
포함할 거고요
그 정도면은 자바나 C#의 기능과 비슷해지는 거죠
근데 이제 차이점이라면
C++은 기본적으로 reflection을 안 쓰는 게 일반적이니까
reflection 해서 쉽게 얻을 수 있던 모든 장점은
사실 없어지죠
C#은 제가 볼 때는 DLL 파일 그냥 구워버린 다음에
바뀔 때마다
그래서 그게 구워졌으면
파일에 있든 메모리에 있든
그럼 거기서 reflection 뽑아 갖고 어떤게 있는지
다 나오거든요 함수며 뭐며
그래서 인텔리센스(IntelliSense)에서도
쉽게 작동을 했고
크게 없는 거죠 사실은
IDE 수준에서 RTTI 켜 버리고 컴파일 한 다음에
찾아 볼 순 있겠지만
그래도 C#의 reflection 만큼 완벽한 기능은 아니기 땜에
그 정도
그래서 모듈은 저도 되게 관심을 가지고 있고
제가 지금 있는 회사에서도
헤더 파일 잘못 건드리면 컴파일 막 30분 40분 걸리는
말도 안 되는 짓이 일어나기 땜에
뭐 컴파일 타임을
죽이네
뭐 하네
얘기가 많았지만
제가 볼 때는 그 프로젝트도 결과적으론 그냥
모듈 시스템으로 가서 해결할 것 같아요
모듈이 드디어 들어옵니다
여태까지 알고있던 온갖 컴파일 시간 줄이기 흑마법은
별로 필요없는 게 될 것 같아요
뭐 최소한 C++ 신 스펙에서 나아지는 게 있으니까
다행이죠
제가 신 스펙 나오는 것 중에
안 좋게 보는 게 되게 많았는데
가끔 이렇게 노다지가 보일 때 좋아요
예! 포프였습니다
