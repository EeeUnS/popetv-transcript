[음악]
w
이 안녕하세요 포프 입니다 음 가끔
이제 저에 대해 오해하시는 것 중의
하나가 제가 예전에 td 관련
비디오를 만들어서 그런지 몰라도
포프는 캐스트에 반대한다 라는 잘못된
마라시 음식은 분들이 있는것 같아요
하지만 그렇습니다 저는 누구보다
테스트를 많이 하고 누구보다 더
자동화된 테스트를 굉장히 좋아하는
사람입니다 그리고 자동화된 테스트를
안되는것은 수 동안의 테스트까지
열심히 하는 사람 중에 하나입니다
제가 반대를 했던 것은 tdd 라는
방법론 이에요 tv 라는 방법론은
사실은 뭐 테스트에 관한 게 아니라
테스트 주도적으로 개발하는 거다 라고
얘기하는데 그거에 효용성은 이미
증명에 안됐고 20년 30년이
지나도록 그리고 오히려 여러가지
사람들의 행동을 봤을 때 제대로
작동할 수 없는 거다 라고 저는 계속
논의 말을 해 왔어요 그리고 정말
3d 진영에서 말하는 것처럼 tdd
를 통해서 설계 능력이 높아진다 라는
이상한 소리를 한다면 그것은
프로그래머의 기본인 함수의 선조 건수
조건적 제외 로 공부를 안하고 모체와
를 못 시킨 사람들 그리고 개체 지향
을 제대로 공부를 안 한 사람들이여
개체 지향 설계 부분을 그래서 그거는
컴공 의 원칙 으로 돌아가서 그거를
공부 하면 되는 것이지 그거를 제대로
공부를 안 해놓고 나중에 무슨 이상한
방법 뭔가 줄걸 하겠다라는 것 자체가
될 수도 없는 거고 그리고 시간낭비
인거고 회사 돈 낭비를 하는
과정이라고 저는 생각을 합니다 그래서
제가 반대했던 거고 저는 어쨌든 나의
테스트를 좋아해요 그리고 td 가
열심히 약을 팔면서 과거에 많이
팔았어 특히 북미 쪽에서 요즘은
한국에도 좀 팔리는 것 같지만 예전에
많이 팔면서 tdd 프레임워크 정확히
얘기하면 유니테스트 프레임워크가 많이
발전
이제 편해진 것들 있어요 테스트 같은
경우에 테스트 자동화 같은 경우에 그
저는 유이 테스트 프레임워크를 사용을
합니다
단 ue 테스트를 유리 테스처럼
반드시 사용하지도 않고 그
프레임워크를 그리고 치 d&d 에서
말하는 코드를 작성하기 전에 테스트를
작성한다 이런 이상하지 타지 않습니다
그러면 저는 유니테스트 를 어떻게
사용할까요 라는걸 몇가지를 얘기하면
좋을것 같아서 몇편의 비디오를 만들어
보려고 해요 최근에 포프 tv 디스
코드 대화방에서 누군가 물어봐서 제가
대답을 했던 거기도 하구요
사람은 기본적으로 내가 어떤 실수를
했는지 모릅니다
그걸 알고 있다면 버그도 안나오구요
그리고 그걸 알고 있다며 는 당연히
버그가 안나오기 때문에 테스트 작성할
이유도 없어요 하지만 내가 이미
코드에서 버그를 만들고 있다는 거는
테스트를 작성하는 똑같은 버그로
만들기 때문에 제가 작성한 테스트에서
잡히지 않을 가능성이 높죠 그래서
저는 기본적으로 새로운 기능을 만들
때 테스트를 작성하지 않습니다
예외는 몇 가지가 있어요 그 새로운
기능이 굉장히 수학적 이곳 데이터
입력과 9 10 명 배까지 찍었지
보면은 절차적 프로그래밍 에서 함수에
인풋 9 뭐 결과적으로는 블랙박스
테스트 팀이죠 사실은 그게 명백히
정의가 되어 있는것 어떤 이미 잘
정애를 수학적인 연산 해쉬 함수 같은
경우 그런 경우에는 테스트를 미작성
으로 코드 작성하기 합니다 하지만
그런 경우는 많지 않아요 사실 그렇기
때문에 어떤 기능을 만들 때는 그런
유니테스트 만들고 그거에 맞춰서 뭔가
하는 이런 쓸데없는 지 시간 낭비하기
보다는 기능을 만들고 급이 능에 대한
테스트를 제가 손수 많이 합니다 근데
그 테스트를 작성하는 아테스트 하는
동안에 아요 기능을 누군가는 굉장히
자주 바꿀 거고 그래서 이게 실수를
뭔가 깨졌을때 그걸 잡을 수 있으면
좋겠다 그럴 때는 기능을 다 만든
다음에 유이 테스트를 몇가지만
놓습니다 하지만 아까 앞에서 말했던
못 굉장히 정형화된 함수를 작성을
했을 때는 그걸로 다 꿀 사람은 많지
않거든요 그래서 그걸 테스 잡히는 건
많지 않아요 기본적으로 캐스트는
작성을 하지 않는다고 보시면 맞아요
그런데 저는 테스트 플레이 보컬
삶에서 유의태 써야 한다 그랬어요
언제 많냐 실제 라이브 서비스를
하던가 뭔가를 하다가 어느 순간
저희가 미리 잡지 못하는 버그가
나오는 경우가 있어요 그게 우리가
생각하지 못했던 방식으로 누군가가
데이터를 넣었을 때 사용자가 뭔가
사용해야 하고 데이터가 들어왔을 때
아니면은 뭔가 우리가 테스트를 미처
못했던 레이스 컨디션 이런게 생겼을
때 아니면은 이 함수를 원래 그렇게
사용을 만드는데 다른 사람이 그렇게
사용하면서 뭐 잘못했을 때 그 함수의
내부로 누가 바꿨을 때 뭔가 오작동을
하는 거죠 프로그래밍을 하다보면
함수로 한번 만들어 오고 나서 그
함수를 여러번 바꾸고 개선해 나가는
과정이 많습니다
그러다가 원래 있던 가정이 깨져서
그런 버그들이 나오는 경우가 있는데
그 가정이 깨졌다는 것을 미리 잡지를
못하는 경우들이 있는 거죠 나름대로
어썰트 드 열심히 박아두고 나름대로
테스트 늦게 넣어 낮지만 실제 나중에
제품이 바뀌는 과정을 처음 코드
작성자가 다 보긴 어렵거든요 그걸
어쨌든 버그가 나와요 그럼 그 버그를
잡는 쓴다 버그를 고치자 나요 4
버그를 고치기 전에 보통 캐스트 를
작성합니다 유이 테스처럼 인프라 앞에
저렇게 만들어서 그래서 지금 실제
사용자가 어떤 데이터를 넣었기 때문에
뽀 계층 거죠 그럼 그 데이터를 실제
유이 테스트로 만들고 뽀 게 지는것
확인해요 오케 이쁘게 주는구나 그러면
이제 코드를 고치면서 그 테스트
데이터가 패스 하게 만드는 거죠 그런
패스가 됐으면 그 문제는 고쳤다는
겁니다 그럼 그 순간에 이제 코드 다
치워놓고 끝나는 거예요 이거 의
장점은 뭐냐면 코드를 어쨌든간에
버그를 고치는 도중에 테스트로 여러번
해야 되는데 그 테스트를 여러 번 할
때 프로그램을 부팅하고 뭐 하고 뭐
하고 뭐 하고 하는 과정 자체가
시간이 꽤 걸려요 이 테스트를 한번
작성해 놓고 버거를 고치는게 일단
훨씬 빠르고 요 또 아라는 이렇게
우리가 버그를 고치고 테스트를
남겨두면 요 풀어 벌의 뭐에 또 원래
설계가 뭐 했는지 이제 문서로 남는
겁니다 처음부터 이걸 다 문서 하면
당연히 좋겠고 처음부터 테스트 아니면
하 게 좋겠지 군대의 크고 언제
다하고 있어 그리고 그거 한다고 해서
그 가정의 깨지지 않게 될지 모르거든
사실은 언제나 계속 바뀌는 거거든
하지만 따른 가정들이 바뀌었을 때 이
기능 이뻐졌다 그럼 이 기능을 시간이
지냈을 때 메도 원래대로 작성하는
그들 작동하는 그대로 작동을 해야
되는건데 실수 깬 거고 그럼 이
여태까지 이런 식으로 작동을 한동안
해왔다면 앞으로도 그렇게 작동할
가능성이 좀 더 높죠 원래 모든 간의
바뀌는 부분은 굉장히 많이 바뀌는
거고 안 바뀌는 부분은 잘 안 바뀌는
거거든요 그걸 우리가 미리 코드
작성할 때 알 수가 없다는 거에요
서비스를 하다보면 않다는 거죠
서비스가 하면서 버그 더하라 나오면
그 버그에 대해서 그냥 유니테스트 를
작성해서 그거를 꼭 에 넣고 고치려면
고치가 확인하고 유이의 테스 같이
먹는다는 겁니다 그리고 당연히 유이
테스가 들어가 쓰니까 뭐 빌드를 할
때마다 그 유태 쓸지 하는 거죠 내일
로코 빌드가 아니라 서버에서 빌드할
때마다 그래서 시 나중에라도 누가
이걸 실수로 깨 먹으면 그것을 곧바로
잡을 수 있다는 거죠 또 재밌는건
뭐냐면 버그 글 한번 만든 부분은 요
부인과 고쳐 너는 또 비슷한 복을
두는것도 만들어요 그 이유는 뭐냐면
처음 코드의 가독성이 약간 모자르게
거나 아니면 처음 코드가 일반적인
사람들이 생각하는 방식과 좀 다르게
짜여졌다 는 원래부터 코드 설계 문제
일 수 있다는 겁니다 하지만 모든
코드가 완벽하게 나올 수 없고 어쩔
때는 아무리 열심히 설계를 하고
아무리 열심히 코드를 작성하고 아무리
열심히 함수를 작성해 도 애매한
것들이 있어요 그런 것들을 더라도
잡는 게 뭐냐면 시간 지나 서버가
나오면 버 고치고 위트 했으면 넣고
그 2세도 돌리는거 그 유의태 수는
점점 늘어나게 되는 겁니다 이런식으로
코드를 작성하면 요 흔히 틸리 에서
보는 유니테스트 많으니 별로 안
생겨요 그게 뭐냐 tdr 때처럼
유의태 300개를 만들어요 코드를
작성 해요 그리고 다음에 뭐 비즈니스
로직이 밖에서 뭔가 바꿔야 될 때
유이 테스트 중에 한 20% 깨져버려
예 그렇고 유니티에서 이렇게 28 때
지워 버리거나 새로운 위치에서
만들거나 아니면 비즈니스인 오직 이
바뀐 들 불구하고 보호를 어떻게
되는지 몰라서 다시 원래 이 트 리
테스트로 맞추다가 망가지는 경우도
생기는 겁니다 그래서 결과적으로는
코드가 바뀌는 만큼 유의태 수도
엄청나게 바뀌어요 한 마디로 원래 로
징 만 작성해야 되는 그 시간에 거의
두 배 세 배의 일을 하고 있다는
겁니다 시간낭비가 엄청나고 회사에서
치료해요 그래요 하지만 제 방식대로
하게 되면은 아까 말했듯이 변하는건
자주 바뀌지만 안 변하는 것 자주
1박 안 변한 하거든요 그래서 이렇게
유이 테스트를 막 지울 이들이
적어집니다 그 점점 5 코드 커버리지
이런 얘기 있는데 것 5 처음부터
코드 커버리지 배포 nt 거는 다
이상 아니고 이런 식으로 유이 테스
작성하다 보면 서비스가 1년 2년
지라도 보면 코드 커버리지 가 망고
퍼지게 되고 요금 않아서 코드가 뭐
치워 됐고 이 코드는 잘 안 바뀌는
거고 이런게 타계한 판단이 되거든요
하지만 인간이 처음부터 코드를 작성할
때부터 무슨 빚이 소지가 안 바뀔 것
부터 한다 굉장히 어 불상 소리죠
그래서 어쨌든간에 저희 회사에서
그리고 제가 ue 테스트 프레임워크
자동화가 잘 되어 있으니까 그거 를
통해서 하루 2 테스트 한 가지가
이겁니다 버그 가 나왔을 때 그
버그를 재현 시켰던 데이터를 코 유이
태슬 돌리고 그러면 버그 각 때문에
꼬리 뽀 게 다 쓰니까 그것을 고치는
코드를 만들면서 여러분이 t 를
돌려보고 그 위치에 스톤과 햇죠
예전에 딸의 dates 다 통과
하겠죠 그러면 다 고쳤다고 각
생각하고 코드 집어넣고 최종적으로
당연히 시스템에 올라가서 또
테스트합니다 위태 스스로 만족할 순
없죠 최종 테스트 해야 되기 때문에
물론 그것도 캐 밝히지만 그렇게 전이
이태수 를 눌러 가 보이고 그래서
유니테스트 상당히 좋아하는 편입니다
특히 puc 5 아카데미에서 하는
많은 일들은 많은 것들이 데이터들이
분이 굉장히 많아요 그렇기 때문에 그
데이터들이 분으로 청소할 수 판단할
수 있는 것들 테스트 할 수 있는
것들 그런 것들은 굉장히 많이 합니다
그래서 유이 테스트를 저희가 알게
되게 많아요 사실 그런 식으로 엄밀한
의미의 유이 테스트는 아니겠지만
자동화 테스트 ue 테스트
프레임워크를 이용한 유이 테스트를
자동화 테스트를 저희는 그렇게 하고
있습니다
그래서 혹시라도 tdd 가 하면서
이상했다
아이 만 말이 되는 것 같으면서도 왜
안할까 이런 고민 하셨던 분들은 이런
식으로 자동화 테스트를 약간 씩은
만들어 가세요 단 원래 4시간 안에
끝내야 될 일을 아테스트 만들려고
이제 뭐 12시간이 걸립니다 그런
순간 조만간 사표를 쓰거나 짤릴
거라는 생각을 하면서 열심히
사실이겠죠 예 뽑혔습니다
