안녕하세요. 포프입니다. 최근에 cpp 컨퍼런스에서 자료 비디오가 몇 개 올라왔어요. 아마 Microsoft 쪽에서 올렸던 것 같아요. 그 자료를 보면서, C++가 예전에 한번 뭐 99년도에 한 번 개정이 됐죠. 그 이후에 오랫동안 안 바뀌다가, 11년도, 14년도, 17년도 이렇게 매 3년마다 업데이트 계획이 나오잖아요? 그래서 처음 해 11년도는 큰 체인지, 14년도 작은 체인지, 17년도는 큰 체인지 이런 식으로요. 인텔의 Tick-Tock과 비슷한 개념으로 업데이트하는 것 같아요. 그래서 이전에도 비슷한 얘길 한 것 같아요. 굉장히 C++가 맘에 안 들어요. (웃음) 물론 좋은 것도 있어요. 제가 이렇게 막 바뀌는 것도 나오면 쭉 보다가 이거 좋다, 저거 좋다 하면서 읽는 경우가 꽤 있는데요. 대표적인 게 라이브러리 화가 되는 것들 중 굉장히 좋은 것들이 많아요. 사실은 예전부터 있었던 범위(Scope)로 컨트롤하는 Mutex 같은 거 있잖아요? 범위 제한(?) Mutex 요. auto keyword 이런 것들도 있고요. 그런 게 굉장히 다른 언어에서 이미 있는 것들이고 우리가 코딩하기 편하게 하는 것들이죠. 그러면서 (코드의) 가독성을 해치지 않는 것들은 굉장히 좋거든요. 그러면서도 또 잡다한 걸 많이 추가도 하죠. 특히나 C++의 문제인 것 같은데, C++의 템플릿 같은 것을 쓰기 시작하다 보면, 읽기 너무 복잡해지고 키보드 칠 때도 굉장히 귀찮아지는 그런 이상한 것들이 많거든요. '이게 왜 나오지?' 생각이 들 정도로요. 그런 것들 좀 문제가 있고, 어떤 것은 아예 가독성을 해치는 경우도 있어요.

제가 C의 장점이라고 보는 건 언제나 이거였어요. C로 코드를 짜면 이게 하드웨어에서 어떻게 도는지 감이 와요. 그래서 어떤 코드를 짜든 간에, 그 내부적으로 '음, 이렇게 돌겠구나'라는 감이 오고요. 그렇기 때문에 코드 하나를 짜더라도, (반드시 최적화하라는 건 아니지만) 성능에 대한 자신감을 갖고 짤 수 있다는 것이에요. 아님 나중에 코드를 봤을 때 '아, 이게 여기서 이것 때문에 느려질 수 있겠구나!'라는 생각을 할 수 있다는 거죠. 그리고 워낙 하드웨어에 아까우니까, 실수할 여지가 적어진다는 생각을 많이 했어요. 근데 요즘 나오는 표준들을 보면서 그렇지 못한 것들이 너무 많은 것 같아요. 일단 가독성을 해치는 것도 많고요. 이건 표준 얘기는 아니지만, 최근에 들었던 string 최적화가 있어요. C++에 string 최적화가 들어가 있대요. 저는 string을 보면 언제나 걱정이 됐던 게, string은 언젠가 뒤에 다른 string을 append 할 수가 있잖아요? C++에서 ~~array~~(vector)를 써 보신 분들은 알겠지만, 결과적으로 내부적으로는 스트링을 이렇게 더 추가하고 붙일 때마다 새로운 메모리 할당이 다시 일어나고, 예전에 할당된 메모리 지우고 이런 일이 있어야 한다는 걸 누구나 알아요. 당연히 C/C++에서는 메모리 Allocation이 굉장히 느린 부분 중에 하나예요. 물론 Custom Allocator를 줄 수 있다고 얘기하는데, 그건 어찌 보면 한 번 세팅해 놓고, 코드를 처음부터 끝까지 제대로 읽지 않으면 Custom Allocator가 설정돼 있는지 아닌지 알기가 어렵기 때문에 오히려 가독성을 해치는 부분이긴 하죠. 그래서 당연히 이게 느리겠다고 생각했죠. 저는 string을 안 써요. char array를 쓰거나, 자체적인 string을 만드는데, 처음부터 어느 정도 string 크기를 미리 잡아두고, 그걸(string 영역) 안 넘어가는 정도로 쓰거나, 넘어가면 뭐 debug assert를 발생시키는 방향이죠. 근데 이런 문제를 고치려고 Microsoft가 (다른 회사에서도 그랬을 것 같지만) 나섰어요. 문제는 컴파일러마다 달라진다는 건데 내부적으로 string 최적화를 넣었대요. string을 처음 만들 때, string의 capacity가 작아도 32개 또는 16개라고 미리 array를 예약하는 거예요. 그리고 계속 string을 추가하면 32개 이하까지는 단순히 스트링만 array에 추가하죠. 그러다가 갑자기 길이가 32를 초과하기 시작하면 이제 그때부터 메모리 할당을 시작한다는 거죠. 어찌 보면 그런 꼼수도 좋고 자동으로 최적화하는 건 정말 좋긴 좋은데, (웃음) 저는 어이가 없는 게 이 순간부터 제가 코드를 읽을 때 과연 이게 메모리 할당이 되는지 안 되지가 안 보이는 거예요. 컴파일러 따라 그 (Capacity) 숫자가 바뀔 수도 있을 거고, 버전 따라 다를 수도 있을 거고요. 보면서 '아 이런 코드는 보기 싫은데?'라는 생각이 드는 거예요. 오히려 이건 느린 거라고 알았던 건데, 어쩔 때는 빠르고, 어쩔 때는 느린 거라는 거죠. 이 어쩔 때라는 개념이 바뀔 수도 있다는 게 너무 싫었어요. 그래서 컴파일러를 빠르게 하려고 이런저런 최적화를 하는 건 좋아요. 근데 이렇게 내부 동작을 바꿀 정도의 최적화는 문제가 있지 않을까요? 차라리 미리 컴파일 시간에 계산이 가능한 것들을 최적화한다거나, 코드의 순서를 바꿔도 영향을 안 주도록 스스로 바꾸게 해서 assembly에서 서로 wait 없이 (cycle locking 제거) 최적화하는 거라면 다 좋은데 이건 좀 아니라는 생각이 들었어요.

그리고 또 하나 들은 얘기가 뭐냐면, C++ 표준위원회에서 굉장히 잘못하고 있는 것 같아요. 제가 볼 때는 언어 자체로 이제 오픈 표준으로 만드는 것도 문제인 것 같기도 하고, 그 언어 하나를 진정으로 책임지고 자기의 원칙을 끌고 갈 수 있는 단 한 사람의, 거의 독재자 같은 사람이 없다는 것도 문제인 것 같아요. auto_ptr(오토 포인터) 같은 경우만 해도 예전에 등장한 뒤 지금은 다른 새로운 게 나왔으니 auto_ptr 쓰지 말자는 얘기가 나왔어요. 새로운 버전이 등장할 때마다 예전 버전의 문제를 발견해서 이걸 쓰지 말고 저걸 쓰라고 가고 있는 방안인 거죠. 그러면서 Backward Compatibility 문제 때문에 여전히 지원하고 있죠.

그리고 최근에 또 R-Value Optimization이라고 있어요. 저도 얼마 전까지 별로 신경을 안 쓰다가, 최근에 cppconference 때문에 제대로 한번 읽어봤는데요. 이게 뭐냐면 예전 같은 경우에는 그 함수 같은 경우에서의 가장 큰 문제는 사실 Copy Constructor, Move Constructor 얘기였어요. 중요한 건 Temporary Variable를 반환할 때 (포인터가 아니라) 오브젝트 클래스 안에서 어떤 오브젝트를 반환할 때 그 오브젝트에 Copy가 들어가는 문제도 있고, Temporary 오브젝트 만든 다음에 함수 안에서 그걸 반환하면 함식 거니까 Object 복사가 일어나잖아요? 그게 느릴 수 있고, 어레이를 그렇게 해도 느릴 수가 있고 struct를 그렇게 해도 느릴 수가 있기 때문에 그 문제점을 Temporary Variable을 그 곧바로 복사하는 게 아니, 그 소유권을 넘겨주는 방식으로 할 수 있는 새로운 언어의 변화가 나왔어요. 그걸 R-Value Optimization이라고 하죠. 일단 Syntax가 구리고요. 뭐 이렇게 펭귄 모양 기호(ampersand) 있죠? 이걸 두 개씩 (&&) 달아야 해요. 그리고 코드만 이렇게 봤을 때 '과연 이걸 어디에 쓰는 게 옳을까?'라는 의심도 많고요. 또 예전 같은 경우엔 const reference (const &)으로 반환하면 그게 보통은 그런 식으로 다 됐거든요. 그런데 그게 아니라 const가 아닌 이상은 그런 Temporary Variable를 const가 아닌 걸로 반환할 수 없다는 단점이 있었죠. 그걸 해결하기 위해 나온 거래요. 예전처럼 오브젝트 있고, const reference로 반환하면 어차피 똑같은 거고, 그게 아니라 그냥 const 할 수 없을 때는 어쨌든 복사가 일어나니까, 그것을 맞게 하는 게 R-Value Optimization이다. 이것을 잘하면 정말 Copy-Cost가 더 빨라진다 이런 이런 얘기가 많아요.

하지만, 제가 봐도 '야 이걸 제대로 쓸만한 곳이 몇 군데 없을 것 같은데?' 생각이 들고, Syntax도 구리고, 잘못하다간 더 느려지지 않을까 생각도 가끔 들어요. 물론 제가 이 부분에 대해서 아직 이해가 모자라긴 할 거예요. 그런 생각 하면서 열심히 하고 있었어요. 근데 cppconference에서 올해 다들 이런 얘기를 하더라고요. 그 유명하신 Scott Meyers라는 분이 책을 쓰셨다는데, "신경 쓰지 말라."고요. 요즘 사람들 문제가, 새로운 거 나왔다고 너무 그쪽으로 쏠려가면서 너무 코드를 개판 치고, 읽기 어렵게 만드는데요. 사실 R-Value(오른쪽에 있는 것) 보다는 L-Value(왼쪽에 있는 것)에서 오히려 속도 조화가 많은데 사람들이 자꾸 (이걸) 잊는 것 같다고 말해요. 그리고 R-Value를 잘못 써서 계속 실수하는 것보다는, 차라리 옛날에 하던 대로 그냥 const reference로 반환할 수 있으면 그렇게 쓰라고 그러더라고요. 그냥 R-Value 쓰지 마라고요. 올해 나온 Recommendation이 진짜 웃겨요. 작년에는 "R-Value가 좋으니 쓰자!"이랬었는데, 올해는 쓰지 마래요. 쓰지 말고 정말 어쩌다가 그 오브젝트 복사하는 게 그게 프로파일링에서 엄청 느리게 나온다면 프로파일에서 보이면 그때 고치래요. 근데 제가 프로그래밍하는 경험상 그게 느려서 코드가 느려진 경우는 없었어요. 뭐 그게 느려서 이제 뭐 레퍼런스로 반환하거나 포인터를 반환한 적은 물론 있죠. 그런데 예전 C++로 해결 못해서 그것 때문에 정말 느렸던 경우가 없어요.

그래서 그게 웃긴 거예요. 그래서 결과적으로 또 뭔가 그럴듯한 feature로 만들어 놓았고, 어느 분야에서 쓰일 만한 곳(라이브러리)이 있을지도 모르겠는데요. 근데 결과적으로 실수할 확률도 높고 (코드) 읽기도 어렵고 등 여러 가지를 따져봤을 때 쓰지 않는 게 가장 안전하게 코드를 짤 수 있어요. 나중에 정말 필요한 때가 돼야 쓰는 거죠. 근데 저는 프로파일러에서 그게 느리다고 나온 적을 거의 본 적이 없어요. 그게 문제예요. 제가 볼 때 이건 정말 스펙에 들어왔는데 한 90% 이상의 프로그래머가 절대 신경도 안 쓰고 평생 쓰지도 않을 스펙이 아닐까 생각해요. 결과적으론 어느 순간 또 이렇게 흐지부지 사라지는 거죠. 말 그대로 표준만 엄청 많아지고, 정말 실제 쓰는 표준은 굉장히 적은 상황이 되지 않을까 생각도 들고요. 그래서 이번에 그걸 보면서 좀 많은 생각을 했어요. '또 C++ 커뮤니티에서 좀 바보짓을 했구나.' 예전에 auto_ptr부터 그랬듯이, 매년 cppconference 이런 데서 Recommendation이 나오는 걸 보면 참 재미있어요. 결과적으론 뭐 새로 나온 것도 auto keyword라던가, range-based-for-loop 등은 굉장히 좋아요. 그렇게 정말 코드 쉽게 짤 수 있는 거 이런 거 다 좋은데요. 그게 아니라 뭔가 좀 가독성 자체를 해치는 부분이 표준으로 들어오면, 몇 년 안에 표준이 아니라 가이드라인으로 이렇게 하지 마라고 나오는 거 같아요. 저는 C++에 대해서 그 꼴을 보면서 솔직히 조금씩 짜증이 나기 시작해요. 그래서 요즘 제가 얼마 전 아마 영문 트위터에 쓴 거 같은데, 학교에서 C언어를 요즘 뭘로 가르치는지 모르겠지만, 99년 이후에 나오는 게 없었잖아요? 그것도 굉장히 조금 바꾼 거예요. 그전에 정말 오랫동안 하나였어요. 그래서 씨를 굉장히 전통적으로 가르쳤거든요. array부터 시작해서 메모리, 정말 하드웨어에 가깝게요. 요즘엔 어떻게 가르치는지 모르겠어요. 저희 때만 해도 STL이 있었는데, 굉장히 수박 겉핥기로 배우고 넘어갔거든요. 저는 그게 고마웠고요. STL을 쓸 수 있는 부분이 생각보다 많지 않아요. 제 입장에선 C++를 만질 때 보면 그래요. 근데 새로운 표준이 나왔을 때, 학교에서 정말 뭘 가르치는지 너무 궁금한 거예요. 이제 새 표준으로 맞추어 가르치는지, 하드웨어는 신경 안 쓰고 좀 더 알고리듬 쪽으로만 신경 쓰는지요. 그럴 거면 차라리 C#이나 Java를 하지, 왜 C++를 하는지 생각이 들어요. 학교에서도 저는 여전히 좀 전통적인 C++를 가르치면 좋겠어요. 그러다가 마지막에 정말 맛보기로 이런 새로운 게 있다는 걸 보여주는 정도로만요. 왜냐하면 제가 실무에서 C++를 안 쓰고 있지만, (요즘은 C#을 많이 하죠) 집에서 C++(프로그램)를 계속 짜면서도 요즘 느끼는 건, 새로운 게임엔진을 좀 끄적이면서 그런 최신 C++11이나 C++14들을 좀 쓰려고 하거든요. 근데 쓰면 쓸수록 몇 가지는 정말 좋은 게 있고(비디오에도 공유했어요), 그 외에 정말 해로운 게 많다는 생각이 들었어요. 말 그대로 실수를 적게 만들 수 있는 것들요. virtual, final, override 같은 키워드들 있잖아요? 그런 거 정말 좋죠. 그런데 그 외에 정말 fancy 하게 뭔가를 시도하려 했는데, 내부적으로 뭐 어떻게 도는지 지 전혀 감도 안 오고요. 나중에 가면 누군가 실수 점점 많이 하고, 읽기도 어려워져서 "쓰지 마세요."라고 Recommendation 나오는 스토리요. 그런 거 보면서 '아.. 이건 아니구나'생각이 들어요.

예전에 스마트 포인터라고 해서, C++에서 auto_ptr 사용하신 분들은 다 걷어 내셔야 할 거예요. (쓰지 말라고 Recommendation이 그랬대요... 저도 왜 그걸 쓰는지 몰랐는데) 그래서 더 아쉬워요. C++에서 한 명이 정말 강하게 주도하는 사람이 없다는 게 좀 아쉽고요. C#도 그런 사람이 사라지기 시작하면서 점점 망가지고 있듯이, 'C++는 참 많이 망가졌구나. 이 망가진 걸 제대로 학생들에게 가르치는 선생님은 몇 명이나 될까?' 누군가에게 가르칠 때 이건 Bad Practice이니 좋을 걸로만 써라고 말해주는 사람이 있어야 할 텐데요. 오히려 게임업계 사람들도 새로운 게 나오면 그걸 너무 과하게 적용해서 엔진을 망치는 사람도 많이 봤어요. 그런 얘기 진짜 많이 들었고요. 언젠가 그 얘기도 제가 할 것 같은데, 새로운 기술 다 좋지만 역시 조금 지켜보고 자기가 직접 새로운 걸 만져 보고 어느 정도 이게 뭔가 하나에 도움이 되거나 해롭구나를 알 때 진짜 제대로 된 프로덕션 퀄리티의 집어넣는 게 맞는 것 같아요. 오늘도 주저리주저리 C++를 깐 것 같네요. 포프였습니다.
