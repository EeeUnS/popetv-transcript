오늘은 오랜만에 그래픽 프로그램의 이를 다시 해볼게요
최근에 모 잠시 또 정치 중간엔 중단을 했지만
음 사이드를 진행하던 게임 프로젝트 가 좀 있었어요
좀 재미 있을것 같아서 음 그거 를 하면서 이제 아무리 봐도 모키 전
ng 를 쓰는 건 별 의미가 없어 서자 체인지 를 만들었는데
그래서 이제 저말고 이제 따른 분이 이제
렌더링 왼쪽을 좀 많이 만들었거든요 그 사람 다 해보고 싶다 그래서
만드는 동안에
제가 예전에 뭐 게임 회사 다니면서 했던 그런 기법들을 많이 설명드리고
걸 부여하게 만드는 구현하게 만들곤 했어요 그래서 그 중에 나왔던 게
앞 추 버텍스 호매실 뭐냐면
이게 사실은 스페이스마린 만들 때도 그랬고
제가 이제 헤일로 참가할 때도 그랬고 주 쓴 기법이 거든요
이 개념이 뭐냐면 일단 이렇게 설명을 드릴께요
캐릭터 하나를 만드는데
메모리가 얼마나 될까 텍스처 4 따로 빼 줘
이미지 니까 액션은 뭐 총 5천 14 겁하게 1023 연대 충북의 이제도
인맥 포함해 선 3회가 먹는다고 보거든요
그런 것 좀 빼고 순수하게 모델 버텍스 모델이며 는 삼각형으로 만들어진
거잖아요
브리드 모델이 그럼 그 삼각형 때문에 내는 사건 때문에 드는데 머리가
얼마나 될까를 볼게요
일단 기본적으로 보죠 음 캐릭터 모델을 만들면 거기에
삼각형이 몇 개 있을까 폴리곤 이라 그렇죠
폴리곤이 몇 개 있을까 생각해 보면 되요 폴리곤 생각을 해 보자구요 폴리
그녀와 몇 개 있을까
그러면 어 제 기억으로는 스페이스마린 만들 때도 이렇게 하이 폴리곤
아니었어 좀 많이 줄어서 썼는데 그것만 해도 실제 면만 풀리고 니
나왔어요 그럼 요즘 게임 같은 경우에는 최소한 캐릭터 모델 않아야 1
30,000 팔리고 생각해볼까요 2만 정도 잡죠 이만 폴리곤 이라고 해요
이 만기에 다경이 잇닿은 폴리 거는
보통 이제 사각형을 보통 폴리곤 일어나니까 이쪽에서 게임 모델 1 쪽에서
그 삼각형을 않으면 은 4만 벌리거나 되는거예요 3 1 삼각형
3 1 삼각형 이면 이제 보통은 요즘은 정점 다 스플릿 하잖아요
그러면 그 정점
스프레이 안 할 수도 있구나 스스로 말이에요
4 보통 한다고 보면은 뭐 아니 안 한다고 봐도 그런 안 한다 쪽에 적대
잡죠 게 낫겠다고 4만 게 면은
거기에 원래 삼각형이 3개씩 이 돼야 되는데 전정 점 이 3개가 사각형의
하니까 평정 전실이 만개가 되야 되는데 이것은 반정도 재활용이 가능하다고
보고 한 중 만 개정 돌아가 보는 거에요 그러면 모델 하나 만드는데
정 점 p 가 영남 개가 필요하다
그럼 6만 곱하기 각 정점 바다의 사이즈를 보면 크게
메모리 겠죠 일단 영감은 적어두고 용 말
그러면 한 정점에 무슨 데이터가 들어 가냐
위치가 들어가야 줘 위치하며 는 x y j
그쵸 그러면 이제 플러스로 3개의 어 블러쉬 뭐냐면
음 4바이트 그쵸
그러면 시위 발등 알고 이렇게 생각하고 헷갈리는데
그냥 플러 3개의 이렇게 해 줘 블러 세계 그리고 텍스트를 실려 유비 콜
대지 들어 가야 되죠 여기에 유류비 텍스쳐 영영이 들어가는 g12
들어가는지 텍스처 에서 어느 부분을 이 버텍스 집어 넣을 건지
그럼 그게 블러쉬 2개 자나 유아 급이 플러시 5 개 요
그 다음에 제가 조명을 받으려면 법 써니 필요하잖아요 내 표현이었 일을
하고 이제 가르키는 복선
그게 xy 쓰지요 세계 요 그러면 x 와이즈 8개 에요
근데 노멀 래핑 하려면 탄젠트 들어가고 바인더 만들어 가야 되죠 그럼
세계적 또 추가 해요
그러면 돼 가볍게 었어 1 2 3 4 떼서
요새 보여도 8개 줘 8개 에다가 6개 추가 되는 거에요
그 별 4개가 되요 14개 이게 끝이냐 음 봅시다
14개가 끝일 수도 있고 아닐 수도 있는데
14개 에다가 팩션 앱을 2개를 따로 피를 겹치고 싶으면 유비가 난 더
들어가야 되요
보통 말 집어넣고는 검 16개가 되요 켜서 16 개 요
거기다가 스킹을 하거나 이러면
본을 보통 4개 스캐닝 하니까 그럼 스킹 에 들어가는 정보 들어가는데
일단 그건 빼자 고요 복잡해 지니까 그러면 지금 제가 계산한 게 16개
맞죠
위치 노말 탄젠트 바 이놈을
맏이 16 개 요 그러면 16개의 면은 아까 말했듯이 4byte 씩
이니까 불렀 하나가 64 바이트 거든요
그럼 64 바이트의 제가 아까 삼각형이 60000 개 라고 했던거 같아요
그죠
그럼 계산을 해보자 고갈 클레 드 뽀 가서 아 저거 두고 그랬네
그 정점의 유망 들어가 있던 같은데
64 에다가 용 관계를 해봐요
그러면
이게
3.8 매 거에요
모델의 3조 판매가 에다가 이제 에로 d 몇 개 하면은
이게 또 엄청나게 많아 지는 거에요 그래서 제가 만들었던 최근에 만들었던
게임은 퍼텍스 만 거의 다 100매 가 읽기가 1기가 먹어줘서 있어 워낙
모델이 많으니까 게임 안에
그리고 왜냐면 3저 판매가 라고 해도 에로 d 로부터 하나 둘 세 개를
만들잖아요 그러면은
그 옅은 2배정도 3배 정도가 돼요 그러면 그것만 해도 일단 8배가
그러면 신뢰가 정도라고 보시면 되요 그럼 모드라 다시 매가 최소한 그
모델 그 버텍스 않아 의 그 약의 나오는 거거든요
그리고 여기서 그럼 캐릭터가 다른게 얼개가 된다 그렇게 100메가 야
그렇게 배경과 통한 들어 가야 되죠
그것도 만 버텍스 막 심 단계는 그려 경우도 있어 어떤 애들은 잘못된
거지만
그럼 결과적으로 제가 예전에 옛날게임 돌릴 때 더 한 10년전에 게임
돌릴 때도 한 프레임에 처리했던 삼각형 수가 한 10만개 정도 됐어요 5
테루 지금은 이제 그것보다 이젠 별 빼는 많겠지
이럴 때는 기울이겠다 최근에 보면 오심 하겟지만 이때 있구나
그럼 50만 개 만 해도 써 청말 잔혹사 식을
그리고 문제는 메모리를 먹는 문제 뿐만이 아니라 밀어서 메모를 제가 이걸
먹어 났어요
그럼 이제 메모리가 gpu 에 들어가서 메모를 처리해야 될 거 아니에요
그럼 그 메모를 찰스 하는 과정도 있거든요 cpu cpu 로
그럼 그 속도 문제도 있고 메모리 많이 먹는 문제 듣고 이런것도 있는
거에요 그래서 저흰 압축 폼에서 많이 써요
압축 포맷이 뭐냐 아까 말들이 미친 x yg 가 이제 플러스로 들어가
있으면 4byte 씩 이거든요 근데 만약에 이 뭐라 그럴까
모델 자체가 엄청나게 크지 않고 한 모델은 언제가 조그맣고 이걸 다른
위치에 앱이 위치만 시키는 그런 개념이라면
여기서 과연 4바이트 에 필요한 그런 정맥 또 가 필요할 수도 있어요
그러니까 예를 들어서 내 숫자가 언제나 0 부터 1
50가지 먹었다가 딴다 그러면 여기는 그정도 정밀도 필요없 수가 있거든요
그럼 위치를 불러 32비트 짜리 4 발전의 있는데 시는 16비트 흡수가
있어요 물론 c 에서는 16 비트 플러스 제대로 지원 안하지만 gp
위해서는 지원해요
그럼 그거를 16비트로 놓고 그 gp 얘기해줄 때 다 이 포지션은 사실은
f3 실이 블러 32 가 아니라 쿨러 16 이야 라고도 주면 지내다
알아서 판단해서 뽑아 하여 그럼 이제 문제는 c 에서 짚을 프레스 뿔에서
32 비트 플러스 신립 밑에 어떻게 사랑하는지 그것만 잘 알면 되는 거죠
그래서 예를 들어서 위치를
10m 를 줄 수 있었다 그럼 이 위치에서 절반이 짤리는 거죠
그리고 유비는 어때요 유비는 넘 부터 142 잖아요 보통 근데 언제나 0
부터 1 사이라고 가정을 할 수 있다면 이것도 16bit 로 눌 수
있는데 이거를 노만 라이 셔서 넣어요 노멀 라이즈 등기가 뭐냐면
인테리어로 놓는데 0 2 0 을 영어로 두고 16비트 체험 값이 26 -
일이거든요
그러면 2.0 을 16 그 이애실 육수 - 1호 매핑을 한 다음에 그
중간 값을 넣어주는 것 뿐이에요
그러면 이애실 6승 이면 안 죽나 고쳐 되는건가
그러면 65,000 니까 3만원 이용 나오죠 맞을 것 같아요 그럼
65,000 단위가 있는 거에 0 부터 1 사이의 단계가 용
15,000개 가 있기 때문에 저밀도 는 충분 하거든요
4 만약에 유비가 0 일이 아니라 - 2 까지도 가고 뭐 플라스크 l -
1부터 이런 상관이 없는데 0에서 1을 넘어서 235 까지 가면 좀 거라
빠지는건 있는데 그런 경우에는 뭐 똑같은 얘기로 0 에서 최고 끝까지를
정해주고 우리는 최대 16가지 만 왜 변할 수 있다
여기서 16가지 만 해주고 아직 - 니까 16가지 만 해주고 이 중간
값을 단계별로 나눠 갖고 저장한 다음에
최 에서 불러와서 그 - 16 이나 16 을 곱해 주면 되는 거죠
그래서 그렇게 유비를 저장을 한다면 그것도 30 일자리가 16비트로
들어가요 그리고 실제 이건 굉장히 많이 해요
포지션을 16 피터를 주인은 경우는 좀 더 래요 왜냐 정밀도 문제가 있을
수 있는 경우가 많기 때문에 그 모 포지션을 두더라도 유비를 그렇게 줄어
떼를 들어서 그럼 유비 2개를 주려면 은 32비트 총 대게 있었잖아요
유비 원하고 u b2 하고
두개 합쳐서 반으로 주로 줄어드는 거에요 그게 가능하고 세번째 재미있는건
거에요
노말
노 말을 언제나 그 범위가
노말 라이즈 대응도 말이 좋을까 정규화 시킨 5 말은 - 1부터 1 4
이어 xy 든 제트
그리고 노 말은 뭐라 그럴까
노말 라이즈 된거 면 정규화된 거면 xy 제 특가 그 길이 구하는 공식이
있잖아요 x 제고 플러스와 이제 고 플랜트 플러스 제트 제 곱하면 은
언제나 값은 1이 나와야 되죠
이 속성을 이용하면 되게 재밌는 게 맥 재밌게 인코딩을 할 수가 있어요
일단 x 는 y 드제 태도 - 부터 일상이라고 했어요 그러면 이 단계를
과연 우리가 뭐랄까 압축할 수 있냐 질문하면 가능한 것 같아요 - 에
붙어 1 사이를
16bit 로 놓으면 은 총 6만 5천 단계로 들어가는 거잖아요 그러면
그거를 노말 라이즈 해서 노면 은 충분히 정밀도가 나와요 그럼 xy 를
그렇게 집어 넣어요 - 1부터 1까지 - 2일까지
프로젝트는 어떻게 되냐 안 넣으세요
왜냐고 x 제곱 플러스 와이즈 플러스 제트 제곱은 이루어야만 되거든
그러면 이것을 104 그 와이프 - 제트는 구할 수가 있어요
단 단점은 제트가 플러스 가 나올 수도 있고 - 가 나올 수도 있죠
그러면 이게 플러스 이제 - 는지 애정 먹어보니까 c 에서 인코딩을 할
때
x 하고 x 제고와 이제 9분해 보고 그리고 이제 이거 에서 1 - 모
x 제고와 이제 곱하고 루트를 쉬었을 때 그리고 이게 이제 어떤 값이
나오잖아요
프랑스의 값이 나올 거 잖아요 그러면 여기 게제 타고 맞는지 확인해서
맞으면 은 양수 라고 양의 기호를 인코딩을 하고 틀리다면 의미의 기호를
인코딩 하면 되요 그리고 쉘에서 곱해 준 하면 되거든요
결론적으로 말한 뭐냐면 x y 만 주장을 하고
제트 에다 - 2 를 곱해 줘야 되는지 2 를 곱해 줘야 되는 지는
결국에는 불리언 플랙 하나로 되는거잖아요 비탄 하면
그러면 이 xy 중에 아까 16 기타 쓴다 그랬죠
15 비트만 쓰고 한 비트의 부호를 봐야 놓으면 되요
그래서 15 비트의 그 - 디테일까지 값을 넣고 이 한 비트의 과연 제
테고 파야 될 값이 플러스 3 - 요
이것만 넣으면 은 노 말이 딱 16비트 2개의 들어가요
32비트 세 개가 아니라 탄젠트 똑같이 들어가요 그렇죠 그래서 또 나
재밌는거 바인 오마르
안 넣으세요 그 유이 거에요
바이넘 알의 개념 자체가 놈아 라고 텐트가 있을 때 이 두 개의 직교하는
벡터가 바 이노 말이에요 맞잖아요
그러면은 이 두 놈 re 이 두 벡터가 있으니까
아바이 넘은 계산으로 구할 수가 있는 거에요 언제나 그 쉐이더 코드
안에서
단 한가지 차이점은
곱하는 순서에 따라 바 이노 말에 그 백터 가창 않은 방에 달라져요
이쪽으로 할 수도 있고 이 쪽을 향할 수도 있을까 플러스 마이너스 또
개념인데
이것도 아까 그 인코딩 했던것처럼 미리계산 해본 다음에 이게 내가 뭐
노말 에다가
바이 노말 크로스 프로 타면 되고 외조 외적을 했을때 나오는 팩터 랑
지금 내 까보 제노 말하고 탄생 틀을
외적을 했을때 나오는 벡터 랑 바이너리 향하는 방향이 같은가 같으면 그냥
뭐 플러스 를 주장하고 틀니 건 - 작았고 그럼 또 어딘가에서 한비 테마
때 나서 저장 하면 되요 그럼 아까 노말 해서 1비트 빼앗고 그 노말
xy 에서 1비트 떼고 져야 겠죠 제 노말 채택을 위해 2% 에서 xy
에서 1 미드 빼앗고 퍼센트에 제트 를 저장하면 불을
있어 비트를 저장 했어요 그럼 여기서 탄 추세라 노멀 사도 빼앗고 한 미
텐더 빼서 와 이쪽에서
바이널 방향은 어디를 가르키는 을 인코딩 하면 되는거예요
그러면 바이넘 r 떨어져 나갔죠
금호 남았어 없는거잖아요 그럼 몇 발 큰집 보자구요
일단 12 바이트는 음 그 포지션을 제대로 주장한다고 봐요 그래야 건
아주 안하고 c 바이트의 타로 들어가고 그 다음에 유비 2개는 저희가
16 bit 씩 4개 노 쓰니까 이게 2바이트 8바이트 해요 그럼 이게
아까 [ __ ] 됐죠 20 바이트가 되어 그 28대 다음에 노말 텐트 다 합쳐
가고
그게 16bit 2개 2개 해왔고 총 삶과 16m 4개의 들어가잖아요
그러면 그게 힙 up 되면 아 헷갈려
탈 바이트 역시 그러면 아까 12 플러스 8+ 파리 줘
그러면 이게 28 바이트가 되는거예요 그럼 아까 계산 했던게
몇 바이트 여서 64 바이트 아니었나
아 헷갈려요
맞죠 64 같에요 유키 4byte 가 이제 28 바이트가 된거예요
그러면 28 나는 63 여 는
옆으로 쟈기야 54% 53% 제약 이거든요
그러면 이렇게 하는 것만으로도
메모리가 절반으로 먹어 다는 거에요 그래서 실제 버 택가 모델이 엄청
많은 게임에 는 다 이렇게 나왔어요
스페이스마린 어 엄청 이렇게 줄였고
심지어는
뭐라 그래 그 스킹 하는 것도 엄청 그렇게 줄인 여기 있어요 스킹 에서
본 웨이트 이잖아요
본 웨이트 나 이제 어드 보네 어느 정도의 영향을 받느냐 포터 플러스로
주장하는데
저희 스페이스마린 할 때 이거를 플러시 아니라 유 인 트 16도 아니야
뉴인텍 팔로 줘야겠어요 2 유럽 단계로 그렇게 기억해요
그래서 엄청나게 해주셨죠 그 원래는 32비트 짜리 내게 들어가야 되는게
8일 저리 되었으니까 것 4 보내며 쭈리 뭐고
그래서 엄청나게 압축을 할 수가 있어요 대신 이 되서 좀 더 많은 일을
하면 되는건데
이런것이 p 보다 gpu 가 빠르고 음 제가 볼때는 쉽 비유 보다
메모리가 더 귀한 그런 상황이었기 때문에 그래서 이거를 모르겠어요 지금
엔진을 쓰는 사람들은 자세히 고민을 안할 것 같긴 한데
응
이런 저는 모든 엔진 이어령의 기반이 결과적으로는
메모리 관리 라고 보거든요 왜냐하면 은 메모리가 그냥 단순히 메모리 많이
먹는 그 문제가 아니라 메모리가 많아지면 많아질수록 실제 맷 캐쉬에
들어가는 캐쉬 비슷 5 많아지고 속도에도 영향을 주고
최적화 신경쓰는 사람도 정말 메모리 하고 이걸 신경을 많이 써야 되고
메모리를 알면은 어떤 언어를 돌리던 간의
좀더 프로그래밍을 빠르고 효율적으로 잘 짤 수 있어요 그게 이유가 뭐냐면
어차피 컴퓨터는 메모리에 들어간 숫자를 어떻게 이해하고 어떻게 쓰느냐가
전 보거든요
심지어는 우리가 말하는 컴퓨터 명령어 라고 하는 컴파일된 언어에서 명령어
들도 결과적으로 메모리에 있는 어떤 정해진 값을 뿐이고
컴퓨터를 그걸 읽어서 어떤 명령어로 인식을 해서 걸 실행시 킹의 전부에요
이거는 명령어 다 이건 데이터가 이걸 아는 것 뿐이죠 그래서 이런 저수준
에서 메모리를 고민을 좀 더 많이 하다 보면 확실히
음 컴퓨터에 대한 이해가 높아져 말도 안되는 버 가 터졌을 때도 이거
어떻게 고쳐야 될지도 볼수가 있고 최근에도 그런 이랬는데
그래서 오늘은 좀 굉장히 디테일하게 들어가서 말이 많아졌는데
이거에 대해 찾아보세요 컴플렉스 더 텍스 보내시라고 찾아보면 더 나와요
그리고 어떻게 하고 어떻게 하는지 저도 처음에 당의 찾아봐서 한국이
때문에 제가 말하는 거 로는 이런게 있다 아 이렇게 가능하구나 숫자가
64 바이트 가 28 바이트가 되거나 이 정도만 알아 주시고
나머지는 찾아가면서 자생을 구현 하시면 되지 않을까 싶어요 그걸 제가
자기 위 찾고
음 아 말 많이 했다 목이 갈라지고 했어 그럼 이정도로 하고
음 머리 아파요 계산 햇더니 뽑혔습니다
