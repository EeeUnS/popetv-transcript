안녕하세요, 포프입니다.

제가 C#이란 언어를 얼마나 사랑하는지는 많은 분들이 아시고 있을 거예요. 어찌 보면 이 언어에 대한 사랑이 C#과 타입스크립트를 디자인한 그 언어 설계자에 대한 막연한 사랑일 수도 있어요. 제가 많은 언어들을 봤지만 프로그래밍 언어들, 제 생각에는 '언어를 만드는 디자이너한테 천재가 있다면 이분이 아닐까?' 생각이 솔직히 들 정도거든요. 그 정도로 인간을 잘 이해하고 프로그래머가 실수 없이 사용할 수 있는 언어를 만들고 있는 게 바로 C#이고, 지금 이분이 마소 직원이기 때문에 다 마소의 '그 사람'이라고 알고 있는데, 사실은 옛날에 마소 전에 Borland가 훨씬 뛰어난 컴파일러와 IDE를 만들 때 그걸 책임지셨던 분이죠. 마소에서 데려가려고 삼고초려를 했던 분입니다. 지금은 마소에서 그냥 날개 달고 훨훨 날고 있는 분이죠. 그렇기 때문에 저는 C#에 잘못된 게 보일 때마다 아주 즐겁게 까곤 합니다. 오늘이 그중에 하나일 것 같아요. 예전에 만들었던 '좋은 언어와 기본 동작'이란 비디오가 있어요. 그때 오늘 말할 내용을 알았더라면 거기에 들어갔을 만한 내용이긴 해요.

여러분 Enumeration 아시죠? 열거형. 열거형의 장점이 굉장히 많아요. 근데 요즘 같은 웹 세상에 열거형이 좋은 점 중의 하나가 내 코드에서는 이 열거형을 (이제 약간) 정형화된 상수, 범위가 정해진 몇 가지 상수를 쓰는데, 실제 json 파일이나 이런 거 찍을 때는 문자열로 바꿀 수 있다면 json 읽을 땐 예쁘게 문자열로 읽고 '아 이게 동서남북이었어?' 코드로 볼 때는 .North인데 실제는 정수값에 대응하는 0, 1, 2, 3 이렇게 되는 거죠. 그래서 굉장히 좋아요. 그리고 아무 생각 없이 json으로 ToString하고 json에서 string 읽어서 Enum으로 변환하는 것도 자동으로 다 해왔어요. 그리고 여기에 사용하는 C#의 함수들이 보통 Enum.TryParse 아니면 Enum.Parse가 있어요. 어... 근데 이게 말도 안되는 숨겨진 동작이 하나 있네요? 이것 때문에 저희가 버그가 한번 발생했었고 그것 때문에 Enum.TryParse를 이제 안 쓰고 저희가 자체적으로 만든 함수를 쓰게 됐습니다.

그 버그가 뭐냐? 자 예를 들어서 어떤 Enumeration 타입이 있다고 생각해 봐요. 동, 서, 남, 북. 동을 0으로 할게요 동서남북이니까. 0, 1, 2, 3 그죠? 동쪽이니까 east죠? 그리고 서쪽이니까 west. 그럼 string으로 west가 있을 때 얘를 Enum.TryParse나 Enum.Parse에서 Enum으로 읽어오면 값이 나오겠죠? west니까 동, 서 1, 1이 나와요. 근데 갑자기 어느 순간 잘못된 데이터가 들어왔는데 TryParse나 Parse가 성공한 적이 있었어요. 뭐였는지 알아요? 문자열로 1이 들어왔어요. 1. west가 아니라 1이 들어왔는데 1을 parsing를 하면 아주 당연한 듯이 west로 parsing이 돼서 나와요. 그래서 그제서야 C#의 TryParse, Enum.TryParse 문서를 읽어봤어요. 정수로 표현한 문자열이나 아니면 실제 문자열로 표현된 걸 둘 다 parsing 할 수 있어요. 읽는 순간 '에라이!' 욕 나왔죠.

역사적으로 보면 이해는 돼요. 왜냐하면 Enum은 그냥 이름 달린 정수거든요? 내부적으로 Int로 저장이 되기 때문에. 그래서 실제 C나 이런 데 보면 Enum과 Int가 코드에 있는데 서로 캐스팅 안 하고 대입할 수 있는 경우도 있어요. 이제 이런 것들 때문에 'Parse를 할 때도 문자열로 적힌 1도 그걸로 parsing되게 해줬겠다'라는 생각은 하는데 갑자기 드는 생각이 '아니 그걸 원하면, Int.Parse를 해서 정수 1로 읽은 다음에 Enum 타입으로 캐스팅하면 되잖아?' 이렇게 하는 게 올바른 방법이죠. 그러지 않고 이걸 숫자까지도 그걸 되게 했다? 이게 되는 순간 특히 public으로 왔다 갔다 하는 json 파일은 지옥문이 열리거든요? 나는 당연한 듯이 Enum.TryParse를 쓰기 시작했어요. 동서 한 번만 들어가야 돼요. 어떤 놈이 장난으로 3 넣었는데 그게 어떤 값으로 parsing이 돼서 들어와 버려요. 그러면 잘못된 데이터 입력 값이 들어온 건데도 불구하고 그걸 의미하지 않은 걸 수도 있거든요? 잘못된 오타일 수도 있는 거고. 그럼 데이터가 올바르지 않은데 갑자기 코드는 정상 작동하는 이상한 상황들이 오는 거예요.

그래서 갑자기 궁금증이 생겼어요, json 역직렬화하는 거. 이거 ASP .NET Core, 웹 프레임워크죠? 거기에서도 Route 같은데 들어올 때 매개변수로 들어올 때 Form Body 같은 경우를 그냥 클래스로 집어넣으면 알아서 json 받아가고 역직렬화해서 나오거든요? '야 그럼 이럴 때는 저게 1로 돼도 되나?'라고 봤는데 다행히 그런 web request 들어온 때는 지네들이 문제를 알았던 것 같아요. 그래서 그거는 바인드 할 때 검증해 주고 잘못된 거라고 말을 해줘요. 이거는 validation 쪽으로 처리하고 있는 것 같아요. 그래서 일단은 코드 자체가 exception은 안 나지만 validation이 잘못됐다고 알려주는 거죠. 그래서 실제 동서남북이 있을 때 1을 web request의 body로 쐈을 때 거기에 들어가 있는 클래스로 역직렬화해도 얘는 validation 오류는 제대로 줘요. 그래서 '아 그거는 했는데 그러면 이걸 파일로 저장해서 읽는 사람들은 그걸 알 방법이 사실은 없다는 거죠. 그래서 기본 동작을 조금 잘못했구나.' 솔직히 제 마음 같아선 정수 지원하는 거 지워버리고 '자 breaking change입니다. 정수를 이렇게 읽으셨던 분들은 이제부터는 Enum.TryParse 하지 마시고 Int.TryParse 하신 다음에 그다음에 그 값을 가져다가 Enum 값으로 캐스팅을 해서 쓰십시오' 이렇게 나오겠죠? 어쨌든 간에 저희는 내부 코드에서 Enum.Parse와 Enum.TryParse를 금지시키는 룰을 넣어버렸고요, 그 대신 자체적으로 Enum.Utils를 만들어서 Enum.Utils.Parse, Enum.Utils.TryParse 그리고 얘는 반드시 문자열로 정의된 숫자가 아닌 것만 parsing하게 바꿨습니다.

어쨌든 간에 재밌었어요. 나도 C# 진짜 오래 사용했는데 '야 이걸 내가 모르고 있었구나...' 근데 많은 분들이 모르고 있었을 것 같아서 공유했어요. 그래서 Enum.Parse는 문자열에 들어간 숫자까지도 올바르게 캐스팅합니다. 괴로운 일입니다. 뭐 요정도 얘기했으면 제가 매우 매우 사랑하는 그녀 C#을 또 열심히 깐 것 같으니 이쯤 하겠습니다.

포프였습니다.