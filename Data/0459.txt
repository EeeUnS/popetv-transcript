이 아니면서 4p 입니다 오늘은 당 어족 프로그래밍에 대해 얘기해 볼게요
사실 이거는 여태까지 제가 만들어온 비디오 들이 이제 하나하나 이제 뭐
이건 이래라 저래라 하고 하는 방어적 프로그래밍에 관한 기법들이 많았어요
이제 그거를 따로 따로 떨어뜨려 놓고 보니까 모든 비디오를 본 사람들은
왜 그런지 아쉽고 또 같은데 그걸 다 안보신 분들이 있다면 그걸 한번에
묶어서 아 방어적 프로그래밍 이란 이런거 다
그래서 나는 이런 이러 이런 구체적인 이제 뭘 해라 하지 마라 는 이제
가이드를 말하고 있다 라고 하기위해서 이 비디오를 만드는 거에요 그래서
어찌보면 여태까지 비디오를 봐 오셨던 분들 한테는 정리하는 개념이고
비디오를 안 보셨던 분들 한테는 아 이게 시작해서 자세한 내용들은 다른
비디오 가서 볼 수 있게 그렇게 하는게 일단 목적 이에요
쓸 딴 뭐 쓰
모모를 살펴보 건지 딴 얘기를 할게요 일단 오늘 얘기를 할 구체적인
주제들은
예외처리 익셉션 그 첫번째 거 두 번째가
gtp 에너지 인젝션 di 라고도 많이 하고 세 번째가 이제 뭐 스트링
하고 뭐 뭐라 그러죠
그 이넘 인 업력 그리고 네 번째가 널 같은거 처리 하는거 뭐 다섯번째
가 매직넘버 같은거 상수 쓰는 것들
구루 그 여섯번째 가 2품 운수 잡는 법
그리고 7번째 가티 리 테스트 dvd 디자인 ts 팁은 디벨로퍼 먼트
그거에 대해 얘기를 할 거에요
여기서 일단 자세하게 살펴보기 전에
한두가지 정도는 확실히 잡고 넘어가야 될 것 같아요
일단 방어적 프로그래밍 하고 자기 방어적 프로그래밍은 다르다 라는 얘기를
하고 싶어요 무슨 의미야 면은
운전할 때 을 운전할 때 이제 아무리 안전하게 운전을 해도 3호가 맨날
나오는 사람이 있고 운전할 때 안전하게 운전해서 사옥 안다는 사람들이
있어요
그게 뭐냐면 나는 안전하게 운전을 하지만 남이 이상한 사고로 칠 때 내가
도안 전할 수 있냐 왜 방어적인 운전 이거든요
그런 개념에서 방어적 프로그램인 오늘 얘기할 거고 그에 비해 1 자기방어
적 이라는 의미도 있잖아요
예를 들어서 딴사람 되어도 요런거 어떻게 했어 그러면 괜히 혼자 자격
되신 먹어 왔고 자기 방어 적으로 나오면서 좀 자기의 감정 때문에 따른
일을 그르치는 경우들 그래서 그런걸 자기 방어적 이라고 해요
제가 오늘 말할 부분은 방어적인 프로그래밍이 지 내 이제 쪽팔린 거 를
구해 보겠다는 자기 방어적인 프로그래밍은 아니에요
그리고 이야기를 드리는 이유는 생각보다 업계에서 방어적 프로그램이라
하면서 자기 방어적 프로그래밍을 하는 사람이 있기 때문이에요
그 자세한 얘는 뒤에서 애가 말씀드릴 거고
그리고 또 한 가지 결정 말하고 넘어가야 될 것은 제 이런 이제 방어적
프로그래밍에 대한 아 이렇게 기 줄 저는 기준이고 국회 줄에 따라서
코딩을 많이 있잖아요 그 기술 때문에 나오는 다양한 가이드들이 있고 그가
이들이 저한테 는 이제 코딩 규칙 코딩 스탠다드 가 되가고 있는 거에요
그래서 제 코딩 스팅 카드는 이미 싶을 보라고 c # 용으로 공개가 되어
있죠
그리고 조만간 4q 아카데미를 열기 때문에 10불 코딩 표준 2
한글화로 도 나오고 이 나올 거에요 그래서 거기에 이제 들어간 거다 라고
생각을 해 주면 되요 그래서 그런 거기에서 본 것들 그리고 제 비디오
작품 것들 합치기 이 거에요
아 서론이 길었죠 이쯤 되서 이제 관심이 없으신 분들은 끊고 나가시면 될
것 같고
관심있으신 분들은 앞으로 좀 긴 비디오 가 될 것 같으니까 차근차근 보면
될 것 같아요
빠를 많이 할 것 같으니 물한잔 마시고
첫번째 예외처리 익셉션 에 대해서 얘기해 볼게요
아 이거 얘기하기 전에 한 가지 원칙을 더 말하고 핵 말하고 가야겠다
죄송해요 좀전에 제가 코딩 스탠다드의 저만의 원칙이 이제 들어가 있다고
얘기를 했어요
그럼 저만의 원칙은 뭐냐 프로그램을 짤때 코드를 짤 때 5가지 기본
원칙을 보통 저는 봐요 첫번째가 프로그래머가 실수 프로그래머가 실수 하지
않게끔 예방할 수 있는 코딩 규칙 코딩 스타일
두번째가 설사 실수가 낮더라도 최대한 빨리 잡을 수 있다
최대한 빨리 문제를 찾을 수 있다 세번째가
아 일단 시간을 낭비하지 않게 이음 이는 뭐냐면 개발에 들어가야 하는
시간이 있고 제품 만드는데 시간이 있고 뭐 좀 제품의 완전성 을 높이고
여러 가지 일을 하면서 시간 드리는게 있어요
근데 어쨌든간에 이제 뭐 어느 업계의 가느냐에 따라 이제 좀 더 안정성이
중요한 게 있고 아니면 제품 빨리 나오는게 중요한게 있지만 웬만한
회사에서는
아
제품 만드는 시각보다 뭐 다른거 좀더 안정성을 높이기 에서 집어넣는
시간이 안전성 10% 올리려고 시간 4배로 놓을 순 없거든요
그런거 개념에서 시간을 너무 낭비 하지 않는 쪽 그런 쪽에 이제 아
쉽게 쉽게 그리고 어찌 보면은 프로그래머 시간을 낭비하지 않고 할 수
있는 그런 안정성을 방어적인 프로그램은 걸 좋아하기 때문에 그런걸 좀
얘기 할 거고
네번째가 이제 굉장히 중요한 건데
아 인간의 지적 능력 우리가 일반적으로 보는 프로그래머의 지적 능력에서
할 수 있는 것들
왜냐하면 아무리 개념이 좋고 아무리 뛰어난 방법이라고 해도 인간의 성향에
맞지 않아서 인간의 본성에 맞지 않아서 인간이
이제 뭐 큰 이 배우는 자라온 환경이 라던가 유전적인 문제 때문에 하지
못하는 것들을 강요할 순 없거든요 그래서 그런 것들이 이제
중요한거 가 직접 수련에서 인간 있을 수 있냐
그리고 마지막 거는 문제는 발생할 때 곧바로 보여야 한다
이 다섯가지 원칙 이에요 다시 말하면 프로그래머 실수의 방 실수 나올 때
빨리 찾기
시간 낭비하지 않기 프로그래머 시간을 너무 많이 낭비하지 않기
적당한 직접 수준의 살 수 있는 것들이 인간이 그리고 문제는 발생하는
것이 곧바로 보여야 된다
이 5가지 원칙 자 그러면 이제 아까 말했던 안 몇 개 어찌 데 이어서
까지 건드리지 살펴볼게요
첫번째가 이제 예외처리 예외처리 음
예외 처리가 뭔지나 쉽게 오고 제가 예전에 예외 처리 관련 비디오를 하녀
설 복귀로 만들었나요
6개 이란 3개를 만들어 놨어요 그래서 그거는 제가 링크를 걸도록 할
거고 그걸 봐 주시면 되고
오늘 할 얘기는 그 거에요 그럼 예외 처리는 아까 제가 말했던 5가지
원칙 중에 과연 어떤거 에 잘 맞느냐 라는 이거든요
프로그램의 실수를 예방할 수 있다
그거는 아니에요 오히려 실수를 촉진 하기도 한다고 저는 생각을 해요
그 익셉션 핸들링 잘 못하는 경우 되게 많거든요
그럴 경우에는 오히려 익셉션 이 털이 는것을 곧바로 잡지 못하고 익셉션
터지는 데도 프로그램에서 돌 돌리고 돌리고 있고 그런 프로그래머가 실수를
못 잡아요
그리고 또 하나가 제가 이 세션에 대해서 굉장히 크게 문제 삼는 게
익셉션 을 함수 안에서 이 제작중인 악의 시작을 하면 은 함수가 12
자리 라며 는 10줄 각각 섹션이 날 수가 있거든요
그럼 9 순간에 그 10가지 나는 익셉션 을 다 고려하면서 프로그래머가
잡을 수 있냐
되게 애매한 부분들이 있어요 고 똑같은 얘기로 이제 두 번째 요건은
실수를 이제 빨리 잡을 수 있냐
모 역 씩 프로그램이 탔을 때 그냥 멈추지 않고 익셉션 처리하며 돌아가는
순간 이 있으니까
그래서 주었고
어 못 시간을 낭비하지 않는다
이것도 좀 애매한 게 익셉션 을 처리하려면 어쨌든 간에 익셉션 처리하는
코드 봐야 되고 어디서 이 끝나는 살펴 봐야 되고 이 트 23 입기
보장해야 되고 굉장히 어려운 부분들이 많아요
그리고 가장 큰 문제는 저는 이제 인간의 지적 수준에서 사람은 기본적으로
코드를
위에서 아래로 있는게 일반적으로 어떤 문서를 주던 뭐 하던간에 사람은
순서대로 일지 2 1 읽다가 여기서 이쪽으로 점프하고 다음주로 있다가
따른 2 천 포 하고
다음주 믿다가 다른걸로 점프하며 는 이미 생각해야 되는 조건이 내가
지잖아요
그 중간에 굉장히 많은 사람들이 로직을 못따라 요 그래서 어쨌든 간에
인간은 1단계 잡고 쭉 있는게 훨씬 어 익숙하고 잘 하기 때문에
멀티태스킹이 안되는 거죠 어떻게 보면은
그런거 에서는 인간의 지적 수준에서 진짜 익셉션 세이프 하게 익셉션
이라도 문제가 없게 코 등을 돌리려는 원칙이 있어요 그럴 정도의 코드를
쓰는게 굉장히 일반적인 프로그램 한텐 어렵다
대부분 어렵다는걸 제가 느꼈어요 그리고 또하나 이제 5번째 원칙 문제
발생한 곳에서 익셉션 나온 곳에서 딱 멈추고 오든지 디버깅 해야되는데
굉장히 많은 경우에는 핸들링을 해버리기 때문에 이제 실수가 생길 수 있죠
일단 문제가 생기는거 해서 못 보는 게 있죠 그 저는 익셉션 은 따른
익셉션 비디오를 보시면 했지만 결국에는 이렇게 판단해야 되어 익셉션 은
정말 내가 컨트롤 하지 못하는 상황에서 뭔가 굉장히 예외적인 상황이
발생했을 때 요 그럼 그걸 어떻게 처리 할 거 아니에요
근데 그 얘기가 뭐냐면 내 코드 안에서 내가 짜고 있는 코드에서 함 중
함수 호출하는 것에서는
이 섹션이 안나는게 정상 이어 기본적으로
왜 아니 어차피 모든 코드를 내 컨트롤 하고 있고 모든 데이터를 내어
컨트롤 하고 있으면 익셉션 2 어깨 코드를 짜는 되요
그 익셉션 이날 수 있는 데이터를 안 넣어주면 되요 근데 문제는 언제냐
하면 익셉션 의 날 수 있는 데이터가 외부로부터 들어올 때가 있죠
웹 리퀘스트 라던가 이런거 에서 외부에서 내가 컨트롤은 데이터 간의 날
나왔어
아니면 내가 이제 또다른 얘는 이제 아빠의 시스템에서 파일을 읽으려고
하는데 파일이 있었는데 읽는 순간 빨리 지워 졌어
왜 콧 프로그램이 도는 순간 다른 프로그램이 그 파일을 지워 버릴 수도
있으니까 사람이 지울 수도 있으니까
이런거는 내 코드에 범위가 아닌
이제 따른 범위 내가 컨트롤할 수 없는 것에서 데이터가 들어오 거야
데이터를 액세스하는 문제거든요
이런 경우에는 익셉션 쓰는게 맞아요 근데 익셉셔널 쓰되
딱 그 경계가 바뀌는가 파일이 있는 순간 딱 빨리 잊고 어 오빠 일이
아닐 켰어요 익셉션 처리하고 내부 코드에서는 이제 파일이 안 일으켜
쓰니까 너를 반 하든 뭐 불리언 값을 반환 하던 해서 파일을 못 읽었을
때는 철이라는 게 정상이고
외부 데이터가 들어왔을 때도 외부 되있다 들어왔을 때 이 값이 올바른
값이 인가를 일단은 다 검증을 해요
밸리데이션 하고 문제가 있으면 곧바로 의미 즉 해버리고 끝내 버리면 내고
리퀘스트를
문제가 없으면 내 시스템으로 들어오는 거죠
그리고 시스템으로 들어오는 순간 그 데이터를 의미 유한 거기 때문에
익셉션 이날 수 있는 여지는 없다 라고 판단하고 이제 코드를 짜라 보면은
제가 좀 전에 말했던 이제 인간은 일직선의 있는 다는거 그 모든걸 일직선
이룰 수가 있어요
그럼 문제가 없어요 그런 부분이 예 좋고 자세한건 익셉션 코드를 살펴
보실 때 익셉션 비디오를 보시면 되요
그래서 익셉션 은근한 쓰면 다른 것에서 또 실수 하는 걸 어떻게 막느냐
그러면 제가 예전에 몇번 얘기했던
아제 어썰트 를 가는 법이 있구요 어썰트 를 박아서 디버그 중에 모두
문제 잡아야 되고 그리고 컴파일러 나 컴파일러가 아니지 그 개발 도구가
공짜로 주는 정적 분석 도구들이 있어요 그거 를 쓰면 은 개발자 의
시간을 하나 들이지 않고 버튼 하나 누르는 것만으로도 모든 거가 이제
모든 건 아니죠 많은 것들에 이 문제를 찾아 주기 때문에 그 문제 해결할
수가 있죠
수입세 액션은 경계가 바뀐 데 좀 쓰자
그 안에서는 모든 코드는 익숙해 없이 본다고 가정을 하고 만약에 무슨
문제가 생긴다면 그건 어썰트 나 정적 이제 분석 등을 통해서 미리 미리
뒤에 이때 잡자 실시간 서버 에서 괜히 익셉션 난다고 핸들링 한다고
벗을 퍼기 2 지금 돌게 하지 말자 얘기해요
두번째 와 비디오 정말 빌어 지겠다
di 디펜스 인젝션
이거는
어찌 보면 되게 좀
사람들이 실수를 많이 하니까 잘못 이 않은 부분들이 있어요 다시는 이
부분이 그 op 원칙에서 보면은
인 벌수 오브 컨트롤 인가 뭐 그래서 이제 아 디펜스를 줄이는 방식이
있어요
그래서 그거에 한 방법으로 이제 di 를 하는 것뿐인데 ioc ers 건
추려 ioc 를 하는 것 자체가 di 라고 생각하는 사람도 있어요 그건
전혀 상관이 없어요
di 안 쓰고도 ioc 는 원래 가능하게 정상 해요 근데 di 라는 결국
뭐냐면
제가 예를 들어서 어떤 인터페이스가 클래스 인터페이스 할 때 인터페이스가
제일 프로그램 안에 있어요
그럼 이 인터페이스의 구현 체는 뭐가 되냐 라고 할 때 이걸 하는 방법이
두가지 정도가 있다고 보는 거에요
하나는 내가 직접 클래스를 구현체를 만들어 놓고 그거를 코드에서 뉴 그런
클래스 에서 그걸 만든 다음에 대입하는 법이 있고 아니면 di 개념으로
가면은
이제 di 에서는 그 뉴 클래스 하는게 아니라 어느새 더 파 이름 헤더
파일을 만드는 거예요
2 인터페이스 정은이 클래스를 만든다 스코프는 무슨 뭐 글로 버릴 수도
있고 아
싱글턴 이어 아니면 뭐 리퀘스트 안에 있는 스코프 수도 있고 아니면 은
만들 때마다 새로운 이스터 수 만들 수도 있고 그런 식으로 어떤 세라
파일의
2 인터페이스 용 구현체 는 이거라고 설정을 해주면 프로그램 실행중에
이제 자동으로 그 인터페이스를 쓸 때마다 그 클래스가 나오는 거에요 저는
이거를
아 이제
뭐 아이디어나 알겠는데 솔직히 이게 가장 이제 유명하게 된 계기가 사실은
tdd 쪽 하는 사람들이
유니테스트 하게 따고 뉴 이 테스트할 때 테스트하는 클래스가 실체 클래스
장 달라야 되는 경우가 있으니까
그거를 디아 2를 처리하겠다 그러면 코드 알아도 안 바꾸는 데 아테스트
돌릴 때는 테스트 클래스 로 돌리고
워커 클래스 도 있고요 실시간 서버 돌릴 때는 실제 이제 구현체 가
나오도록 제대로 된 구현체 가 나오도록 세팅 하겠다
그래서 많이좀 퍼진 게 있어요 이거는 전에 비교해서 말했지만 그런 용도로
쓸 거라면 이건 인터페이스의 남용이 있고요
아 이런걸 좀 더 자동으로 처리해 주는 제품들이 나오고 있죠
예전에 설명했던 타임 먹이 라던가 그것도 링크를 벌 수 있으면 걸께요
그런것들 해결이 되는 거에요 그래서 유니테스트 일단 집어치우고
그럼 di 만을 갖고 얘기를 할게요 di 의 가장 큰 문제점이 뭐냐면
아니 장점은 뭐냐면 내가 클래스를 바꿀 때가 있어요
나중에 가다가 이 클래스 말고 다른 클래스 쓰자 그 바꿀 때 뉴 그
클래스 하는 걸 다 찾아갔고 손수 안 바꿔도 된다
이런 장점이죠 근데 그의 b 의 단점은
실제 프로그래머가 그 빠 일어나 실제 그 클래스 인터페이스 쓰는 파일에서
볼 때 아니면 그 코드를 볼 때 아니면 로그 치킨 거로 본다 본다던가
이 클래스가 뭔지 알 방법이 없어요 그 세터 파일을 따로 여러 봐서
봐야만 되는거예요
그래서 그런 부분에서는 오히려 한눈에 어떤 기원 체를 만드는지 안보이기
때문에 나중에 디버깅 하거나 이럴때 좀 에러 사안이 있어요 사실 그래서
아까 말했던 원칙으로 얘기하며 는 프로그래머 실수 예방하는 효과 솔직히
없구요
왜냐하면 은 뭐 내가 코딩을 짜다가
실수하는 그 문제가 아니라 이거는 내가 이 인터페이스가 당연히 어떤
구현체 라고 가정하고 썼는데 그 구현체 가 아닌 경우가 있을 수가
있거든요
그리고 나는 분명히 코드를 고쳐도 놓는 데 따른 애가 세트 파일 바꿔
갖고 빠지는 경우도 있고 물론 엄밀한 op 개념에서 말하면 인터페이스와
같으면 모든 구원은 제대로 도라의 정상이지만 실생활에서 는 그렇지 않은
경우 되게 많아요
아무리 열심히 노력을 해도 구현체 마다 따로 하는 것들 그런 과정들이
오브젝트 밖으로 퍼지는 경우들이 충분히 있어요
그래서 프로그램을 실수 거울 더 잘 발생하고 요 써본 결과
실수 시 최대한 빨리 문제를 잡을 수 있다 도 솔직히 아니에요
그만큼 딱 한눈에 무슨 클래스가 들어온지 만들어지는지 보이지가 않기
때문에
크럼 또 이제 인터페이스 맞는다고 모든 클래스 만들때마다 인터페이스
만들고 클래스 하나 만들고 실제로는 현재 9 연체가 1 일 지라도
인터페이스 클래스를 만드는 경우가 있죠
제가 전에 말했던 인터페이스의 남용 그리고 인터페이스 클래스 만들어 나고
시간낭비
브루 9 이거를 그러면 di 를 안쓰고 실제 클래스를 쓰면 은 오히려
코드 박군의 시간낭비가 많지 않냐 바꿀 때마다
란 얘기를 할 수도 있는데 첫째 코드 바꾸는 일이 그렇게 많지 않고
요즘 id 가 매우 매우 매우 좋아져서 그 한번의 바꾸죠
그냥 뭐 이름 변경하기 로 바꾼 단어가 아니며 전체 차에 3번의 뒤집기
로 바꾼다 건가
실제 그거 바꾸는 데 걸리는 시간은 1
기껏해야 30초 그 정도밖에 안 걸려요 그래서 시간낭비 중에 측면에서는
차라리 dr 안쓰는게 한거고
아 시간 절약 측면에서
그리고 적당한 인간의 지 척수의 쓸수 있냐 이거는 사실 쓸 수는 있는데
이제 문제는 뭐냐면
아까 말했듯이 인터페이스 를 보면 그 순간에 내가 클래스가 구현체 가
뭔지 몰라요 그럼 그 구현체 가 뭔지를 찾아가는 과정을 얼마나 인간이
열심히 할 거냐
사람들은 생각보다 개 흐르기 때문에 대충 눈에 보이는 것만 보고 넘어가요
하나하나 한 눈에 보이지 않으면 가 찾아 보잖아요
그런 의미에서는 구현체 가 직접 코드의 나와 있는게 훨씬 이 일반
사람들이 실수 없이 편하게 그지 척수에서 쓸 수 있는 방법이기도 해요
그럼 5
문제발생 한것에 잡는다 이거는 뭐 인터페이스 클래스 똑같은 얘기죠
9 연체가 실제 있으면 어떤 구현체 인지 알고 그 구현체 안에 가서
브레이크 포인터 걸고 볼 수 있겠지만 그게 아니라면 인터페이스에서
브레이크 포인터 걸고 실행될 때 어떤 9 연체가 인지한 한단계 한단계
봐야 되고 약간 좀 더 애라 사항은 있어요
그런 부분이 있고 음
또 하나는 이런 부분도 있어요 이거 이건 어쩌면 되게 되게 핵심적인 문제
일수도 있는데
컴파일 도중에 오류가 잡히는게 실행 도중에 오류가 잡히는게 좋아요
예를 들어서 di 를 하고 있는데 세로 파일들이 있잖아요 그 어떤
클래스를 만들 건지 그 3 러비 제대로 됐는지 안됐는지 는 코드를 실행해
봐야 확인할 수가 있거든요 근데 인터페이스에서 인젝션 안쓰고 곧바로
클래스 해서 구현체를 만들어서 코드 짜 벌여 타면 은 나중에 뭐 생성자가
바뀌어 따거나 나중에 어떤게 바뀌었을 때 뭐 흰 텍셀 같은걸로 컴파일이
안되는 경우가 바로 떠요 그래서 실제 di 라면 실행하고 나서 고쳐야 될
문제들을 di 를 하지 않으면 컴파일 도중에 잡을 수 있기 때문에
아 뭐 디버깅 속도의 훨씬 유리한 점이 있어요 그래서 시간 낭비하지 않는
것 문제 빨리 잡는거 이런 부분에서는 di 를 안 쓰는게 훨씬 이용해요
두번째 끝났고 와 1시간짜리 비듬 하루 세 번째는
아 이거는 잡아 쪽에서 특히 문제인것 같은데
자바프로그래밍 많이 하신 분들 보면 은 굉장히 많은 것들을 스트링으로
비교를 해요 스트링을 쓰냐 이니 뭐 레이 션을 쓴 야차 이거든요 e 넘
타이
왜냐면 잡아 쪽엔 한동안 이놈이 없었다고 들었어요 지금 나왔다는 얘기도
들었는데 제가 확인을 제대로 안 해봤고
그 예를 들어서 음
그 무슨 데이터가 들어올 때 이 데이터에 들어올 수 있는 유효한 값 이
예를 들어서 동서남북 4개 밖에 없어요 근데 이제 자바 프로그래머들은
이거를 보통은 0
서는 일 이런식의 숫자로 비교하거나 음
가독성 좀 떨어지죠 아님 때는 이것을 그냥 스트링으로 비교를 해요
노스 사우스 음 아 이런식으로 근데 문제는 뭐냐면 스트링은 어떤 데이터도
눌 수 있다 올 수 있는 거잖아요 그래서 스트링 에서 만약에 동승한 북이
아니라 여기다가 바보 이렇게 노도 일단은 코드 안에 들어가고
그럼 함수 안에서 2 jb 게 바보 회가 동서남북 중에 하난 지를
판단하는 로직을 닫을 수밖에 없어요
근데 그렇지 않고 인 유머 데이터 타입을 쓰면 은 이넘 타입이죠
이넘 타입을 쓰면 쓰면 딱 그 받을 수 있는 값을 4개로 시정을 해먹고
그 타입을 이제 매개변수로 받으면 되니까 그 타입이 아닌 게 들어온 순간
이제 에러가 나게 되어 있죠 그래서 그런 2 유오성 검사는 아까 말했듯이
익셉션 할 때 말했듯이 처음 바운더리 바뀔 때 경계가 바뀔 때 딱 처리를
해서 것을 이제 걸 해볼 수가 있어요
그리고 또하나 장점이 이런거 스트링으로 잘못 넣고 이라는 것들은 실수 로
함수가 원래는 동서남북을 받는 함수 인데
아 뭐 아침 저녁을 받는 이제 그 데이터 스트링을 실수 록 그런 함수를
호출할 수도 있어요 아침 저녁을 판단 하고 싶은데 실수로 동서남북 함수를
호출할 수도 있어
이게 이넘 이었다면 컴파일러가 잡아 주거든요
컴파일 중에 스팅이 라면은 실행하지 않는 아 잡을 방법이 없어요 그래서
이것도 이제 아까 말했던 5가지 원칙 중에
전부다 어긋나는 거예요 스트링을 쓴다는 것 자체가 12345 다 어긋나는
거고
사실은 이제 인 유머 로이터 타입을 써야만 이놈 타입을 써야만
제가 이념의 레이 터 라고 말 잘 못하는데 인 유머 레이 터 라고 인어
먹은 달라요 사실은 그 이넘을 써야만 이제 아까 말했던 그 5가지 원칙을
다 지킬 수가 있죠
이 그래서 세 번째 건 얘기했고 네번째 거니 널 처리
널 이라고 있잖아요 그쪽 전에 비디오 만들었는데 이 덜 처리에 문제가
뭐냐면 그 가만 언어 만드시는 분들 마다 그런 얘기하는 사람들이 많아요
이자 이 언어에서 너를 눈 게 내 큰 실수였다
이런 식의 길만이 해요 널이 좋긴 좋은데 그만큼 프로그램의 실수를 많이
할 수 있는 부분이기도 해요
왜냐 예를 들어서 제가 스트링을 받는 함수가 있어요 이견 이 함선은
스트링을 뒤지는 남 써요
근데 스트링이 실제 스트링이 들어올 수도 있고 널이 들어올 수도 있잖아요
그럼 널이 들어오면은 곧바로 반환하거나 에러 코드를 m 나거나 이런
코드를 짜야 돼요
앙 그러고 너를 널 룻 에 있는 스트링을 뒤집으려 가면 너 리셉션 이나
버리거나 나 버리거나 클래식 않아 버리니까
그래서 이런 경우에 코드 이제 잘못 자신은 보면은 함수 마다 너 릴
경우는 이렇게 너를 경우는 저렇게 이거를 타노 여 만 어리면 너 리셉션
쏜다 이런식으로
근데 이거는 정말 말이 안 되는 방법 중에 하나는 게 뭐냐면
아니 내가 아까 전에도 말했지만 일단 내 코드에 들어온 데이터는 다 유아
더 가정하자 그랬잖아요
그리고 실제 는 내가 컨트롤할 수 없는 데이터가 읽어 들어오는 부분
거기서만 유효성을 검증 하자
그거를 잘하면 은 제 함수들은 뭐든지
매개변수는 절대 널이 아니고 반환값은 절대 널이 아니다 라고 짤 수가
있어요
기본적으로 그쵸 그러면 그 모든 코드 마다 만약 n 어리면 널리 3편
던지고 이런게 필요가 없는 거예요
그냥 그게 가능해요 왜냐면 아까 말했듯이 데이터를 이미 검증 해서 미제
그해 버렸으니까
내 시스템에 들어온건 달 유하다 그래서 모든 함수에서 그 검사를 하고
모든 함수의 반환 땀에서 너를 받아야만 한다고 가정을 하면 되는거예요
근데 가끔 널 처리를 해야 될때가 있어요
왜냐하면 은 여대가 지금 만약에
어 2 유저 id 가 뭐 날 모임 에러 드레스 가 뭔지 풀 불러 오려고
했는데 뭐 이메일 주소가 아직 안 넣었어 그러면 개가 이메일 주는
않았다는 것을 표현하기 위해서 너를 만날 수도 있거든요
그런 경우에는 함수 이름에 겟 유 전의 5와 널 이런식으로 해서 너를
반하는 것을 확실하게 보여 주게 하자
그리고 매개 변수도 일을 해서 제가 매개 변수를 이름을 봤는데 이름이
정말 이름이 없는 사람이 있어
그래서 이 사람은 무명씨 아 그런 경우엔 얼이 들어올 수 있다면
매개 변수 이름 지울때 스트링 하고 널 아니다
내 임 오와 널 이런식으로 해서 매개변수 나 이제 함수 이름에서 분명히
게는 너를 줄 수 있는 애라는 것을 확실하게 해 주면 되요
그런 식으로 처리하면 된다
이 이야기가 되게 제가 처음 말할 때 다들 번째 보인다고 얘기해서 쓸 것
같은데 옛날 비교에서 실제 c # 어전 8에서 이런 일을 하려고 하고
있어요
시사 8에서 모든 데이터 타입을 널이 봐 떨이 될 수 있는지 널이 안 될
수 있는지를 프로그램 상에도 놓게 해서 너를 못 받는 걸로 표현되어
있는데 이 창이 있는데 코드 어디선가 넣을 포인터를 집어넣으려면 집어
넣을려고 하면 컴파일 시간에
원인임을 주던가 에러를 주던가 로 그
그런 스펙을 만들려고 하고 있어요 그래서 이거는
모든 그 개발자가 똑같이 겪는 문제 곡 제가 생각했던 해결 벗과 시샵
쪽에서 해결하는 생각 생각 법이 비슷하니까
뭐 되겠구나 시샵 쪽에선 이게 들어 올 거니까 시작으로 쓰면 되고 크게
아닌 언어들은 제가 말한 것처럼 기본적으로 모든 프로그램에서 너 를
반환한다
너를 바나 할 때는 이름에서 명백하게 나오게 한다 라고 하면 되요
그래서 이것도
아까 말했던 원칙에 딴 말하면 널 널 처리 같은것도
똑같은거 이것도 사실은 이제 널 처리를 안 하고 널리 섹션 안 던지고 뭐
그냥 너 어릴때 리턴하는 경우 없으니까
아 넣을 이 잘못 들어오면 문제가 생기면 바로 보여요
그리고 프로그램을 실수 예방할 수도 있고 실수 한번 빨리 잡을 수도
있어요 거다 딱 멈춰 버리니까
3 마디를 시간 낭비하지 않는 거 되게 중요하고 가장 큰 것은 인간이 지
인간이 시적 수레에 쓸 수 있어요
데이터가 들어 왔는데 모든 데이터가 예외 상황이 있다고 가정을 하고 널
체크 해야 되는 거 모든 함수 마다 그래야 되는거 굉장히 피곤하고 놓치기
쉬운 부분들이 거든요 근데 기본적으로 그런 일이 없다고 가정 에 넣으면
은 그 처리는 저위 딴 어이 샀다 라고 가정하면 사람들은 되게 쉽게
코드를 짤 수가 있어요 로즈의 좀 집중을 할 수가 있고
다섯번째 와 3개 밖에 안남았어
매직넘버 매직넘버 라는 게 뭐냐면 코드에서 예를 들어서 숫자를 늘 때
이제
변수의 이름 붙여서 상수의 이름 붙여서 뭐 컨테스트 인 트 한 다음에
이거는
넘버원 스치던 치 모 맥스 스트러츠 학생 총수 이렇게 서 500
이렇게 정할 수가 있는데 그게 아니라 숫자로 500 을 천 사람도 있어요
그럼 나중에 코드 보다 보면은 이 502 모름 이 하는 건지 모르겠는
거야 그래서 그런것 때문에 이렇게 숫자를 두고 봤을 때는 차라리 이거를
삼수 화 시켜서 이름 달 이상 수화를 시켜서 변수명을 주는 거죠
그 변수명을 쓰라고 해요 이거는 되게 당연한 건데 음 안하시는 분들이
아직 두 점 있긴 있어요
뭐 이거는 그냥 아까 말했던 원칙 제 1 2 3 4 5 중에 네 가지는
확실하게 완성을 하고요
이제 시간 낭비는 당연히 숫자 쓰는것 보다는
변수 만드는게 좀 더 시간을 걸리는데 한번 쓰는게 별로 오래 걸리지 않고
그리고 나중에 디버깅 잡을 때 디버깅할 때 더 쉽게 코드가 뭔지 를 알
수 있기 때문에 전체 군 시간을 아 절약하는 효과가 있어요
그래서 이런 것들은 매직넘버 는 쓰지 말고 변수 해서 쓰자
이건 중요하고
여섯번째는 이거는 저도 최근 들어서 이제
모르겟어 이게 왜 이런 사람들을 최근에 많이 맞는지 모르겠는데 이 뿜은
얘기 했고요
이프 문을 하면은 함수 같은 데서 보통
뭐 값이 들어 왔는데 이 부문으로 뭐 체크하고 이 조건 만족하고 저조 건
만족하고 저조 건 만족하며 는 이런 행동을 해라 라고 할 때 사람들이 이
부문의 3개를 1편을 1 2 3
그러면 이 품은 했다 이프 문 때문에 들여쓰기 하는거 인벤 테이션 하는게
3단계로 가거든요
그럼 코드를 읽다 보면 어느 순간 이프 가기 나왔고요 l l 스 가
나왔는데 이게 어떤 애쓴 지 모르겠는 거야
이거를 일단은 옛날에 모든걸 함수와 하라고 했던 그 이상은 진영에서는
그이 품은 안에 들어가 있는 코드가 모세 내 줄이 넣으면 그 함수로
만들어서 함수 호출하는 지고 얘길 했었어요
이거는 별개의 얘기지만 것도 함수를 유지 보수하는 데 굉장히 복잡해 지고
잘못된 좋은 이었고
이런 경우에 대해 간단히 해결 방법이
그 아닌 조건들을 찾은 다음에 그 조건이 안 되면 곧바로 함수에서 반환
해 버리면 되요
그대 예를 들어서 이 함수에 들어왔을 때 조건이 이거 이거 이거 일대
이걸 해라 였으면
함수로 잘때 조건이 첫 번째 게 아니면 m
그 m 했으니까 첫 번째 조건은 없었잖아요 것처럼 2가 이 조금만 신경
쓰면 되죠
두번째 에서 두 번째 조건이 아니면 다시 기타
그러면 이제 1가에 조금만 신경 쓰면 되요 세 번째 조건이 아니면 m
그러면 그 다음의 코드는 무조건 세 가지 조건이 아니기 때문에 이제
논리적으로 그냥 무조건 잘 작동하는 그런 조건이 거에요 이게 되게 중요한
게 뭐냐면 아까 말했던
사람들의 사고방식 사람들은 기본적으로 한 단계를 쭉 읽어 오는 걸
좋아해요 근데 이 조건 맞고 자 적어 받고 저작권 맞고 3가지가 맞다는
걸 판단하고 있는 순간 이미 헷갈려 10
2 조 건 아니고 조건이 되면 어떻게 되지 이런 것들
조건이 3개국 참 어지지 있으면 이에 3승 하고 같으니까 8가지 조건
이거든요 사실은 좀 너무 복잡해 줘
그거에 비해 아까 말했던 것처럼 일찍일찍 조건이 틀렸을 때
파란 해버리면 이것을 얼리 액세스 시 라고 하거든요
그 반환을 해버리면 이런 문제 지금 없어져요 프로그램의 실수의 방안도
좋고 실수 시에도 빨리 잡을 수 있는게
로즈 글 읽어 들이게 빨라요 아 이거 아니고 적어 허용한 하고 접어
허용하고 그러면 이제 이해를 하는구나
이렇게 볼 수 있고
뭐 시간 낭비는 비슷한 것 같으니까 뭐 원래 씻어 아니든 똑같은 거고
아 적당한 인간 수준에서 훨씬 잘 쓸 수 있는거구요
그리고 또 문제 발생하는 곳에서 잡는다 아닌다
이것은 디버깅이 조금더 수월한 거 외에는 별 게 없는 것 같아요
마지막 tdd 음 이거 때문에 이제 얼마 전에 되게 2
제 티비 비디오도 안 본 사람들이 이제 tdd 한다 면서
되게 약 팔고 나 였을때 이제 제가 말하는 걸 잘 이해를 못했는데
아 tdd 는 일단은 그 뭐가 장점이 뭐가 단점이 지는 얘기할게요 장점이
없는 건 아니예요
첫번째 프로그래머의 실수를 예방할 수 있다
이거는 절반은 맞는 얘기에요 왜 절반이 많냐
일단 내가 캐스트 코드를 쓰고 구원을 했기 때문에 그 테스트 코드가 돌지
않으면 구현에 뭔가 문제가 있다고 볼 순 있어요
근데 왜 절반이 라고 얘기 하냐면 tdd 는 기본적으로 이제 구현 자가
테스트 부터 먼저 만드는게 기본적 이잖아요
그러면은 내가 이미 구원을 잘 못할 정도로 비지니스 로직을 잘못 이해하고
있는데
테스트 풀 테스트 코드가 제대로 나와 쓰린 없어요 그러니까 bgs 로직에
대한 오해는 이미 내가 잘못하면 테스트도 안잡혀요
그게 아니라 내가 이해한 스펙 때로 코드가 안 나왔을 때만 잡을 수도
있는 거죠
근데 그거는 다른 방식으로 쉽게 잡을 수 있는 거기 때문에 그 부분에서
정말 캐스트 내가 이해할 오직 때로 코드를
아주 못자는 사람들은 별로 없거든요 문제 생기고 d 봉하고 고쳐나가는
과정은 당연히 있지만 과연 그 데이터 워킹 까지 하고 위 테스트 작성하는
만큼 이 의미가 있을까 할 정도로 가성비 해서 안 맞아요
그럼 이거는 얘기는 뭐냐면 시간낭비가 엄청 많아요 세번째 더 문젠데
내가 테스트 코드를 작성하는 데 드는 시간에 비해 내가 얻는 그 제품의
퀄리티 제품의 완성도는 솔직히 그렇게 높지가 않아요
tdd 유니테스트 기반으로 는 그리고 그게 높아진다는
그 통계도 없고 td 기반으로 한 제품들이 훨씬 더 튼실한 것도 아니에요
현재까지 나온 것 중에는 td 라 안 한 제품들이 더 튼실하게 도 많아요
사실을
둘다 하면 다다미 튼실하고 그건 어쩔 수 없지만 그래서 일단은 실수를
막을 수 있다 절반 그리고 세번째 시간 낭비 하지 않기는 최악이다 사실은
실수 지 최대한 빨리 잡는다 이 장점은 있어요 제가 아까 말했듯이 테스트
코드에서 잡을 수 있는 실수를 했을 때는 빨리 잡을 수 있어
4 그 테크 문제가 실제 발생하는 문제에 절반도 안될 거에요
기본적으로 세 번째 나간 내 얘기 같고
적당한 인간의 지적 술에 쓸수 있냐
이것도 되게 재미있는 건데 음 내가 이해하는 소스에 쓸 수가 있어요
근데 이 문제가 뭐냐면 내가 아무리 이해하는 수제 테스트를 써봐야 그게
정말 비지니스 로직에서 이해하는 테스트 수준은 아니에요
그래서 정말 제대로 된 프로그램이라면
문제는 위 코드를 프로그래머 짜는게 아니라 누군가가 제 3자가 테스트
플레이를 잘 만들고 그 테스트할 수 있는 계획이 있고 그걸 자동화할 수
있다면 더 좋고
그리고 제티 게 장점이라고 하는 것 중에 또 하나가 스펙의 일찍 나온다
왜냐하면 테스트 플랜을 만들기 때문에 못했 코드를 만들기 때문에 그만큼
이제 어떤 스펙을 만들 거에요 지에 대한 고민을 많이 할 수 밖에 없어요
그러면 그런 스펙 나오는 건 의미가 있는데 이거는 솔직한 얘기로 tdd
가 아니어도 이걸 제대로 하면 되는거예요 스펙 제대로 뽑고 캐스트 플랜츠
대 로 나오면 되는거예요 그 테스트 플랜이 굳이 유니테스트 로 돌릴 이건
없어요
그러면 그게 말했던 이제 인간의 직접 3 쓸수 있냐 라는 것
자가당착 쪽으로 쓸 수 있다 라는 생각을 해요 근데 정말 이게 제품의
굉장히 큰 도움이 되냐 라고 보면은 그렇게 큰 두 딸은 테스트가 더 큰
도움이 된다 고 얘기할 수밖에 없어요 저는 그런 의미에서 좀 크게 있고
그리고 또 하나가 문제가 뭐냐면
유니테스트 는 기본적으로 내가 짠 테스트를 내가 짱 코드가 패스하는 개념
이에요
그렇다면은 나중에 만약에 코드에 문제가 나왔을 때 따른 기능이 들어 왔을
때 이 코드가 망가졌을 때 어떤 일들이 일어나면
원래 유이 캐슬을 만들어 놓고 그 코드를 패스 한 사람이 있죠
그 사람들이 약간 자기방어 조리 되요 나는 내 가슴 코드다 테스트 했고
다 패스 했기 때문에 코드는 괜찮다
이가 지금 뭔가를 바꿔서 고장이 나는 거니까 니가 가서 고쳐라
이런 식의 솔직히 약간의 자기 방어적 이 되는 개발자들이 시스템에 선
조금 나와요
그래서 어찌보면 은 이제 좀
이제 이게 광 영어 그러나 아닌데
좀 약간 7 여기 좀 많이 모자른 분들이 tdd 를 굉장히 좀 선호하는
경향들이 있어요 사실은
아닌 사람들보다 그 이유는 제가 볼 때는 그런 자기 방어적인 수단도 있기
때문이 아니라는 생각을 해요 그래서 뭐 이런 광역 어그로 많이 고 그냥
제가 주변에 통계를 봤을때 좀 그렇다 라는 얘기 정도로 생각을 해 주시고
뭐 문제를 발생한 곳에 잡는다는 다섯번째 원칙을 일단 뭐 어쨌든 간에
충족을 하죠
td 를 다시 얘기 라며 는 실수 시 최대한 빨리 잡는 것 그리고 문제
발생하는 것에 잡는것은 굉장히 좋은 방법이긴 하구요
실수 예방을 하는 차원은
의무 스럽고 아 적당한 인간 수준의 쓸수 있냐
5 2 뭐 티 리 수준에서 되는데 실제 제품의 퀄리티를 높이는데 에서는
아닐 가능성이 높고
그리고 가장 큰 누나 그리고 아까 말 때 자기 방어적인 자기를 방어하는
요소로 잘 쓸 수 있는 계기가 되는 것도 있어요
그리고 가장 큰 문제는 시간 낭비가 너무 크다
그러니 것과 나 뭐 뭐냐 그러면 전에 비디오에서 엄청 많이 말했어요
자동화 테스트를 해 라 스모크 테스 테라 & tests 테라 인테르 50
테스트 해라
모든 기능이 던지 제품 달에서 확인을 하고 거기서 문제가 생기는 것만
고쳐도 있다는 충분하다
단 이 제품들이 사람의 생명에 영향을 미치거나
이제 이거 잘못되었고 핵미사일 날라 가거나 비행기 떨어지거나 뭐 의료 쪽
군사 쪼 이런 쪽에서는
당연히 오토메 잇힝 테스트하고 스모크 테스트하고 인텔의 책도 하지만 그
추가적으로 위 테스트까지 하면서 시간을 내 대로 많이 쳐먹고 5배로 많이
써 먹어도 인간을 죽일 순 없기 때문에 그 정도의 노력은 들이 만 하다
라는 건 맞아요 근데
많은 개발자들이 그렇게 중요한 소프트웨어 만들지 않게 있거든요
그 상황에서 모든걸 td 가 들어가고 모든 것의 테스트 코드를 쓰겠다고
하는 순간
아마 그 제품 형에게 본인의 효율성이 엄청나게 떨어질 거예요
제품 만드는 속도 자체가 그리고 그 순간에 그렇게 되면 될수록 본인의
입지가 조 mag 는 부분도 있을 거에요 그래서
td 가 맞는 아니다 td 가 장점은 있지만 이렇게 많은 장점이 있고
그래서 모든 걸 td 로 가는 사람들
무조건 t 로 해야 된다고 하는 사람들이 요즘 약 파는 사람이 되어 갔고
그리고 이제 그런거 한다고 그런거 좀 한다고 막 하면 좀 생각없는 개발
지역에 많이 듣거든요
그 얘기가 그 거에요 td 가 한번 화 인기를 끌었을 때 문으로 갖다가
다들 이제 회사 풀 낭비하고 회사 시간 낭비하고
이런 걸 들이 좀 나서 그래서 뭐 그정도 그래서
7 같이 말했어요 거의 40분 동안 말했기 때문에 다음 bd 없습니다
저는 40분 얘기하면 비디오
많이 만나요 힘들어요 정리를 하면은
되게 빨리 정리할게요 아 코딩을 이제 방어적인 코딩을 어떻게 하냐 얘기를
한 거예요
그리고 저는 방어적인 코딩 이라는게 자기 방어가 아니라 이제 프로그램이
문제없이 씨스 나오는 빨리 지 않고 벅스 빨리 잡는 쪽 그런거 리지
방어적 이라고 생각을 해요
그럴 때면 저는 5가지 원칙을 고수할 수밖에 없는데 프로그래머 실수
예방할 수 있는 거 실수 할 때 최대한 빨리 되는거 시간 낭비하지 않는
겁니까
방어적 방어적 코딩을 하기 위해서 시간을 너무 쓰지 않는 거 그리고
인간의 지적 수준에서 누구나 쓸 수 있는 프로그래머 정도라면 은 그리고
문제가 발생할 때 바로 잡을 수 있게 해주는 것 5가지 원칙 5
그 원칙에서 좀 요즘 잘 못쓰고 있는 것들 잘 못쓰고 있는 것들 아니면
좀 베스트 part 3 고까지 말했어요
익셉션 아 최대한 쓰지 말고 경계에 새 맞서라
그 대신 정적 못 분석이 라던가 뭐 뭐 그런거를 더 해라 써 틀을 쓰
던가
그리고 dit 에너지 인젝션 가능하면 쓰지 마라 써봐야 생각보다 도움이
안 된다
그 di 로 해서 얻을 수 있는 그
뭐 코딩 30초 추가로 안 r&d 도 별로 없다
세번째 스트림과 이넘이 있으면 반드시 넘어서라
스트링은 쓸 가치가 없다 그 상황에서 그리고 네번째 널 쩌리 하지마라
코드는 기본적으로 널이 반환하고 널 매개 변수를 받지 않는 그 가정으로
써야 되고
너를 정말 써야 할 때는 아 매개 변수나 함수 이름에 오한 덜 이걸
붙여서 너 를 반환하거나 닫을 수 있다는 것을 얘기해 주자
다섯번째 맺으면 법 절대 쓰지 말아라 쓸 이유 자체가 없다
여섯번째 이프 문이 복잡하게 인데 테이션 들어가면 이렇게 어려우니까 그냥
아닌 조건 더 빨리 판단에서 얼리 엑시 패 버려라
일찍 에 찍 반응해 버리는 게 최고다 그럼 마지막 티 리
정말 사람을 상대하고 이제 뭐 목숨이 달린 이런 부분에서는 당연히 해야
되는거 더 문제 하는거 잡아야 되니까 조치 말
제품의 퀄리티 자체는 일단은 테스트 플랜 이라던가 스펙이 부시도 좌지우지
하지
유니테스트 가 좌지우지할 게 아냐 좌지우지 하지 않는다
그리고 이 테스트를 하기 전에 자동화 테스트 api 자동화 테스트 스모크
테스트 엔텔스 테스트 인텔의 테스트 부터 하는게 훨씬 더 효율적이다
그거 다 하고 나서 정말 추가는 테스트를 눌 이제 그 여력이 있으면 위
테스 타자 그거 아니면 은
이거 한다고 시간낭비 하는게 오히려 낭비일 수도 있다
좀 그렇게 해서 이것까지 정리할게요 40분 찍었으니 까 아 이제 끊도록
하고요
즐겁게 보셨다면 이제 구독을 눌러주시면 저한테 많은 도움이 됩니다
구독 7만 5천명 찍으며 는 무슨 트로피 준대요
그래서 찍어보고 싶어 예 포크 했습니다
