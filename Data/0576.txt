안녕하세요, 포프입니다.

오늘 하는 얘기가 다소 낯설게 느껴지시는 분들이 좀 있을 것 같아요. 왜냐하면 이게 굉장히 흔하게 얘기해 왔던 프로그래밍의 기본 구성 요소인데, 어느 순간 약간 좀 사라졌어요. 이게 제 생각에는 모든 게 포인터인 자바가 흥하면서 그랬던 것 같은데, 많은 사람들이 이런 얘기하죠? 'null은 악마다'. 그래서 C++ 만드신 분도 'null을 없애지 못해서 너무 아쉬웠다' 이런 얘기하는데, 결과적으로 null이라는 개념은 어떤 개체가 있잖아요? 모든 게 참조형인 언어에서는 개체로 존재를 하고 그러면 '개체가 없다'라는 표현, 결과적으로 boolean값이에요. 그 논리값을 하나에 뭉쳐놓은 겁니다. 개체 + 있다, 없다. 그래서 이게 null이면 false에요. 없는 거고, null이 아니면 개체가 있는 거예요. 이 두 개를 한 군데 합쳐놓은 거예요. 한 자료형에 실제 유효한지 아닌지를 판단하는 논리값까지 합쳐놓은 거. 이게 nullable 타입입니다. 한마디로 참조형이에요.

그런데 이 nullable 타입이 아닌 경우에도 똑같은 개념이 사실 있어요. 그게 sentinel value라고 하는 거예요. sentinel이라고 하면 감시, 감시자거든요? 그래서 이거를 감시 값, 감시 값이라고 해요. 그래서 대표적인 예가 뭐냐? 문자열 연산들. 문자열 함수들 보다 보면 가끔 '이 문자열 안에서 이 문자가 어디 있는지 위치를 알려줘' IndexOf라는 함수를 모든 언어가 보통 가지고 있어요. 그럼 이 함수가 반환하는 값이 0부터 시작해서 실제 이 문자를 배열로 세워놨을 때, 색인가 어딘지 그 숫자를 반환합니다. 못 찾으면 뭐를 반환해요? 이거 모르시면 당신은 주니어예요. -1. 왜? 배열 색인에서 유효한 값은 0부터 위 값이에요. 근데 유효하지 않은 값? 그럼 0보다 전이네? -1. 근데 이 색인을 부호 없는 정수로 반환하는 라이브러리들도 있어요. 부호 없는 정수는 -1과 대응하는 비트 패턴과 똑같은 값이 있어요. UINT_MAX 값을 반환해요. 그러면 -1을 반환할 때는 이해할 수 있어요. 어차피 나올 수 없는 값이니까. 근데 얘도 감시 값이에요. 그러면 최대 값은 뭐예요? 원래는 유효한 범위인데 그냥 여기서 한 값을 뺄 거예요. 그래서 '이 값은 유효하지 않다'라고 가정을 해요. 그래서 유효한 범위 중에 값에서 딱 하나, 그나마 가장 안 나올 것 같은 가장 큰 값이죠? 그 값을 빼서 이게 나오면 얘는 유효하지 않은 거, '문자를 못 찾았어'라는 값을 알려주는 겁니다. 즉, 뭔가 하나가 실제 우리가 유효하지 않은 값이 나올 때를 대비해서 뽑아놓은 값, '이 값이 보이면 유효하지 않다는 의미야'라는 게 sentinel value입니다.

sentinel value는 사실 굉장히 여러 군데서 볼 수 있어요. 그중에 하나가 IndexOf, 또 하나가 null이라는 값입니다. 제가 이 이야기를 왜 하냐면 데이터베이스 ORM을 쓰거나 하면 참조형 같은 거 넣고, 아니면 DTO 같은 거 attribute 검증할 때, 이런 경우에 보면 null 값이 들어오면 이 JSON 파일에서 '이 값이 없었기 때문에 유효하지 않으니까 이거 이거 안 넣어줬어. 제대로 넣어줘'라고 400 베드 리퀘스트 반환하면서 '이게 없어'라고 말하는 attribute를 많이 박아요. 그러다가 갑자기 정수값이나 부호 없는 정수값이 들어올 때는 얘가 참조형이 아니라 값형이거든요? 그러면 얘가 null이 기본적으로 안 돼요. 그럼 null이 안 되니까 '이 값이 들어오지 않았다'는 판단을 할 수가 없어요. 그러면 괜히 얘를 nullable 타입으로 바꿔요. 그리고 null이 들어오면 '값이 없었다'고 얘기하고, 숫자가 들어오면 '올바른 값이 들어왔다'고 하는 거예요. 그래서 이렇게 코드를 원래 null이 안 되는 것에다가 null을 넣다 보면 되게 복잡해져요. 기본적으로 로직이 돌 때는 null이 될 수가 없어요. 검증을 위해서만 있는 거예요. 검증을 통과하면 얘가 null이 아니거든요? 근데 코드에서 nullable로 되어 있으니까 이게 null이 들어오는데 null이 아니라고 가정하고 코드를 작성하다 보니까 코드도 길어지고 쓸데없는 디버그 체크 넣게 되고 굉장히 복잡해집니다.

그래서 이거를 조금만 더 잘 고민하면 결론은 이렇게 나와야 해요. 자 생각을 잘해봐요. 어떤 참조형을 DTO에서 들고 있을 때 기본값을 아무것도 세팅이 안 되는 null로 넣어줍니다. 그래서 우리가 null이라고 알 수 있는 거예요. 그게 운 좋게도 sentinel value기 때문에 우리는 이거에 의존하는 거예요. 그러면 정수형이라고 생각을 해봐요. 얘가 어떤 색인 값이에요. 그럼 DTO로 들어올 때, 아니면 웹 요청이 들어올 때 값이 없을 수도 있어요. 근데 얘가 색인 값이거든요? 값이 없으면 얘를 실제 우리가 개체로 만들 때 어떤 값을 대입을 안 해주면 생성 시에 기본값이 유지가 될 겁니다. 아무 값도 대입을 안 해줬으면 0인 거잖아요? 그래서 지금 문제가 생긴 거잖아요? 그럼 차라리 기본 생성자에서 이 값을 감시 값으로 대입을 해줘요. 그리고 감시 값이 바뀌지 않았다면 400 반환하면서 '올바른 요청이 아니다'라고 오류 메시지를 만들어주면 되는 겁니다.

그래서 실제 올바른 감시 값만 받고 attribute만 잘 박아주면 이게 언어에서 값형과 참조형이 둘 다 존재하면서 이 문제가 생긴 거긴 한데, 이런 문제들을 실제 로직 작성하는 코드에서는 뺄 수가 있는 거예요. 검증에 대한 검증이 끝나는 겁니다. 이거를 실제 검증이 끝나고 다시 내부에서 도는 클래스를 따로 만들어서 중간에 DTO 변환한 다음에 사용하는 경우도 있어요. 코드 정말 복잡해지거든요? 똑같은 거 하는 클래스 5~6개 만들어야 되거든요? 쓸데없이 그러기보다, 좀 더 생각을 한 다음에 null이 감시 값였다는 것만 알면 정수 배열의 색인에서 사용하는 것의 감시 값은 -1이면 될 거고, 그게 아닌 정수값이면 INT_MAX, 아니면 INT_MIN을 뽑아서 '이 값은 죽어도 우리가 사용하지 않는 값이다.'라는 가정을 세워서 감시 값으로 만들고, 이 값이 들어와서  그대로 유지가 됐을 경우에는 유효하지 않은 값일 때 오류를 만들게 자동화를 할 수가 있어요. 저희도 이걸 깨달은 다음에 회사 코드 베이스에서 예전에 있던 null 떡칠들을 많이 빼버리면서 굉장히 깔끔해지고 있어요. 그리고 이거를 해결하는 방식 중에 하나가 C#에서 나왔던 nullable 참조라는 기능이 있어요. '그 기능이 이거를 완벽하게 해결해 줄 수 있지 않을까?'라는 고민을 많이 해온 것 같은데, 결론부터 말하면 NTT 프레임워크에서 사용하는 NTT 클래스라고 하죠? 거기에는 이게 꽤 도움이 됩니다. 직렬화, 역직렬화하는 로직 자체가, 그리고 DB column required하고 선택적으로 만들어주는 옵션 자체가 굉장히 nullable 참조하고는 잘 돌아요. 근데 이게 JSON으로 직렬화, 역직렬화되는 쪽 라이브러리까지 올라오면 굉장히 안 예뻐요. 그리고 '?'을 다는 거, 이거의 의미가 달라요. 참조형에 다는 거랑 값형에 다는 거랑 많이 달라지거든요? 그래서 그것까지 생각하면 깔끔하게 코드 정리가 안 되기 때문에, 차라리 그냥 옛날 방식대로 코드를 작성하되, 감시 값을 잘 작성해서 이거에 따라 attribute 검증을 하는 게 훨씬 깔끔한 코드가 나오긴 하더라고요. 그리고 이 nullable 참조 관련 이야기는 다른 에피소드에서 한 번 더 얘기할 것 같아요.

여기까지 얘기하면 이제 sentinel value가 뭔지도 이해하셨을 것 같고, 이거를 잘 사용하면 값형을 nullable로 만들어서 이상한 DTO 검증까지 했던 그런 핵을 많이 걷어내실 수 있을 거라 생각 합니다. 저희 회사 코드도 깔끔해져서 너무 행복합니다.

포프였습니다.