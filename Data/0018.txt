C++에 추가된 기능 중에 유니크 포인터(Unique Pointer)라는 게 있어요. 

스마트 포인터 중 하나인데 여태까지는 오토 포인터라는 게 있었잖아요? 

자체적으로 레퍼런스 카운터 유지해 가지고 그게 0이 되면은 자동으로 해지해 주는 포인터가 있었는데, 저는 개인적으로는 그걸 한 번도 사용해본 적이 없어요. 

가장 큰 이유는 제가 엔진 쪽 작업을 많이 하기 때문에 그렇게 범용적인 스마트 포인터는 필요가 없었고, 성능상의 문제도 있고, 내부적으로 사용자가 사용을 잘 못하면 메모리 누수(leak)가 발생할 수 있는 일이 생겨서 개인적으로 한 번도 쓴 적이 없었거든요... 

근데 유니크 포인터라는 거는 저도 쓸 일이 있더라고요. 

유니크 포인터가 뭐냐면 오토 포인터하고는 다르게 레퍼런스 카운터는 없어요. 

그 대신에 유니크 포인터에는 '소유'라는 개념이 있거든요. 

그래서 유니크 포인터가 가리키는 개체(object)가 파괴되는 시점은 유니크 포인터가 지워질 때에요. 

범위(scope) 밖으로 나가거나 유니크 포인터를 담고 있는 객체가 지워질 때, 유니크 포인터가 가리키는 객체도 같이 지워지는... 그래서 저는 이것을 어디서 많이 썼냐면은 private 멤버 중에 생성자에서 new를 통해서 만들어야 하는 게 가끔 있잖아요? 

그러면은 private 멤버이기 때문에 외부에서는 이 포인터를 가져가지 못하고 내부에서 파괴가 될 때 delete를 호출해줘야 하는 건데, delete를 호출하지 않아도 자동적으로 지워지게 하는 용도로 좀 많이 썼고, 싱글턴 클래스 만들 때 포인터 저장해두는 그런 개념으로... 이것도 나쁘지 않았어요. 

여전히 어떻게 생각해보면 유니크 포인터도 잘 못쓰면 문제가 생길 수 있을 것 같긴 한데, 제가 생각하는 사용 범위 내에서는 굉장히 직관적인 스마트 포인터고 사용도 굉장히 간단해요. 

delete를 호출하는걸 잘 챙기는 게 훌륭한 프로그래머의 자질이기도 하지만 사실 상당히 귀찮은 일이거든요... 

그런 일을 일일이 해 주지 않아도 되는 거에서 굉장히 훌륭한 것 같아요.

그래서 저는 제한적으로 유니크 포인터를 사용하고 있어요. 

지금까지 사용한 바로는 상당히 만족스럽고 특별히 성능 상의 문제를 가져 올 부분도 없는 것 같아요. 

오토 포인터처럼 Ref 카운터를 해야 되는 것도 아니고, 멀티스레드 들어가다 보면은 경쟁상태(Race Condition)가 생길 수 도 있는데 이걸 막는다고 락 걸다 보면 성능 저하가 심한데 그런 게 없다는 점에서 저는 상당히 마음에 들어요. 

혹시라도 파괴자(destructor)에서 매번 delete 지우기 귀찮으신 분들, 그리고 포인터가 언제나 private 멤버에 있고 
밖으로 나갈 일이 없는 경우라면 꼭 써보시라고 추천하고 싶어요... 상당히 좋아요.
