안녕하세요, 포프입니다.
오늘은 세 편 연속으로 거의
'생각하며 코딩 좀 하자' 라는 시리즈인 것 같은데
저번 두 편을 만들고 나서 이번에서야
이 시리즈가 뭔지가 생각이 난 것 같아요.
이번에는 메타프로그래밍. 
C++ 메타프로그래밍에 대해 설명을 좀 해볼게요.
이 메타 프로그래밍이 뭐냐면
메타(meta-)라는 말이 들어가면은
아... 어떻게 얘기를 하면 좋을까
모든 영어에서 메타가 들어가면요
그거는
'진정한게 아니다', '어떤 부수적인 거다' 
이런 느낌이 강해요
예를 들어서
어...
뭐...
롤(LOL)을 많이 하시잖아요
리그 오브 레전드
거기서 메타 게임이라는게 있잖아요. 
뭐냐면
실제 게임에서 있는 룰은 아닌데 
사람들이 자기 위치를 미리 정해놓고 한다는 것
서포터, 탑, 바텀 이런 것
그런걸 한다거나
그 외에 스킬트리는 어떻게 찍는게 좋다 
이러이러한 것들을
그런걸 메타 게이밍이라고 해요
그래서 메타프로그래밍도 
조금 그런 개념이에요
원칙적으로는 이게 
올바른 프로그래밍 방향은 아니야
아니면 올바르다는 얘기보다는
전통적인 프로그래밍 방향은 아닌데
그...
C++에서 제공하는 템플릿이라는게 있어요
이 템플릿이 원래 나왔던 이유는
조금 다른 개념인데
그 기능들을 전부 이용해서
'프로그래밍을 짜자'라는 개념이에요.
그러니까
템플릿이라는게 어떻게 되냐고 말씀드리면
C#하고는 좀 달라요. 
C++은, 예를 들어서
가장 편한 예가 벡터같은, 
벡터라고 안하죠.. ArrayList.
그런 벡터 같은게 있는데 
벡터를 할 때
이렇게 세모난 괄호(ex. <int>, <string> etc.)를 양쪽으로 열고 
타입을 지정해 주면은
그 타입만 받아들이는,  
그런 변수형이라고 해야 될까? 
벡터가 만들어진다고 보시면 맞아요
그러면 그거에 따라 그 변수만 집어넣을 수 있게
그런데 이게 언어 차원에서 지원을 하는건데 
각 괄호 두 개가 열리는 순간 뭐가 생기냐면은
C#에서는 이걸 실행 중에 처리해주는건데
C++에서는 이 괄호에 들어온 
이 값이 있잖아요
그러면,  그 값이 달라지는 경우 
예를 들어서
하나는 int고,  
두 번째 것은 unsigned int 야.
그러면 그 두 개 용으로 코드를 완벽히 따로 만들어줘요
그러니까
이것을 실시간으로 해서 체크를 하려면 
예전에 포인터로 체크했듯이
뭐 포인터, 캐스터하고 이런식으로 했던가? 
직접 수동(Manual)으로?
아니면은 typedef을 쓴다면
여기서 아, 이 컨테이너에 있는 타입이 이거니까
이거는 이렇게 처리하고
이 안에 이거니까 저렇게 다른 함수를 호출해 처리해
이렇게 해서 실시간으로 브랜치를 갈라야 하는데, 
실행시에.
이 템플릿을 쓰면은
그게 컴파일 중에 끝난다는 거예요
컴파일 중에 끝나서 완벽히 새로운 코드를 줘버려요
그래서 이제
그러면 결과적으로는
제가 이것을 가지고
그 폴리모피즘(polymorphism)이라는거 있죠. 다형성.
이게 정적 다형성이라고 부르는 사람도 봤어요
저는 좀, 아직도 그것은 동의하진 않지만
왜 그렇게 부르는지는 알겠다는 거예요
실제는
ArrayList라는, 그러니까 벡터라는 똑같은 타입인데
그 안에 어떤 타입 변수를 넣어주냐에 따라
그거에 따라 다른 behavior가 나오잖아요
그러고 다른 behavior가 컴파일 도중에 결정이 되버리니까
이건 정적인 것이다라고 하는 거예요
물론 이런 경우에는 int와 unsigned int를
같은 컨테이너에 못넣죠
그래서 이걸 활용해서 만든다고 나온게
템플릿 메타프로그래밍 쪽인데
이것도 제가 저번 편
소프트웨어 아키텍쳐 얘기할 때랑 똑같은 걸로
그 때 얘기한 것과 똑같은 얘기를 할 수 있는게
이게 처음 나왔을 때, 템플릿 코딩 같은게
처음 나왔을 때 사람들이
오! 이걸 하면은 코드 속도도 빨라지고 굉장하겠다
컴파일 시 자기가 다 해버리니까
그래서 엄청 남용을 한거예요
새로운 것이니까 써보자!
'새로운 것이니까 써보자'
이런 식으로
그래서 이걸로 떡칠이 된 코드 베이스를 몇 번 본 적이 있어요
그런데 지금은 다,
보통 끄집어 냈죠
아직도 이것을 쓰고 있는 회사가 있다면
그거는
저는 굉장히 걱정이 되요
일단 이게 왜 문제냐면
디버깅 하기가 일단 만만치가 않아요
일단, 뭐 이제는 비주얼 스튜디오가 조금 나아져서
디버깅이 그나마 되긴 되는데
브레이크 포인트를 거는 순간
그.. 예를 들어서 아까 벡터라는 것이
예를 들어서 100가지 타입으로 썼다
그럼 브레이크 포인트 거는 순간
100가지 타입이 같이 걸려버리는 거죠
그러면 나중에 브레이크 포인트 거는데
다른 것을 다 제거하고 내 것만 본다거나,
그리고 컴파일 중에 나오는 에러도
굉장히 좀 기묘해요
왜냐하면은 컴파일 도중에
얘는 단순히 어떻게 하는거냐면
예를 들어서 제가 벡터 몰을 만들고,
아니면 이 타입을 만들고
이 클래스 안에서 이 타입에다 
어떤 함수를 호출하는 거예요
그런데 컴파일 하기 전까지는 얘가,
이 타입이 무엇인지 모르기 때문에
뭐 어떻게 이게 에러가 나고 말해주는건 별로 없고
컴파일 하는 순간 할 수 있는 얘기는 꼭 
'그 함수가 이 int에 없어'(그 타입에 그 함수가 없음) 이게 전부에요
그런데 그게...
그런데 그게...
좀 뭐라 그럴까
제대로 된 에러라고 보기엔 되게 어려운게
컨테이너 같은 경우에는 되게 단순하게 할 수 있는데
내가 스스로 템플릿 코드를 만들고
막 이것저것 집어넣다가 뭐 하나 바꿨는데
다른 오브젝트 지원하는게 있어서 다 망가진다거나
뭐 이런 이상한 일들이 생겨요
그래서...
일단 코드 가독성이 떨어지고
디버깅 하기가 조금 애매해지고
거기에 템플릿 메타프로그래밍을
어떤 용도로 생각하시면 되냐면
옛날에 그 #ifdef로 해가지고
if define 뭐 이런거 해가지고, define이구나
#define 해가지고 
거기다가 함수를 다 만든 다음에
그 define를 써가지고 함수를
그냥 코드로 바꾸는 경우도 있었잖아요
그거를 조금 현대화(modern화) 시킨게
메타프로그래밍이라고 보시면 맞아요 사실은.
그런데 그것보다 조금 나아졌죠
여러가지 체크라던가
그런데...
이렇게 템플릿 메타프로그래밍을
해야되는 경우가 솔직히 그렇게 없거든요
템플릿 메타프로그래밍을 하는 경우가
결과적으로 뭐냐는 것을 고민해보면
이제 #define에 쓰던 것을 대체하려고 하는 것
그런데 그거는 이미
'그럴 바엔 차라리 함수를 써라
거기서 얻을 수 있는 성능 향상은
이제 무시해도 괜찮을 정도다'라는게
일반적인 방향이잖아요
그래서 굳이 거기서는 이유를 못찾겠고
두 번째는 코드 최적화라는 얘기가 있는 거예요
아까 말했듯이 타입을 중간에 if else 문으로 해야 되면은
코드를 이제..
중간에 브랜치를 언제나 깔아야 되니까
최적화에 문제가 있다
그러면 차라리 코드를 두 개 만들게(generate) 시켜서
아예 브랜치를 뺀 코드가 빠를 수 있다
음...
대답은 맞을 수도, 틀릴 수도 있어요
현재 되게 모든 시스템이 재밌어진게
캐시 사이즈라던가,
하드웨어 CPU에 있는 캐시 사이즈
이런 것 때문에
최근에는 대부분,
언제나는 아니에요
코드를 컴파일 할 때
코드 사이즈를 작게 컴파일 하는 것
함수를 만들더라도,
이 함수를 여러 번 호출하더라도
코드 사이즈를 작게 만드는게
성능이 빠른 경우가...
버퍼링...
대부분이라고 할 수는 없고
버퍼링...(2)
성능이 빠른 경우가 성능이 느린 경우보다는 많아요
그리고 그 정도, 50% 이상은 가죠
그 정도는 가죠
그래서
심지어는 코드를 이제 컴파일러,
C++ 컴파일러로 코드를 컴파일 할 때도
어떤 경우에는 본인 스스로 인라인을 해버릴 수가 있어요
인라인을 한다는건 코드를 복사하겠다는 거예요
함수 호출을 안해버리고.
그래서 코드를 크게 만드는 대신
함수 호출을 줄이는 방법이 있고
아니면 코드를 작게 만드는 대신
함수 호출을 더 잦게 만드는, 자주 만드는 것도 있죠
그런데 현재로서는, 되게 재밌는게
대부분의 코드 베이스에서, 절반 이상은
코드 사이즈가 작은게 성능이 더 빨라요
그럼 그거는 템플릿 코드 메타프로그래밍과는
전혀 반대라는 얘기구요
그리고 정말 말 그대로...
뭐라 그럴까...
템플릿 메타프로그래밍을 써야하는 경우가 있다
이거는.. 저는 말 그대로...
최적화?
타이핑을 줄이기 위해서?
뭐 이정도인데...
생각보다
뭐 이제는 메타프로그래밍이 아니라
템플릿 프로그래밍
템플릿 프로그래밍에서 타이핑을 줄일 수 있는 건 맞아요
그래서 저는 컨테이너 쪽,
그러니까 벡터라던가 Array(배열) 쪽에는
템플릿 쓰는 것을 허용을 해요, 사실은.
왜냐하면 벡터에 무슨 오브젝트가 들어갈지도 모르는데
그것을 다 Array로 만들기도 귀찮고
Array를 만들어서 무슨 if else 치기도 귀찮고
그래서 거기는 제가 허용을 하는데
Math, 그러니까 수학 함수에서까지도
과연 메타프로그래밍을 써야하는가에 대해
저는 굉장히 회의적이에요
특히 게임 쪽에서.
Matrix라던가... 행렬이요.
행렬을 게임 속에서 쓸 때 몇 곱하기 몇이 생길 수 있어요
2×2, 3×3, 4×4가 전부에요
그러면...
여기서 뭘 더... 
차라리 만들고 말지
이걸 왜 굳이 메타프로그래밍을 써서
더 복잡하게 만드냐구요
그리고
뭐 수학도 비슷해요
보통은 float 계열의 수학공 하나하고
게임 쪽에서는 보통 float 아니면 int로 끝나죠
unsigned int에 매스 함수를 따로 제공할 필요가 있나요?
어차피 뭐 이렇게 C++에서
더해버리면 int로 가버리잖아요, 곧바로
그러니까 그런 것들을 생각해 보면은
메타프로그래밍을 좀 남용하는 경향이 있어요
물론 제가 말했듯이
아까 말했던 컨테이너, 이런건 좋은 거고
그리고 정말...
제가 써본 경우가 한 번 있는게
렌더링 파이프라인 만들다가
한 코드가...
이렇게 한... 50줄 정도 되는 어떤 함수가 하나 있었어요
그런데 그 함수가 렌더링 엔진 것인데
이게 한...
한 프레임에 한 1,000번 정도가 불린다고 보면 맞아요
그러면 1,000번 호출하는데 보니까
거기서 호출할 때 패러미터가 하나 있어요
하나는 이거고, 하나는 이거에요
패러미터가 둘 중에 하나로 바뀌는데
그 때마다 if else를 돌려야 하는 거예요
그래서 그거를 실제 그 패러미터를
메타프로그래밍화 시켜서
그 부분을 함수를 2개로,
코드 제네레이션 레벨에서 코드가 2개 나오게 해버리면
성능 향상이 엄청나거든요
그래서 그런 경우는 이해가 되요
정말 왜냐하면 50줄의 코드를 또 복사해 놓고
공통되는 코드가 별로 없어요
그게 또 문제인데
뭐, 다른 함수도 할 수는 있었지만...
이것을 2개로 분리해 놓고 유지보수를 하려고 보면은
여기 1줄 바꿀 때 여기도 1줄 바꿔야 하거든요
그런데 그게 안되는거야
아니 그게 헷갈리는, 실수를 더 유발하는거죠
그리고...
그런 경우에는 약간은 이해가 되요
이 함수가 정말 미친듯이 불리고
이게 정말 Bottleneck(병목현상)이었거든
그런데 이제, 그런 경우에는 메타프로그래밍을 쓰는데...
또, 그런 경우에 딴지거는 사람도 있어요
'이거는 메타프로그래밍을 쓰는게 아니야'라는 걸로
그래서...
아니, 그러니까 템플릿 프로그래밍은.
그래서...
'이 템플릿 프로그래밍은 반드시 타입을 
바꾸기 위해 쓰는거야' 이런 식의 사람들이 있는데...
저는...
그것도 아니라고 보거든요
저는 기본적으로
코드는 유지보수가 쉽고 가독성이 좋은게
최고라고 생각해요. 뭐든 간에
그리고 성능의 향상을 위해서는 당연히
어느 정도의 융통성은 있어야 하는데
그것은 이제 자기 판단이고
자기가 만드는 소프트웨어가 어떤건지에 대한 판단이죠
그거는 제가 저번 편에서도 말했고.
그런데 이제 너무 쓸데없이 메타프로그래밍을
남용하는 것을 막자는 것이 제 취지였구요
전에도 말했듯이 새로운 것이라고
반드시 다 해야하는 것은 아니고
새로운게 정립될 때까지는 안쓰는게 맞아요
제가 다녀 본, 소프트웨어를 제대로 개발하는 회사들은
새로운 기술이 나오면 업그레이드를 일단 안해요
아무리 좋은게 있어도 조금 지켜봐요
업데이트가 나올 때까지는.
왜냐하면은
그 순간에 그것을 도입함으로서 나오는 문제점들을
고치는데 일단 인건비를 낭비하기 싫다는 거구요
누군가는 베타 테스팅을 해주는건데
내가 하기는 싫다죠
두 번째는...
그거에 이제 문제가 생기면
다시 돌려놓으면 될거 아니냐는 얘기가 나와요
그런데 재밌는게 뭐냐면...
이미 한 3개월을 개발하다가 문제를 발견했어
그런데 이걸 되돌리기에는
이미 새 기능을 너무 많이 쓰고 있어
그런데 이 버그는 굉장히 치명적이야. 돌리지를 못해. 
이런 경우 있잖아요.
그저 뭐든간에...
그 제품의 안정성을 좀 추구하는 분들,
그런 분들은 그런걸 되게 주의해요. 
새로운 기능이 나올 때 일단 안쓰고 봐요.
아니면 일단 자기가 확답이 서기까지.
이게 확실히 올바른 것이고 
여기서 단점이 오는거를, 장점이 훨씬 낫기 때문에 가자
이런게 그렇게까진 잘 안가요 
그래서 그런게 되게 중요한 것 같아요
그래서...
버퍼링...(3)
다 좋은 개념이고, 다 제대로 쓰면 좋은데
이..
뭔가를 제대로 쓴다는 개념이...
뭐랄고 할까, C++가 굉장히 자유로운 언어다보니까 
되게 힘든 것 같아요
그리고 어찌보면은...
더 큰 문제는 C++이 여전히
Backward compatibility 잖아요 
그러니까.. 후방 호환성?
그거를 유지하기 위해 
그전 거를 안빼내는 거예요
그게 더 문제일 수도 있어요
예를 들어서 C#이라던가 어떤 언어를 보면 가끔가다
그러니까... 
어떤 회사가 주도하는 언어든...
그런거, 파이썬도 한 번 그랬었죠 사실은.
그랬거든요. '후방 호환성 여기서 지원 안돼. 
우리는 여기서 딱 멈추고 새로운 버전을 시작한다고'
그게 필요해요. 왜냐하면
그걸 안하면 옛날 거에, 
이미 실수를 많이할 수 있는 부분에 문제가 있는데
그거하고, 새롭게 실수 안할 수 있는 부분을 엮으면서 
합쳐지면서 실수가 더 많아지는 경우도 있거든요
그래서 이건 언어 디자인의 문제고
어찌보면은 이제 C++ commit...
뭐라 그럴까 Open committee라고 그러나? 
걔네들 Standard committee의 문제일 수도 있어요
OpenGL도 이제 OpenGL을 지원하다 한계를 느껴서 
Vulkan이라고 새로 만들 듯이
그런식으로 어느 순간에는  
다음 버전으로 넘어가야 한다고 보고
파이썬도 2.x에서 3.0으로 올라가면서
버전 2개 유지하고 있잖아요. 2.x하고 3.0하고
그래서 아직도 2.x를 많이 쓰지만
옛날... 후방 호환성을 위해서
새로운 기능들, 좀 더 안전한 코드
뭐 이런건 3.0에서 주로 강화되고 있고
그래서...
그냥.. 이것도 제가 봤던 것들 중에
굉장히 자유로운 언어와, 새로운 스펙이 나오고...
그 자유로움 속에서 얼마나 많은 것을 망가트려 놨는지...
그...
프로그래머들이... 좀 많이 망가트려놨어요. 그런 부분을...
그래서...
어떤 언어든간에 기본적인 동작은
전에도 몇 번이나 얘기 했지만 
실수가...
실수를 최소한 적게 만들 수 있는
기본적인 동작을 만들어야 한다고 보거든요
그리고...
정말 그 자유로움을
맘껏 누릴 수 있는 프로그래머들이 있어요
정말... 디자인, 어느 디자인이든 확실히 보고
뭐가 문제인지도 알고
언어 하이... 그러니까 언어...
이렇게 고수준의 언어부터 저수준의 언어를 비롯해서,
하드웨어와 시스템과,
이 모든게 어떻게 도는지 이해하시는 분들이 있어요
그런 분들만이 그런 자유를 누리면서
뭔가를 뒤에서 바꾸는게 맞는거죠
그게...
제가 rust language가 좋다고 한 이유가 그거예요.
rust language는 제가 봤던거 모두 모드는
기본 동작 하나하나에는 정말 실수를 못하는데
그 기본 동작을 벗어나서
내가 다른 것을 할 수 있는 자유도가 있어요
그래서...
다시 rust lang을 좀 빨았고...
음...
그 정도, 오늘 얘기는
결과적으로 했던 얘기는
메타프로그래밍이라는 그...
메타라는게 들어가는 순간...
이미 뭔가 잘못하고 있다는 것이구요...
템플릿 프로그래밍은 쓸만한 곳이 있구요
그런데... 주로 컨테이너 외에는
제가 아직 그닥 그렇게 유효성을 못봤고
그 범위를 넘어서서 메타프로그래밍이나
템플릿 프로그래밍을 해야 하는 상황이 오면은
진짜 곰곰히 고민해보세요. 이거 왜 필요한지.
본인이 확신할 수 있을 때 하세요
이거는 정말 대충하다가는 
코드 유지보수 정말 안되는 코드 나와요.
정말 힘들어지고...
뭐 그정도... 음...
예, 포프였습니다.
